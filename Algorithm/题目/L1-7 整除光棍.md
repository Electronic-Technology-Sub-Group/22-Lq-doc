> 2021年团体程序设计天梯赛-模拟赛

# 题目

这里所谓的“光棍”，并不是指单身汪啦~ 说的是全部由 1 组成的数字，比如 1、11、111、1111 等。传说任何一个光棍都能被一个不以 5 结尾的奇数整除。比如，111111 就可以被 13 整除。 现在，你的程序要读入一个整数 `x`，这个整数一定是奇数并且不以 5 结尾。然后，经过计算，输出两个数字：第一个数字 `s`，表示 `x` 乘以 `s` 是一个光棍，第二个数字 `n` 是这个光棍的位数。这样的解当然不是唯一的，题目要求你输出最小的解。

提示：一个显然的办法是逐渐增加光棍的位数，直到可以整除 `x` 为止。但难点在于，`s` 可能是个非常大的数 —— 比如，程序输入 31，那么就输出 3584229390681 和 15，因为 31 乘以3584229390681 的结果是 111111111111111，一共 15 个 1。

### 输入格式

输入在一行中给出一个不以5结尾的正奇数 $x<1000$。

### 输出格式

在一行中输出相应的最小的 `s` 和 `n`，其间以 1 个空格分隔。

### 输入样例

```in
31
```

### 输出样例

```out
3584229390681 15
```

### 代码限制

- 代码长度限制：16 KB
- 时间限制：400 ms
- 内存限制：64 MB

# 思路

咋一看好像是一个高精度问题，Java 和 Python 的话大数也能做，但实际上从数学上来看，不需要使用大整数

问题关键在于，每增加一位 1，其除数和余数的结果可通过递推获得

设 $k_n=\underbrace{111\cdots 111}_{n 个 1}=s_n\times x + m_n$，即 n 个 1 组成的数被 $x$ 除商 $s_n$ 余 $m_n$，
则有 $s_{n+1}=s_n\times 10+(m_n\times 10+1)\div x$，$m_{n+1}=(m_n\times 10 + 1)\mod x$

因此，每增加一位 1，其商可以直接在上次的商之后增加 (上一次除法的余数x10+1)/x 即可，不需要高精度。

# 答案

```c++
#include <iostream>
  
using namespace std;  
  
int main() {  
    int x;  
    cin >> x;  
  
    int m = 1, len = 1;  
  
    // 初始化：111...111 >= x  
    while (m < x) {  
        m = m * 10 + 1;  
        len++;  
    }  
    cout << m / x;  
    m %= x;  
  
    while (m % x != 0) {  
        m = m * 10 + 1;  
        cout << m / x;  
        m %= x;  
        len++;  
    }  
  
    cout << ' ' << len;  
    return 0;  
}
```
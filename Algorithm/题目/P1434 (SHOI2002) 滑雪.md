> 【动态规划1】动态规划的引入
> https://www.luogu.com.cn/problem/P2196

# 原题

Michael 喜欢滑雪。这并不奇怪，因为滑雪的确很刺激。可是为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。Michael 想知道在一个区域中最长的滑坡。区域由一个二维数组给出。数组的每个数字代表点的高度。下面是一个例子：

```
1   2   3   4   5
16  17  18  19  6
15  24  25  20  7
14  23  22  21  8
13  12  11  10  9
```

一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度会减小。在上面的例子中，一条可行的滑坡为 24-17-16-1（从 24 开始，在 1 结束）。当然 25－24－23－…－3－2－1 更长。事实上，这是最长的一条。

## 输入格式

输入的第一行为表示区域的二维数组的行数 R 和列数 C。下面是 R 行，每行有 C 个数，代表高度(两个数字之间用 1 个空格间隔)。

## 输出格式

输出区域中最长滑坡的长度。

## 输入样例

```
5 5
1 2 3 4 5
16 17 18 19 6
15 24 25 20 7
14 23 22 21 8
13 12 11 10 9
```

## 输出样例

```
25
```

## 说明

对于 100% 的数据，$1\leq R,C\leq 10$。

# 思路

带备忘录的递归

# 答案

```c++
//
// Created by lq200 on 2022/11/28.
//

#include <iostream>
#include <list>

int r, c;

int inputs[100][100], path[100][100];

using namespace std;

void search(int i, int j) {
    if (path[i][j] == -1) {
        path[i][j] = 0;
        if (i != 0 && inputs[i][j] < inputs[i - 1][j]) {
            search(i - 1, j);
            if (path[i][j] < path[i - 1][j]) {
                path[i][j] = path[i - 1][j];
            }
        }
        if (i != r - 1 && inputs[i][j] < inputs[i + 1][j]) {
            search(i + 1, j);
            if (path[i][j] < path[i + 1][j]) {
                path[i][j] = path[i + 1][j];
            }
        }
        if (j != 0 && inputs[i][j] < inputs[i][j - 1]) {
            search(i, j - 1);
            if (path[i][j] < path[i][j - 1]) {
                path[i][j] = path[i][j - 1];
            }
        }
        if (j != c - 1 && inputs[i][j] < inputs[i][j + 1]) {
            search(i, j + 1);
            if (path[i][j] < path[i][j + 1]) {
                path[i][j] = path[i][j + 1];
            }
        }
        path[i][j]++;
    }
}

int main() {
    cin >> r >> c;
    if (r == 1 && c == 1) {
        printf("1");
        return 0;
    }

    for (int i = 0; i < r; ++i) {
        for (int j = 0; j < c; ++j) {
            cin >> inputs[i][j];
            path[i][j] = -1;
        }
    }

    int max = 0;
    for (int i = 0; i < r; ++i) {
        for (int j = 0; j < c; ++j) {
            search(i, j);
            if (max < path[i][j]) {
                max = path[i][j];
            }
        }
    }

    cout << max;
    return 0;
}
```
```
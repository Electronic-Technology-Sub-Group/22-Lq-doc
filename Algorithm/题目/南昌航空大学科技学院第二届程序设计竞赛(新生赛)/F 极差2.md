链接：[https://ac.nowcoder.com/acm/contest/48725/F](https://ac.nowcoder.com/acm/contest/48725/F)  
来源：牛客网  
  
# 原题

学姐给定了 n 个整数 $a_1$ , $a_2$, ⋯, $a_n$。现在她可以进行至多 m 次操作（也可以一次也不进行），每次操作可以执行以下两条之一：

-   选择一个最小值 $a_i$ 将该值等于数据中的最大值
-   选择一个最大值 $a_i$ 将该值等于数据中的最小值

现在学姐希望需要最小化最终序列的极差（最大值减去最小值的差）。请求出最小的极差。

例如，对于序列 $a=\{5,1,4\}$ 可以进行如下几次操作：

-   选择 $i=1$，满足 $a_1=5$ 是当前的最大值 5，可以将 $a_1$ 修改成当前的最小值 1，此时序列变成 $\{1,1,4\}$
-   再选 $i=2$，满足 $a_2=1$ 是当前的最小值 1，可以将 $a_2$ 修改成当前的最大值 4，此时序列变成 $\{1,4,4\}$。

这两次操作后得到的序列为 $\{1,4,4\}$。最大值减去最小值的差为 $∣4−1∣=3$。

当然，这种操作方式得到的极差并非最小。最优策略是，先将最大值 $a_1=5$ 变成目前的最小值 1，再把此时的最大值 $a_3=4$ 变成目前的最小值 1。此时序列为 $\{1,1,1\}$，得到的极差 $∣1−1∣=0$ 是所有策略中最小的。  

## 输入描述:

> 第一行有两个正整数 n, m，分别表示序列的长度和你最多可以进行的操作次数。
>
> 第二行有 n 个整数 a，描述给定的序列

## 输出描述:

> 输出共一行一个整数，表示最优策略下能得到的最小极差。

**示例1**

## 输入

```
3 2
5 1 4
```

## 输出

```
0
```

## 说明

> 样例 1：$\{5,1,4\}→\{1,1,4\}→\{1,1,1\}$，极差为 0。

**示例2**

## 输入

```
8 0
1 2 3 4 5 6 7 8
```

## 输出

```
7
```

## 说明

> 样例 2：$\{1,2,3,4,5,6,7,8\}$，什么也做不了，极差为 7。

**示例3**

## 输入

```
8 3
1 5 5 5 6 6 9 10
```

## 输出

```
4
```

## 说明

> 样例 3：$\{1,5,5,5,6,6,9,10\}→\{10,5,5,5,6,6,9,10\}→\{5,5,5,5,6,6,9,10\}→\{5,5,5,5,6,6,9,5\}$，极差为 4。

## 备注:

对于全部数据，保证 $1≤n≤10^5$，$0≤m≤10^9$，$∣a_i∣≤10^9$。

# 思路

- 当移动次数 $m=0$ 时，无操作，极差即最大值减最小值
- 当移动次数 $m>=n$ 时。足够将所有值替换成最大值或最小值，极差为 0
- 先将输入的数字排序，极差最小的情况出现在替换满 $m$ 次时。若先将 $k$ 个最大值替换成最小值，则同时会增加 $k$ 个最小值，想要再替换掉当前最小值需要至少替换 $k+1$ 次。因此最多向一个方向替换 $m/2$ 次，否则无意义。

# 答案

```c++
#include <iostream>  
#include <algorithm>  
  
using namespace std;  
  
int main() {  
    int n, m;  
    cin >> n >> m;  
  
    // m >= n - 1 时，极差恒为 0
    if (m >= n - 1) {  
        cout << 0;  
        return 0;  
    }  
  
    int nums[n];  
    for (auto &item: nums) cin >> item;  
    sort(nums, nums + n);  
  
    // m == 0 时，就是原队列的极差  
    if (m == 0) {  
        cout << nums[n - 1] - nums[0];  
        return 0;  
    }  
  
    int v = nums[n - 1] - nums[0];  
    for (int i = 0; i <= m / 2; ++i) {  
        // 先替换 i 个最大值，再替换 m - 2i 个最小值  
        int v1 = nums[n - 1 - i] - nums[m - 2 * i];  
        // 先替换 i 个最小值，再替换 m - 2i 个最大值  
        int v2 = nums[n - 1 - (m - 2 * i)] - nums[i];  
        v = min(v, min(v1, v2));  
    }  
    cout << v;  
    return 0;  
}
```
> 2021年团体程序设计天梯赛-总决赛

# 原题

![[Pasted image 20230112171307.png]]

上图转自新浪微博：“阿里代码库有几亿行代码，但其中有很多功能重复的代码，比如单单快排就被重写了几百遍。请设计一个程序，能够将代码库中所有功能重复的代码找出。各位大佬有啥想法，我当时就懵了，然后就挂了。。。”

这里我们把问题简化一下：首先假设两个功能模块如果接受同样的输入，总是给出同样的输出，则它们就是功能重复的；其次我们把每个模块的输出都简化为一个整数（在 **int** 范围内）。于是我们可以设计一系列输入，检查所有功能模块的对应输出，从而查出功能重复的代码。你的任务就是设计并实现这个简化问题的解决方案。

## 输入格式

输入在第一行中给出 2 个正整数，依次为 N（$\leq 10^4$）和 M（$\leq 10^2$），对应功能模块的个数和系列测试输入的个数。

随后 N 行，每行给出一个功能模块的 M 个对应输出，数字间以空格分隔。

## 输出格式

首先在第一行输出不同功能的个数 K。随后 K 行，每行给出具有这个功能的模块的个数，以及这个功能的对应输出。数字间以 1 个空格分隔，行首尾不得有多余空格。输出首先按模块个数非递增顺序，如果有并列，则按输出序列的递增序给出。

注：所谓数列 $\{A_1, A_2, \cdots, A_M\}$ 比 $\{B_1, B_2, \cdots, B_M\}$ 大，是指 $\exists 1\leq i<M$，使 $\forall 1\leq k\leq i$，$A_k=B_k$，$A_{i+1}>B_{i+1}$

## 输入样例

```
7 3
35 28 74
-1 -1 22
28 74 35
-1 -1 22
11 66 0
35 28 74
35 28 74
```

## 输出样例

```
4
3 35 28 74
2 -1 -1 22
1 11 66 0
1 28 74 35
```

## 代码限制

- 代码长度限制：16 KB
- Java (javac)
	- 时间限制：1500 ms
	- 内存限制：128 MB
- Python (python3)
	- 时间限制：1500 ms
	- 内存限制：64 MB
- 其他编译器
	- 时间限制：500 ms
	- 内存限制：64 MB

# 思路

还是计数+排序，主要是 STL 标准库容器的使用，使用 `map` 计数可有效防止 TLE。

要想实现使用 `map` 排序，或者使用 `sort`，`set` 等，都需要对应数据实现 `<` 运算符，或者自定义比较函数。

记得之前做过一道题使用 `set` 去重+排序的来着，数据进入 `set` 容器后即完成了从小到大排序操作。这道题去重时候还需要计数，因此需要二次排序。

# 答案

```c++
#include<iostream>  
#include<algorithm>  
#include<vector>  
#include<map>  
  
using namespace std;  
  
int n, m;  
  
struct Record {  
    int *values;  
    int count{1};  
  
    explicit Record(int *values, int rid) : values(values) {}  
  
    Record(const Record &v, int count0) : values(v.values), count(count0) {}  
  
    bool operator<(const Record &v) const {  
        if (count == v.count) {  
            for (int i = 0; i < m; ++i) {  
                if (values[i] == v.values[i]) {  
                    continue;  
                }  
                return values[i] < v.values[i];  
            }  
            return false;  
        }  
        return count > v.count;  
    }  
  
    void print() const {  
        cout << count;  
        for (int i = 0; i < m; ++i) {  
            cout << ' ' << values[i];  
        }  
        cout << endl;  
    }  
};  
  
int main() {  
    cin >> n >> m;  
  
    map<Record, int> counter;  
  
    // 输入+计数  
    int *values = nullptr;  
    for (int i = 0; i < n; ++i) {  
        if (values == nullptr) {  
            values = new int[m];  
        }  
        for (int j = 0; j < m; ++j) {  
            cin >> values[j];  
        }  
        Record r = Record{values, i};  
        if (counter.count(r)) {  
            counter[r]++;  
        } else {  
            counter[r] = 1;  
            values = nullptr;  
        }  
    }  
  
    // 合并计数数据+排序  
    vector<Record> records;  
    for (auto &item: counter) {  
        records.emplace_back(item.first, item.second);  
    }  
    sort(records.begin(), records.end());  
  
    cout << records.size() << endl;  
    for (const auto &item: records) {  
        item.print();  
    }  
  
    return 0;  
}
```
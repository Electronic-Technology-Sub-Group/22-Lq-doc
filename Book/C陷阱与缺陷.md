# 词法陷阱

> [!note]
> 符号：`token`，指程序的一个基本组成单元，相当于一个句子中的单词。符号是程序中的一个基本信息单元。

词法陷阱讨论符号和组成符号的字符之间的关系，及有关符号含义的误解。
## 常见混淆

- `=` 与 `==`
- `&`，`|` 与 `&&`，`||`
## 词法分析中的“贪心法”

> [!quote]
> 如果（编译器的）输入流截止至某个字符之前都已经被分解为一个个符号，则下一个符号将包括从该字符之后可能组成一个符号的**最长**字符串。

编译器进行词法分析时，自左向右一个个读入字符，直到读入下一个字符后与已组成的字符串无法组成一个新符号，这可能引发*准二义性（near-ambiguity）*问题，如：

```c
a---b;
y = x/*p;
```

其解析结果为：

```c
// --- 解析为 -- -
a -- - b ;
// /* 解析为 /* 而非 x / (*p)
y = x /* p;
```
## 整形常量

以 0 开头的整形字面量被认为是八进制数
## 字符（串）

双引号引起的字符串，代表的是一个指向字符数组的起始指针，并在串最后追加一个 `\0`。
# 语法陷阱

指程序语法中，定义与人们直觉相悖，或容易引起混淆的部分。
## 类型声明

C 语言任何变量声明都由 *类型* 以及 *一组类似表达式的声明符* 组成，对表达式进行求值后应返回一个声明中给定类型的结果。

将变量声明中的变量名部分去掉，加括号包围即可用于类型转换。

任何声明构造都可以按照一条简单规则创建：*按照使用方式声明*

```c
// 例1
float f, g;
```

例1：当对其求值时，`f`，`g` 的类型应当为 `float` 类型

```c
// 例 2
float ((f));
```

例2：当对其求值时， `((f))` 值类型应当为 `float`，因此该语句声明了一个变量 `f`，类型为 `float`

```c
// 例 3
float *g();
```

例3：`()` 优先于 `*`，`g` 是一个函数（注意**不是**函数指针），该函数的返回值类型为 `float*` 

```c
// 例 4
float (*h)();
```

例4：`*h` 是一个函数，因此 `h` 是一个函数指针，该函数返回值类型为 `float`

例n，如果我们要构造一个模拟计算机启动，从首地址为 0 位置运行的例程，可以进行如下构造：

```c
(*(void(*)())0)();
```

1. 设启动函数 `void bootstrap()`
2. 由于我们从地址调用，转换为函数指针形式：`void (*bootstrap)()`
3. 抹去变量名，变成类型转换的形式：`(void (*)())`
4. 将地址为 0 强转为对应函数指针类型：`(void(*)())0`
5. 解引用，调用函数：`(*(void (*)())0)();`

通过 `typedef` 简化，可以表示的更加清晰：

```c
typedef void (*funcptr)();
(*(funcptr)0)();
```
## 运算符优先级

位运算符的优先级很低，甚至低于逻辑运算符

```c
int p = flags & FLAG != 0;
int r = hi << i + low;
```

该语句被解释为：

```c
// 预期可能为 (flags & FLAG) != 0
int p = flags & (FLAG != 0);
// 预期可能为 (hi << i) + low
int r = hi << (i + low);
```

修改方法：
- 使用括号
- 将 `+` 变更为 `|`（特指第二个样例），但这又涉及到位运算与逻辑运算的优先级

优先级分组可更利于记忆：

1. 运算符总体顺序为：系统 > 数学，单目 > 双目 > 三目 > 逗号，算术 > 位运算 > 关系 > 逻辑 > 赋值 > 条件
2. 最高优先级的运算符其实不是真正的运算符：函数调用 `()`，下标访问 `[]`，指针访问 `->`，成员访问 `.`
3. 一些单目但由系统而不是数学定义的运算符：`sizeof`，取址`&`，解指针 `*`，强转 `(type)`
4. 单目运算符在所有数学运算符中优先级最高：取负 `-`，`--`，`++`，`~`，`!`
5. 双目运算符中，算术运算符 > 位移 > 关系运算符 > 逻辑运算符 > 赋值运算符 > 条件运算符
	1. 任何一个逻辑运算符优先级都低于任何一个关系运算符
	2. 任何一个位移运算符优先级低于算术运算符，但高于关系运算符
	3. 关系运算符中，`==`，`!=` 低于其他关系运算符
	4. 任何两个逻辑运算符都具有不同的运算优先级，`&` > `^` > `|`
	5. 任何两个赋值运算符的优先级是相同的，从右向左逐步执行
6. 三目运算符 `?:` 优先级仅次于 `,` 运算符
7. 逗号运算符 `,` 优先级最低，该运算符多用于需要一个表达式而不是一条语句的情况下替换语句结束的 `;`
## 分号

- 流程控制语句中，多写、少写分号导致语义不同，但语法没有错误

例1：`if`，`while` 等控制语句不加大括号时，多加 `;` 导致控制语句脱离条件

```c
if (x[i] > big); // 这里多了分号
    big = x[i];
```

相当于

```c
if (x[i] > big) {}
big = x[i];
```

例2：`return` 后少写分号，导致错误的执行逻辑和返回值

```c
if (n < 3) 
    return // 这里少了分号

logrec.data = x[0];
logrec.time = x[1];
logrec.code = x[2];
```

相当于

```c
if (n < 3)
    return locrec.date = x[0];

logrec.time = x[1];
logrec.code = x[2];
```

- 声明后缺少分号

例：声明结构体缺少分号，且函数返回 int 但省略：

```c
struct logrec {
    int date;
    int time;
    int code;
} // 这里少了分号

main() {
    // ...
}
```

相当于后接的函数返回值类型为该结构体

```c
struct logrec {
    int date;
    int time;
    int code;
} main() {
    // ...
}
```
## switch

`switch` 有时遗漏 `break` 由于 `fall-down` 特性造成歧义。

几种比较好的习惯是：
- 给所有 `case` 子块都增加 `break`
- 仅无代码的块允许无 `break`
- 在没有 `break` 的 `case` 子块中通过注释标明本身就应没有 `break`
## 悬挂 else

`else` 始终与同一 `{}` 内最近的没有 `else` 的 `if` 配对，在一些嵌套中，尤其是内层隐式的退出函数时，容易发生匹配错误

```c
if (x == 0)
    if (y == 0) error();
else {
    z = x + y;
    return z;
}
```

由于 `error()` 通常是产生异常并中断执行，可能会造成本层 `if` 已经结束的歧义。实际上其结构为：

```c
if (x == 0) {
    if (y == 0) {
        error();
    } else {
        z = x + y;
        return z;
    }
}
```
# 语义陷阱

该章节讨论在语法、语义上均正确的情况下，仍有歧义或与本意不同的情况。
## 数组

C 语言中数组的特点：

- C 语言**只有**一维数组，且（C99前）数组长度必须在编译期确定。多维数组是 *数组的数组* 模拟出来的。

例：`int calendar[12][31]` 是一个拥有 12 个元素的数组，每个元素是 31 个整形的数组

```c
int calendar[12][31];
// 1488 = 12 * 31 * sizeof(int)
sizeof calendar;
// 124 = 31 * sizeof(int)
sizeof calendar[0];

int *p;
// 编译错误
p = calendar;

int (*pp)[31];
// ok
pp = calendar;
```

- 任何一个对数组的操作都是通过**指针**完成的，任何一个数组下标运算都等同于对指针的运算。

陷阱：

- 一个指针与整形进行运算，与指针地址值加上同一个整形的值不同，指针运算的一个单位是原始类型的长度

```c
int k, *p = &k;

unsigned long long v1 = (unsigned long long) p + sizeof(int);
unsigned long long v2 = (unsigned long long) (p + 1);
int dv = (int *) v1 - p;

// 1 1
printf("%d %d", v2 == v1, dv);
```

- 数组为函数传参时，会退化成指针，即抹去数组长度；即函数形参列表中，`[]` 与 `*` 等价，只是想表达的侧重点不同

- `sizeof` 如果对一个数组使用，取得的是整个数组占用的内存空间；如果对一个指针使用，则返回一个指针变量的长度

- 由于数组下标运算实质是指针运算，`i+a` 与 `a+i` 等效，因此 `a[i]` 与 `i[a]` 等效，即一个 `下标[数组]` 与 `数组[下标]` 等效

- 注意 C 字符串是一个指针，空指针并非空字符串

- C 字符串以 `\0` 结尾，因此 `strlen` 算出的长度比占用的空间少 1 个 char

- 数组长度 = 上界 - 下界，下界永远不可能小于上界
	- 不对称边界：假设两个指针（下标）分别代表数组的开始与结束，则第一个指针指向第一个元素，第二个指针指向最后一个元素的下一个元素
	- 允许获取数组最后一个元素的下一个元素的地址（用于比较），但不允许访问其值
## 求值顺序

- 存在中断的运算符：`&&`，`||`，`?:`
## 整数溢出

当两个数字都是有符号整形时，可能发出溢出。使用 `a + b < 0` 校验是不准确的。

正确校验整形溢出的方法有：

```c
// 1 将无符号转换为有符号，与 INT_MAX 比较
if ((unsigned) a + (unsigned) b > INT_MAX) { /* 溢出 */ }

// 2 使用减法
if (a > INT_MAX - b) { /* 溢出 */ }
```
## main 返回值

- 返回 `int` 的函数，如果省略返回值，则该函数返回值具体是什么是未定义的

- 函数返回值类型可省略，默认为 `int`

C语言 `main` 函数返回值是有意义的，表示程序是否正常执行。因此，应当使用 `return 0;` 而不是省略返回值。
# 连接

将多个编译过的 C 程序合并成一个整体的过程称为连接。

> [!note]
> 分别编译：Separate Compilation，若干个源文件可以在不同的时候单独进行编译，然后在恰当的时候整合在一起

> [!note]
> 外部对象：external object，代表内存的某个部分，并通过一个外部名称识别。程序中每个函数和非 `static` 的外部变量都是外部对象

对于函数，发生命名冲突一般会直接禁止，无法完成连接；对于变量，则比较复杂。
## 声明与定义

- 在所有函数体之外定义的非 `static` 变量，称为外部变量

```c
int a = 7;
```

- 使用 `extern` 修饰，即使在函数中，表示该变量是对其他地方的变量的引用（类似函数头），编译器不会为其分配内存

```c
extern int a;
```
## 命名冲突

- 在多个文件声明同名外部变量，要么引发命名冲突无法连接，要么两个变量共享相同内存地址。

- 若要避免使用相同地址，可以使用 `static` 修饰，表示该变量仅在当前文件中有效，与其他文件中同名外部变量不会冲突

```c
static int a;
```
## 形参、实参、返回值

- 函数在调用之前，应当被定义或声明（函数头）

- 若定义在其他文件，但没有在调用前声明，则函数返回值应为 `int`，否则连接器行为未定义
## 外部类型

- 应确保 `extern` 声明的变量与实际声明的变量类型相同，否则行为是未定义的 - 连接器不会识别和检查 c 类型
## 头文件

- 每个外部对象都应只在一个地方中声明，即该源码对应的头文件中
# 库函数

多数情况下库函数不会有什么问题，但某些情况下库函数表现出的行为往往有悖于其本意。
## getchar

- `getchar` 多数情况下应返回一个 `char`，但若没有输入时返回 `EOF` 为一个整形
## 更新顺序文件

- `fwrite` 后如果需要直接读取，应当插入一个 `fseek`

```c
struct record rec;
FILE *fp;*
fwrite(msg, ((char*) &rec, sizeof(rec), 1, fp);
// fwrite -> fread 之间必须插入一个 fseek 用于改变文件状态
fseek(fp, 0L, 1);
fread(...);
```
## 缓冲区

在使用 `setbuf` 设置流缓冲区时，不能使用局部的缓冲区数组

```c
int main() {
    char buf[BUFSIZ];
    setbuf(stdout, buf);

    return 0;
}
```

以上程序是错误的。在 `main` 函数执行完成后，C 会最后一次清空缓冲区，此时已经在 `buf` 生存周期之外。

正确做法是使用静态成员变量，或者堆内存

```c
int main() {
    // 静态成员
    static char buf[BUFSIZ];
    setbuf(stdout, buf);
    // 堆内存
    setbuf(stdout, malloc(BUFSIZ));
}
```
## errno

系统库失败时会将异常信息通过 `errno` 传递出。但标准库并未强制要求在没有失败时库函数一定要设置 `errno` 为 0，在调用成功时也不强制要求设置为 0。因此，我们应先检测作为错误指示的返回值，确定程序失败。
## signal

在使用信号量处理中断时，需要时刻注意：
- 谨慎或禁止使用库函数，因为中断可能在一些复杂库函数中触发（如 `malloc`）
- 在处理一些错误时，如算术运算错误，我们不可能在中断中修正操作数，中断返回后仍会触发错误，正确的办法是使用 `longjmp` 或 `exit` 立刻退出程序
# 宏定义
## 宏定义中的空格

在创建宏时，宏名称与参数之间不能存在空格

```c
#define f (x) ((x)-1)
```

上面的宏中，`f` 与 `(x)` 之间多了一个空格，因此相当于：

```c
#define f (x)((x)-1)
```
## 宏不是函数

宏只是查找替换，不是函数，因此可能出一些问题：

- 优先级问题

```c
#define abs(x) x>0?x:-x
```

当调用 `abs(a-b)` 时，被替换为 `a-b>0?a-b:-a-b`，明显在 `-a-b` 实际应该为 `-(a-b)`。因此修改为：

```c
#define abs(x) (x)>0?(x):-(x)
```

上面的宏定义还有问题，即与外部其他内容的优先级问题，如 `a-abs(a-b)` 展开为 `a-a-b>0?a-b:-a-b`。因此修改为：

```c
#define abs(x) ((x)>0?(x):-(x))
```

- 副作用问题

```c
#define max(a,b) ((a)>(b)?(a):(b))
```

在下面的代码中：

```c
biggest = x[0];
int i = 1;
while(i < n) {
    biggest = max(biggest, x[i++]);
}
```

展开为

```c
biggest = x[0];
int i = 1;
while(i < n) {
    biggest = ((biggest)>(x[i++])?(biggest):(x[i++]));
}
```

可见，在某些分支中，`i++` 被执行了两次。

- 当宏非常复杂或嵌套使用时，可能展开为一个很长的语句

```c
// ((a)>(((b)>(((c)>(d)?(c):(d)))?(b):(((c)>(d)?(c):(d))))?(a):(((b)>(((c)>(d)?(c):(d)))?(b):(((c)?(d)?(c):(d))))))
max(a, max(b, max(c, d)));
```
## 宏不是语句

假设我们要模拟 `assert` 创建一个宏定义：

```c
#define assert(e) if(!e) assert_error(__FILE__.__LINE__)
```

但当使用在 `if` 语句中时：

```c
if (x > 0 && y > 0)
    assert(x > y);
else 
    assert(y > x);
```

替换后为：

```c
if (x > 0 && y > 0)
    if (!x > y) assert_error("???.c", 99);
else
    if (!y > x) assert_error("???.c", 99);
```

重新缩进一下，即可看到我们改变了运行逻辑！

```c
if (x > 0 && y > 0)
    if (!x > y)
        assert_error("???.c", 99);
    else if (!y > x)
        assert_error("???.c", 99);
```

事实上其实现方式为：

```c
#define assert(e) ((void)((e)||assert_error(__FILE__.__LINE__)))
```

即使之变成一条表达式
## 宏不是类型定义

宏可以用于为类型起别名

```c
#define FOOTYPE struct foo
FOOTYPE a, b, c;
```

但当我们为指针起别名时，

```c
#define T struct foo *
T a, b;
```

其展开为 `struct foo *a, b`，可见 `b` 并不是指针。

这种情况应当使用 `typedef` 替代 `#define`

```c
typedef struct foo *T;
T a, b;
```
# 可移植性缺陷
## 整数范围

- `short`，`int`，`long` 类型长度是非递减的，只要 `short` 长度不高于 `int`，`int` 不高于 `long` 即可。事实上 `long` 通常与 `int` 相同。
- `int` 类型足够大，足以容纳任何合法的数组下标
- 字符长度由硬件特性决定，`long` 至少 32 为，`short`、`int` 至少 16 位
## char 符号

如果需要无符号字符类型，使用 `unsigned char`，不要使用 `(unsigned) c` 的写法，因为这样会先将原数字转换为 `int`
## 位移运算符

- 对于无符号数，向右移位时填充 0；有符号数填充 0 还是符号位未定义
- 不可能在单次操作中将某个数值的所有位都移出 - 若长度 n 位，则被移位操作数 $0\le m\lt n$
- 负数的位移不能完全取代除法：`(-1)>>1` 一般非 0，但 `(-1)/2` 为 0
## 内存位置 0

`NULL` 指针是否能访问，访问结果是未定义的
## 除法

```c
q = a / b;
r = a % b;
```

C 语言保证：
- $q*b+r==a$
- 当 $a\ge 0$ 且 $b>0$ 时，$|r|<|b|$ 且 $r\ge 0$
不能保证：
- 当 `b>0` 时，$r\ge 0$ 且 $r<b$
## 随机数

`rand` 函数生成的最大值为 `RAND_MAX`

# 结构化绑定

> [!note]
> 结构化绑定：将一个或多个名称绑定到目标对象的一个或多个成员元素上

C++ 11 引入元组的概念，使 C++ 支持直接打包多个元素，并在现有的语法上配合引用实现了类似结构化绑定的特征：

```c++
// 创建元组
std::tuple<int, double, float> tuple = std::make_tuple(10, 2.0, 1.99f);

// 类似结构化绑定的用法
int a;
double b;
float c;
std::tie(a, b, c) = tuple;
// a=10, b=2.0, c=1.99f
printf("a=%d, b=%lf, c=%f", a, b, c);
```

C++ 17 开始从语法上支持结构化绑定，并允许使用 `auto` 进行类型推断

```c++
// 创建元组
std::tuple<int, double, float> tuple = std::make_tuple(10, 2.0, 1.99f);
// 结构化绑定
auto [a, b, c] = tuple;
```

注意 a，b，c 这里不是引用，而是一个独立的变量（`tuple` 值的副本），虽然称为别名

> [!warning]
> 事实上，结构化绑定的实现可能是编译器产生一个变量，等于右边目标对象对应成员 

如果需要获取引用的绑定，使用 `auto&`

```c++
// 创建元组
std::tuple<int, double, float> tuple = std::make_tuple(10, 2.0, 1.99f);
// 结构化绑定
auto& [a, b, c] = tuple;
```

结构化绑定不仅支持元组，其支持绑定任何数组和对象，但有一定的限制。每个绑定都相当于一组变量声明，因此同一个作用域的结构化绑定中变量名不能相同。

对于数组，编译器要求必须知道数组的长度。此时应注意数组退化，一旦退化成指针则无法进行绑定。

对于对象，要求有以下内容：
- 所有成员必须是 `public` 的（C++ 20 前）
- 被绑定的变量数量必须与类非静态成员变量数量相同
- 所有变量必须存在同一个类或基类中
- 类和结构体中不能存在匿名联合体（union）

C++ 20 之前要求对象成员必须是 `public` 的，20 及之后允许根据当前作用域判断元素是否可被访问。
## 类元组绑定

结构化绑定类元组是以类似元组的形式进行绑定。C++ 绑定到元组实际上并不要求目标类型是元组，而是需要满足以下几个条件（其中 `T` 为目标类型，`t` 为目标类型的一个实例，`i` 为第 i 个元素）：
- 满足 `std::tuple_size<T>::value` 是一个符合语法的表达式，其中 `value` 即左侧标识符列表中别名个数
- 满足 `std::tuple_element<i, T>::type` 是一个符合语法的表达式，其中 `type` 是第 i 个元素的类型
- 类型 `T` 必须包含以下模板函数：`get<i>()` 或 `get<i>(t)`，返回第 i 个元素的值

标准库中除了 `std::tuple`，符合以上条件的还有 `std::pair`，`std::array`
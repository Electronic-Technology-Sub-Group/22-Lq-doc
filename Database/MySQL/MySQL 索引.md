# 概述

Index，帮助 MySQL **高效获取数据**的**有序数据结构**。这些数据结构以某种方式引用数据，以此基础上可以开发高级查找算法。

优点：降低查询时 IO 成本和排序时的成本
缺点：占用空间，降低更新表的效率（insert，update，delete 等）

# 结构

索引结构因引擎而异，不同引擎的支持和实现不同：

| 索引结构              | 描述                                                         | 引擎           |
| --------------------- | ------------------------------------------------------------ | -------------- |
| B+Tree 索引           | 最常见索引                                                   | 大多数均支持   |
| Hash 索引             | 使用哈希表实现，效率高，但支支持精确匹配搜索，不支持范围查询 | 仅 Memory 支持 |
| R-tree （空间索引）   | MyISAM 的特殊索引类型，主要用于存储地理空间数据              | 仅 MyISAM 支持 |
| Full-text（全文索引） | 类似 Lucene，Solr，ES 等，通过建立倒排索引快速匹配文档       | Memory 不支持  | 

## B+Tree

B-Tree 是一颗可以有多个节点的树。最大度数 n 称为 B 树的阶数，存在 n-1 个数字，n 个指针。

![[Pasted image 20230722121758.png]]

当插入数字后某个节点满时（此时有 n 个数字），中间元素将向上分裂插入到父节点，剩余元素分裂成两个节点。

B+Tree 是 B-Tree 的变种
- 所有元素都会出现在叶节点，其余节点仅作为索引使用
- 所有叶节点相互连接，之间形成一条单向链表

![[Pasted image 20230722122724.png]]

当 B+Tree 某节点元素满时，中间节点向上裂变，但会保留一份留在分裂后的叶节点之中，并与另一个叶节点之间形成链表。

用于索引的 B+Tree 在 B+ 树的基础上，将叶节点之间的单向链表修改为环形双向链表，提高区间访问性能和排序效率

![[Pasted image 20230722123150.png]]

```ad-hint
不使用二叉树：数据库数据通常较多，B+Tree 层级更少
不使用 B-Tree：在非叶节点也保存数据，会导致可存储指针减少，树高度增加
不使用 Hash：不支持范围索引
```

## Hash

哈希结构通过一定的 Hash 算法将键值数据转换为 Hash 值，并将其映射到对应的槽位+链表上。

由于 Hash 冲突很少发生且不反映数据本身的大小关系，该索引对相等比较 `=`，`in` 等及查询操作效率很高（通常只需要一次检索），但无法利用索引完成排序操作。

- 目前，MySQL 中仅 Memory 引擎支持 Hash 索引
- InnoDB 存在自适应 hash 功能，在某些特定情况下可以根据 B+Tree 索引自动构建 Hash 索引。

# 分类

根据索引类型：

| 索引类型 | 含义                             | 关键字   |
| -------- | -------------------------------- | -------- |
| 主键索引 | 针对主键创建的索引               | primary  |
| 唯一索引 | 避免同一个表中某列存在相同数据   | unique   |
| 常规索引 | 快速定位数据                     |          |
| 全文索引 | 查找文本中的关键词而非索引中的值 | fulltext |

- 主键索引仅能创建一个，且由数据库自动创建。其他索引可以创建多个
- 建表时使用 `unique` 关键字修饰字段会自动创建唯一索引

根据储存形式（InnoDB）：

| 索引类型                 | 含义                                 |
| ------------------------ | ------------------------------------ |
| 聚集索引 Clustered Index | 将所有索引存在一起，叶节点保存行数据 |
| 二级索引 Secondary Index | 将索引与数据分离，叶节点保存主键     | 

- 聚集索引有且只有一个
	- 如果存在主键，主键索引即聚集索引
	- 如果不存在主键，使用第一个唯一索引作为聚集索引
	- 如果不存在主键和唯一索引，InnoDB 自动生成唯一 `rowid` 作为隐藏的聚集索引
- 二级索引又称辅助索引、非聚集索引，可以有多个

![[Pasted image 20230722125135.png]]

```ad-info
回表查询：进行不以主键为关键字的具体查询时，先通过二级索引查询主键值，然后再通过聚集索引查询具体行数据
```

# 语法

## 创建

```mysql
create [unique | fulltext] index 索引名 on 表名 ( 字段1, 字段2, ... );
```

- unique | fulltext：索引类型（唯一索引、全文索引），省略表示常规索引
- 索引可以关联多个字段，仅关联一个字段的索引称为单列索引，关联多个字段的索引称为联合索引或组合索引
	- 联合索引需要考虑字段顺序
	- 建议使用联合索引，效率更高
- 索引名通常遵循 `idx_表名_字段名` 的命名规则

### 查看索引

```mysql
show index from 表名;
```

### 删除索引

```mysql
drop index 索引名 on 表名;
```

# 性能分析

## 执行频率

一般来说，性能优化主要优化查询。MySQL 可以使用以下命令查询某数据库中某个操作的访问频次，包括 `insert`，`update`，`delete`，`select`。当 `Com_select` 频次较高时可重点进行优化

```mysql
show [session | global] status like 'Com_______';
```
- `Com_______` 匹配 `Com_insert`，`Com_update` 等

## 慢查询日志

慢查询日志记录了 MySQL 中执行时间超过指定参数（`long_query_time`，默认 10s）的所有语句日志，默认未开启，需要修改 `my.cnf` 开启

查看慢查询日志是否开启，显示 `ON` 即开启。Windows 默认开启，Linux 默认关闭。

```mysql
show variables like 'slow_query_log';
```

开启慢查询日志修改配置文件 `/etc/my.cnf`，增加以下两行：

```
# 开启慢查询日志
show_query_log = 1
# 设置记录到慢查询日志的 SQL 语句执行时间为 2s
long_query_time = 2
```

之后重启 MySQL 服务器即可。

慢查询日志存放于 `主机名-slow.log` 中，Linux 下在 `/var/lib/mysql/` 目录中，Windows 下则在 `ProgramData\MySQL\MySQL Server 8.0\Data` 目录下。

## profile

通过 `show profiles` 指令可以显示每一条语句的耗时详情。

使用前先查看是否支持，返回 `YES` 即支持

```mysql
select @@have_profiling;
```

检查是否开启了 profile，返回 1 即开启

```mysql
-- 检查是否开启
select @@profiling;
-- 开启
set profiling = 1;
```

开启后便可以查询所有指令的耗时时间

```mysql
show profiles;
```

根据上一步给出的结果中的 `query_id`，可以进一步查询其耗时的详细信息

```mysql
-- 检查每个执行阶段的耗时
show profile for query query_id;
-- 检查 CPU 使用情况
show profile cpu for query query_id;
```

```ad-warning
MySQL 5.7+ 推荐使用 Performance_shema 取代 profile
```

## explain

使用 `explain` 查看 MySQL 的执行计划，可以查询 select 命令执行过程中表如何连接、连接顺序、使用到的索引等情况

```mysql
-- 可以使用 explain 或 desc 均可
explain select ...;
desc select ...;
```

- `id`：执行顺序；值越大越先执行，值相等从上到下执行
- `select_type`：查询类型，参考意义不大
	- `simple`：简单表，不使用表连接或子查询
	- `primary`：主查询（外层查询）
	- `union`：union 中第二个及之后的查询语句
	- `subquery`：select/where 中包含的子查询
- `type`：连接类型，以下自上而下性能逐渐变差
	- `NULL`：查询不访问任何表（类似 `select 值` 这样的语句直接返回值）
	- `system`：访问系统表
	- `const`：根据主键或唯一索引访问
	- `eq_ref`：子查询的 `const`
	- `ref`：使用非唯一索引进行访问
	- `range`
	- `index`：遍历整个索引树
	- `all`：全表扫描
- `possible_key`：可能用到的索引
- `key`：实际使用到的索引
- `key_len`：使用到的索引字节数，索引字段可能的最大长度。不失真的情况下越短越好
- `rows`：执行查询的行数（InnoDB 为预估值）
- `filter`：查询行数占总读取行数的百分比，越大越好
- `extra`：额外信息

主要关注的字段有 `type`，`possible_key`，`key`，`key_len`，`rows`，`extra`。

# 使用原则

## 索引失效

某些情况下，数据查询不会通过索引：

- 最左前缀法则：联合索引中，查询需要从索引最左列开始，不跳过索引中间列
	- 跳过则产生索引部分失效现象，跳过字段之后的字段全部失效
	- MySQL 8+ 不包含最左侧列时不会全部失效
- 范围查询：联合查询时出现 `>`, `<` 范围查询，索引失效
	- 尽量使用 `>=`，`<=` 即可使用索引
- 不要在索引列上进行运算，否则索引失效
- 字符串类型不加引号索引失效（隐式类型转换）
- 模糊查询 `%` 放在开头会使索引失效
- `or` 连接时，若前后两个条件存在无索引的情况，另一个条件索引失效
	- 可使用 `union` 或 `union all` 规避
- 数据分布影响：若 MySQL 评估使用索引比全表扫描更慢，索引失效
	- 当大多数甚至所有数据都符合条件时，MySQL 自动使用全表扫描，此时效率比索引更高

## SQL 提示

当某个查询可以选择多个索引时，MySQL 可以自动评估效率最高的一个索引。但我们可以通过 SQL 提示向 SQL 语句中人为插入提示选择索引达到优化效果
- use index：建议 MySQL 使用某索引
- ignore index：使 MySQL 忽略某索引
- force index：强制 MySQL 使用某索引

```mysql
select * from 表 use|ignore|force index(索引名) where ...
```

## 覆盖索引

覆盖索引：在查询中使用了索引，且查询需要返回的列在索引中已经全部找到，则只返回索引的列（也可以包含主键），不要返回其他数据或 `select *`，可以省去一次[[#分类|回表查询]]。

在此种情况下，根据条件和返回值涉及的字段建立联合索引通常比只根据条件建立的索引效率更高

## 前缀索引

当存储的数据为字符串，且字符串很长时，针对其建立的索引会很大，查询时也会浪费大量的磁盘 IO。此时仅使用字符串的部分前缀作为索引可以节约索引空间，提高索引效率

```mysql
create index 索引名 on 表名(字段名(字符串前缀长度));
```

长度通常根据索引的选择性决定，选择性指不重复的索引值与记录总数的比值，越高则查询效率越好。可以直接通过 `select` 查询出条目数后相除获取

```mysql
select count(distinct substring(字段名, 1, 长度)) / count(*) from 表名;
```

# 设计原则

- 针对数据量大（>100W），查询频繁的表建立索引
- 针对常用于查询 `where`、排序 `order by`、分组 `group by` 操作的字段建立索引
- 尽量选择区分度高的列（重复元素少）作为索引，尽量使用唯一索引
- 长字符串可以考虑前缀索引
- 尽量使用联合索引而非单列索引，利用覆盖索引的特性，节省存储空间，避免回表
- 控制索引数量，减少维护索引结构的代价（影响增加、删除、修改表的效率，空间占用）
- 若索引列不能存储 NULL 值，使用 `not null` 约束，方便 MySQL 优化
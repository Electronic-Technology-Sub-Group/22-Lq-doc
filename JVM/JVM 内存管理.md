# 运行时数据区

![[Pasted image 20230220083922.png]]

*方法区、堆由所有线程共享，其余线程隔离（线程私有）*

## 程序计数器

指向当前执行的字节码位置，通过更改该指示器位置实现分支、循环、异常处理、线程恢复等
- Java 方法：正在执行的虚拟机字节码指令地址
- Native 方法：undefined

## Java 虚拟机栈

存储方法执行时创建的栈帧的位置，每个栈帧包括局部变量表、操作数栈、动态链接、方法出口等信息

通常说的 *栈* 指的是栈帧中的局部变量表部分，该部分存储编译器在编译期可知的各种基本 Java 数据类型和对象的引用类型（reference，可能是指针，句柄或其他指向对象的数据）

局部变量表中数据存储的基本单位是**局部变量槽 Slot**，64 位长度数据占有 2 个槽位，其余占用 1 个槽位。每个变量槽占用的内存长度不一定是 32bit，由具体虚拟机实现，规范不做要求

## 本地方法栈

为虚拟机本地方法（Native 方法）服务，具体实现规范不做要求，很多虚拟机将其与 Java 虚拟机栈合并管理

## 堆

JVM 虚拟机管理的内存中最大的一部分，用于存放对象实例，物理上可以不连续但逻辑上连续。规范中要求所有对象实例及数组都应在堆上分配。Java 堆由垃圾收集器管理，又称 *GC 堆*。

> 随着即时编译的发展，尤其是逃逸分析计数的日渐强化，栈上分配、标量替换等优化手段已经支持在栈中直接分配对象

## 方法区

又称*非堆*，存储已加载的静态变量、常量、类型信息、JIT 编译后的代码缓存等

方法区与永久代并不等价，且永久代也不是规范的一部分，只是早期 Hotspot 垃圾收集器的一种特征。现 Hotspot 方法区已经使用本地内存实现的元空间 Metaspace 实现

JVM 垃圾收集器对方法区的回收不理想，但又是必要的，用于实现类型卸载等

### 运行时常量池

存放编译期生成的字面量、符号引用等，存于 Class 文件的常量池部分。
- 一般来说，符号引用翻译出的直接引用也会存于运行时常量池
- 动态性：允许在运行时向常量池添加常量，常被应用于 `String::intern()` 方法

## 直接内存

不由 JVM 管理，但可以被访问到的内存，尤其在引入 NIO 后被大量使用

# 对象
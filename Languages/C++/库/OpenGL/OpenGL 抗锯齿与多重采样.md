```ad-note
走样 Aliasing：有时模型边缘有锯齿的情况，放大能看到锯齿状边缘，可以清楚的看到形成边缘的像素。

抗锯齿 Anti-aliasing：又称反走样，缓解走样现象，产生平滑边缘
```

![[Pasted image 20230913155051.png]]

光栅器是位于最终处理过的顶点之后到片段着色器之前所经过的所有的算法与过程的总和。光栅器会将一个图元的所有顶点作为输入，并将它转换为一系列的片段。

受限于窗口分辨率，顶点坐标与片段之间不可能一对一映射，所以光栅器必须以某种方式来决定每个顶点最终所在的片段/屏幕坐标，有些边缘的像素能够被渲染出来，有些不会。结果就是我们使用了不光滑的边缘来渲染图元，导致锯齿边缘。

![[Pasted image 20230913155234.png]]

抗锯齿方法最初使用超采样抗锯齿 SSAA：Super Sample Anti-aliasing，使用比正常分辨率更高的分辨率（即超采样）来渲染场景，更新图像时分辨率会被下采样(Downsample)至正常的分辨率。这些额外的分辨率用来防止锯齿边缘的产生。这种方法的缺点是需要绘制更多片段，带来很大的性能开销

后来出现了多重采样抗锯齿 MSAA：Multisample Anti-aliasing，借鉴了SSAA背后的理念，但却以更加高效的方式实现了抗锯齿。
# 多重采样

多重采样 MSAA 将单一的采样点变为多个采样点。以特定图案排列的几个子采样点 (Subsample，默认 4 个) 决定像素的遮盖度，但颜色缓冲的大小会随着子采样点的增加而增加。
![[Pasted image 20230913155504.png]]
MSAA真正的工作方式是，无论三角形遮盖了多少个子采样点，每个图元中每个像素只运行**一次**片段着色器。片段着色器所使用的顶点数据会插值到每个像素的**中心**，所得到的结果颜色会被储存在每个被遮盖住的子采样点中。当颜色缓冲的子样本被图元的所有颜色填满时，所有的这些颜色将会在每个像素内部平均化。因为上图的4个采样点中只有2个被遮盖住了，这个像素的颜色将会是三角形颜色与其他两个采样点的颜色（在这里是无色）的平均值，最终形成一种淡蓝色。

![[Pasted image 20230913155714.png]]
![[Pasted image 20230913155728.png]]

对于每个像素来说，越少的子采样点被三角形所覆盖，那么它受到三角形的影响就越小。三角形的不平滑边缘被稍浅的颜色所包围后，从远处观察时就会显得更加平滑了。

深度和模板测试也能够使用多个采样点。对深度测试来说，每个顶点的深度值会在运行深度测试之前被插值到各个子样本中。对模板测试来说，我们对每个子样本，而不是每个像素，存储一个模板值。当然，这也意味着深度和模板缓冲的大小会乘以子采样点的个数。
# OpenGL 使用多重采样

在 OpenGL 中使用多重采样，要求每个像素中存储大于 1 个颜色的颜色缓冲，为一个窗口绑定一个包含 N 个样本的多重采样缓冲可通过 GLFW 完成，在窗口创建之前设置：

```c++
// 包含 4 个样本的颜色缓冲
glfwWindowHint(GLFW_SAMPLES, 4);
```

之后，在 OpenGL 中启用多重采样即可，具体细节在 OpenGL 光栅器中已经实现，无需过多关心

```c++
glEnable(GL_MULTISAMPLE);
```
# 自定义抗锯齿算法

在着色器中使用 `sampler2DMS` 替代 `sampler2D`，可以手动访问各个采样点，手动实现抗锯齿

```c++
uniform sampler2DMS tex;

vec4 colorSample = texelFetch(tex, TexCoords, 3); // 第 4 个子样本
```
# Java 18

- 将 UTF-8 作为默认字符集（之前取决于系统）
- 使用 `jwebserver` 可以启动一个简易静态 web 服务器，不支持 CGI 和 Servlet
- Javadoc 中，可使用 `{@snippet 代码块}` 代替 `<pre>{@code 代码块}</pre>` 用于插入代码
- 重新实现了 `Method`，`Constructor`，提高反射性能
# Java 20
## 实验性功能

- switch 模式匹配：[[#Java 21 LTS#Pattern Matching for Switch]]
- record 模式：[[#Java 21 LTS#Record Patterns]]
# Java 21 LTS

## String Templates
#实验性功能 

JEP430，通用性字符串处理方法字符串模板，可以将字符串来初始化各种类型

字符串模板使用 `\{表达式}` 表示插入一个变量，包含以下三部分：
- `StringTemplate`：字符串模板类
- `StringTemplate.Processor`：字符串模板处理器

Java 内置三个字符串处理器
- `STR`：普通字符串模板
- `RAW`：不进行任何格式化的字符串模板
- `FMT`：使用 `java.util.Formatter` 进行格式化

```java
// STR
int x = 10, y = 20;
String s = STR."\{x} + \{y} = \{x + y}";
```

```java
// FMT
record Rectangle(String name, double width, double height) {
    double area() {
        return width * height;
    }
}
Rectangle[] zone = new Rectangle[] {
    new Rectangle("Alfa", 17.8, 31.4),
    new Rectangle("Bravo", 9.6, 12.4),
    new Rectangle("Charlie", 7.1, 11.23),
};
String table = FMT."""
    Description     Width    Height     Area
    %-12s\{zone[0].name}  %7.2f\{zone[0].width}  %7.2f\{zone[0].height}     %7.2f\{zone[0].area()}
    %-12s\{zone[1].name}  %7.2f\{zone[1].width}  %7.2f\{zone[1].height}     %7.2f\{zone[1].area()}
    %-12s\{zone[2].name}  %7.2f\{zone[2].width}  %7.2f\{zone[2].height}     %7.2f\{zone[2].area()}
    \{" ".repeat(28)} Total %7.2f\{zone[0].area() + zone[1].area() + zone[2].area()}
    """;
```

也可以自定义处理器，将字符串处理成任意类型 Java 对象

```java
var JSON = StringTemplate.Processor.of(
        (StringTemplate st) -> new JSONObject(st.interpolate())
    );
```
## Record Patterns
#实验性功能 

JEP440，进行模式匹配时，允许对 `record` 类进行解构甚至嵌套解构，解构时可以使用 `var` 推导

```java
record Tuner(int pitchInHz, Note note) implements Effect {}
record Note(String note) {}

class TunerApplier {
    static String apply(Effect effect, Guitar guitar) {
        return switch(effect) {
            case Tuner(int pitch, Note(String note)) -> 
                String.format("Tuner active with pitch %d on note %s", pitch, note);
            // var 版本
            case Tuner(var pitch, Note(var note)) -> 
                String.format("Tuner active with pitch %d on note %s", pitch, note);
        };
    }
}
```

该模式同样适用于 `for-in` 循环

```java
record Delay(int timeInMs) implements Effect {}

class DelayPrinter {
    static void printDelays(List<Delay> delays) {
        for (Delay(var timeInMs) : delays) {
            // do something
            System.out.println("Delay found with timeInMs=" + timeInMs);
        }
    }
}
```

以及 `instanceof` 判断

```java
record Delay(int timeInMs) implements Effect {}

class DelayPrinter {
    static void printDelays(Object delay) {
        if (delay instanceof Delay(var timeInMs)) {
            // do something
            System.out.println("Delay found with timeInMs=" + timeInMs);
        }
    }
}
```
## Pattern Matching for Switch

JEP441，Switch 表达式可判断对象类型了

```java
static String formatterPatternSwitch(Object o) {
    return switch (o) {
        case null      -> "null"
        case Integer i -> String.format("int %d", i);
        case Long l    -> String.format("long %d", l);
        case Double d  -> String.format("double %f", d);
        case String s  -> String.format("String %s", s);
        case default   -> o.toString();
    };
}
```

另外，还支持进一步的复杂检查，使用 `when`

```java
Effect effect;
Guitar guitar;

switch(effect) {
    case Tuner tu when !guitar.isInTune() -> ... ;
    case Tuner tu                         -> ... ; 
}
```

- 当一个模式匹配失败时，抛出 `MatchException`
- `switch` 表达式和语句中支持推断 `record` 模式类型参数，因此可以使用 `var`
## Unnamed Patterns and Variables
#实验性功能 

JEP443，`_` 可以表示未命名的变量，以及模式匹配时不使用的组件。

```java
try (var _ = ScopedContext.acquire()) {
    // do something
}

try { ... } 
catch (Exception _) { ... } 
catch (Throwable _) { ... }
```

未命名模式是一个无条件的模式，并不绑定任何值。未命名模式变量出现在类型模式中。

```java
if (r instanceof ColoredPoint(_, Color c)) { ... c ... }

switch (b) {
    case Box(RedBall _), Box(BlueBall _) -> processBox(b);
    case Box(GreenBall _)                -> stopProcessing();
    case Box(_)                          -> pickAnotherBox();
}
```
## Unnamed Classes and Instance Main Methods
#实验性功能 

JEP445，简化 Java 的入口类。现在 Java 的入口函数可以是以下类型的 main 函数，自上而下搜索

- 首先是 `public static void main(String[] args)` 方法
- 其次是声明为 `protected` 或 `package` 的 `static void main(String[] args)` 方法
- 接着是非私有的 `static void main()` 方法
- 然后是非私有的实例方法 `void main(String[] args)`
- 最后是非私有的实例方法 `void main()`

后两种 main 方法要求方法所在类有一个非私有的无参构造，或省略外层的 Java 类声明，直接把 `main` 方法作为顶层元素，写在 Java 源代码文件中。`main` 方法所依赖的其他方法和字段，也同样作为顶层元素。Java 编译器会自动生成一个匿名类，并调用其中的 `main` 方法。
## 其他

- Generational ZGC：扩展的分代式 ZGC 垃圾收集器，支持不同的世代，年轻和年老的对象分别存放在不同的世代中，减少应用所需的堆内存和垃圾收集 CPU 的间接费用，并降低分配停滞的风险
- 不再支持 32 位Windows

# Java 12
## switch 表达式扩展

[[#Java 14#Switch 表达式]]
## Compact Number Formatting

针对不同地区格式化数字

```java
int value = 1_234_554_321;
System.out.println(NumberFormat.getCompactNumberInstance().format(value)); // 12亿
System.out.println(NumberFormat.getCompactNumberInstance(Locale.SIMPLIFIED_CHINESE, NumberFormat.Style.SHORT).format(value)); // 12亿
System.out.println(NumberFormat.getCompactNumberInstance(Locale.SIMPLIFIED_CHINESE, NumberFormat.Style.LONG).format(value)); // 12亿
System.out.println(NumberFormat.getCompactNumberInstance(Locale.TRADITIONAL_CHINESE, NumberFormat.Style.SHORT).format(value)); // 12億
System.out.println(NumberFormat.getCompactNumberInstance(Locale.ENGLISH, NumberFormat.Style.SHORT).format(value)); // 1B
```
## JVM 常量 API

引入 `java.lang.invoke.constant` 包，用于描述一系列基于值的符号引用类型，用于描述可加载常量

定义一系列符号引用类型 `ClassDesc`，`MethodTypeDesc`，`MethodHandleDesc`，`DynamicConstantDesc` 包含描述这些常量的 `nominal` 信息
## 其他 API

- `String.transform`, `String.indent`

  ```java
  // 69609650
  System.out.println("Hello".transform(String::hashCode));
  //    Hello
  System.out.println("Hello".indent(3));
  ```

- `Files.mismatch()`
- `Collectors.teeing()` 聚合两个收集器的结果
- `CompletionStage.exceptionallyAsync`, `CompletionStage.exceptionallyCompose`, `CompletionStage.exceptionallyComposeAsync`
## 其他

- Shenandoah GC：基于 brooks pointers 的中低停顿垃圾收集器
- G1
	- 允许将old generation分配在诸如NV-DIMM memory的alternative memory device
	- `G1PeriodicGCInterval`, `G1PeriodicGCSystemLoadThreshold` 参数用于在 GC  后重新调整堆内存大小，释放内存给系统
	- `-XX:ShenandoahUncommitDelay=<milliseconds>` 指定ZPage的page cache的失效时间，然后归还内存
- ZGC：支持了Concurrent Class Unloading，默认是开启
- 内置 Java Microbenchmark Harness
# Java 13
## yield

[[#Java 14#switch 表达式]]
## 多行文本块

[[#Java 15#Text Block]]
## 其他

- Dynamic CDS Archives
	- `java -XX:ArchiveClassesAtExit=hello.jsa -cp hello.jar Hello`
	- `java -XX:SharedArchiveFile=hello.jsa -cp hello.jar Hello`
- ZGC：
	- `-XX:ZUncommitDelay=<seconds>` 用于指定ZPage的page cache的失效时间
	- 归还unused heap memory给操作系统，默认开启，`-XX:-ZUncommit` 显式禁用
	- 支持 `-XX:SoftMaxHeapSize`
# Java 14
## Foreign-Memory Access API
#实验性功能 

操纵堆外内存的 API

```java
SequenceLayout intArrayLayout = MemoryLayout.ofSequence(25, MemoryLayout.ofValueBits(32, ByteOrder.nativeOrder()));
VarHandle intElemHandle = intArrayLayout.varHandle(int.class, MemoryLayout.PathElement.sequenceElement());
try (MemorySegment segment = MemorySegment.allocateNative(intArrayLayout)) {
    MemoryAddress base = segment.baseAddress();
    for (int i = 0; i < intArrayLayout.elementCount().getAsLong(); i++) {
        intElemHandle.set(base, (long) i, i);
    }
}
```
## 文本块

[[#Java 15#Text Block]]
## instanceof 模式

[[#Java 16#instanceof 模式]]
## record 类型

[[#Java 16#record 类型]]
## Packaging Tool

[[#Java 16#Packaging Tool]]
## switch 表达式

对于简单的 Switch 语句提供更简便的写法

```java
// 简单的只有一行的语句
switch (day) {
  case MONDAY:
  case FRIDAY:
  case SUNDAY:
      System.out.println(6);
      break;
  case TUESDAY:
      System.out.println(7);
      break;
  case THURSDAY:
  case SATURDAY:
      System.out.println(8);
      break;
  case WEDNESDAY:
      System.out.println(9);
      break;
}
// 只有一行的赋值语句
int dayNum;
switch (day) {
    case MONDAY: dayNum = 1;break;
    case FRIDAY: dayNum = 2;break;
    case SUNDAY: dayNum = 3;break;
    case TUESDAY: dayNum = 4;break;
    default: dayNum = 0;
}
```

简化成

```java
switch (day) {
    case MONDAY, FRIDAY, SUNDAY -> System.out.println(6);
    case TUESDAY                -> System.out.println(7);
    case THURSDAY, SATURDAY     -> System.out.println(8);
    case WEDNESDAY              -> System.out.println(9);
}

int dayNum = switch (day) {
    case MONDAY -> 1;
    case FRIDAY -> 2;
    case SUNDAY -> 3;
    case TUESDAY -> 4;
    default -> 0;
};

```

使用 `yield` 关键字返回 Switch 表达式返回值

```java
String dayOfWeek = switch (i) {
    case 1 -> {
        String day = "Monday";
        yield day;
    }
    case 2 -> {
        String day = "Tuesday";
        yield day;
    }
    default -> "Unknown";
};
```
## 其他

- G1 实现 NUMA-aware 内存分配
- 移除 CMS 垃圾收集器
- ZGC 支持 Mac OS 和 Windows，Windows 要求 Win10 1803+
- 支持 Stream 方式的 JFR 监控
- NullPointerExceptions 异常提示：`-XX:+ShowCodeDetailsInExceptionMessages`
# Java 15
## Sealed Class

[[Java 17 LTS 新特性#sealed classes]]
## Text Block

使用 `""" ... """` 表示多行文本

```java
// 开头的 """ 后应当留空
String html = """
        <html>
          <body>
            <p>Hello, %s</p>
          </body>
        </html>""";
```

多行文本块增加 `\` 和 `\s` 控制符
## API

- CharSequence.isEmpty()
- TreeMap 增加以下方法：
	- `putIfAbsent()`
	- `compute()`，`computeIfAbsent()`，`computeIfPresent()`
	- `merge()`
- Nashorn JavaScript Engine 彻底移除
- 新增基于 EdDSA 的数字签名算法（Ed25519）

```Java
public void EdDSA(String msg) throws NoSuchAlgorithmException, InvalidKeyException, SignatureException {  
    KeyPairGenerator kpg = KeyPairGenerator.getInstance("Ed25519");  
    KeyPair kp = kpg.generateKeyPair();  
    Signature sig = Signature.getInstance("Ed25519");  
    sig.initSign(kp.getPrivate());  
    sig.update(msg.getBytes(StandardCharsets.UTF_8));  
    byte[] s = sig.sign();  
}
```
## 其他

- ZGC 转正，但默认仍是 `G1`，需要通过 `-XX:+UseZGC` 启用
- 隐藏类：用于框架，不可被程序正常调用，只能用于反射
	- 通过 `Lookup#defineHiddenClass()` 创建并返回 `Lookup` 对象使用
	- `Class::getName` 返回的不是名称字符串
	- `Class::getCanonicalName` 返回 `null`
	- 所有字段不可被修改；类对象不可被 `instrumentation` 等修改
# Java 16
## instanceof 模式

`instanceof` 时可直接附加强转操作

```java
Object o = "This is a string";
if (o instanceof String str) {
    // str 已经是 String 类型了
    System.out.println(str.length());
}
```
## record 类型

一个简单的只读数据类声明方式，自动实现 getter，toString，hashCode，equals

```java
public record Point(int x, int y) {
    // ...
}

// 相当于（以下省略实现）
public final class Point extends Record {
    public Point(int x, int y);
    
    public String toString();
    public final int hashCode();
    public final boolean equals(Object);
    
    public int x();
    public int y();
}
```
## Packaging Tool

jpackage 工具，提供简易的创建 exe，msi，pkg，dmg，deb，rpm 等格式安装文件

该工具可通过命令行调用，基于 JavaFX javapackager tool；也可通过 ToolProvider API 调用，模块名为 `jdk.jpackage`
## Vector API
#实验性功能

提供 `jdk.incubator.vector` API 用于向量表示与运算
## 其他

- ZGC：实现了并发 thread-stack 处理来降低 GC safepoints 的负担
- 除关键内部 API（`sun.misc.Unsafe` 等）外，默认强封装 JDK 内所有元素，将来只能通过 `-add-opens` 打开

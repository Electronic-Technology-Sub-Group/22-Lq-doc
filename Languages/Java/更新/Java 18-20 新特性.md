# Java 18
## VectorAPI
#实验性功能 
第三轮孵化

包含针对向量计算的一系列操作，通过对编译后的 CPU 指令优化以达到超过标量计算的性能

```java
int upperBound = SPECIES.loopBound(a.length);  
int i = 0;  
for (; i < upperBound; i += SPECIES.length()) {  
    FloatVector va = FloatVector.fromArray(SPECIES, a, i);  
    FloatVector vb = FloatVector.fromArray(SPECIES, b, i);  
    // c[i] = -(a[i] * a[i] + b[i] * b[i])  
    FloatVector vc = va.mul(va).add(vb.mul(vb)).neg();  
    vc.intoArray(c, i);  
}  
for (; i < a.length; i++) {  
    c[i] = (a[i] * a[i] + b[i] * b[i]) * -1.0f;  
}
```

以上代码等效于 

```java
for (int i = 0; i < a.length; i++) {  
    c[i] = (a[i] * a[i] + b[i] * b[i]) * -1.0f;  
}
```
## 其他

- 将 UTF-8 作为默认字符集（之前取决于系统）
- 使用 `jwebserver` 可以启动一个简易静态 web 服务器，不支持 CGI 和 Servlet
- Javadoc 中，可使用 `{@snippet 代码块}` 代替 `<pre>{@code 代码块}</pre>` 用于插入代码
- 重新实现了 `Method`，`Constructor`，提高反射性能
- 新增一个新的 SPI 用于地址解析，以便 `InetAddress` 可以使用平台外的三方解析器
# Java 19
## 外部函数和内存 API
#实验性功能 

与 Java 运行时之外的代码和数据进行互操作，高效调用外部函数，安全访问外部内存，调用本机库并处理本机数据，而不会像 JNI 那样危险和脆弱。
- 分配外部内存 ：`MemorySegment`、`MemoryAddress` 和 `SegmentAllocator`
- 操作和访问结构化的外部内存： `MemoryLayout`，`VarHandle`
- 控制外部内存的分配和释放：`MemorySession`
- 调用外部函数：`Linker`、`FunctionDescriptor` 和 `SymbolLookup`

```java
// 查找函数  
Linker linker = Linker.nativeLinker();  
SymbolLookup stdlib = linker.defaultLookup();  
// void radixsort(void*)  
MemorySegment segment = stdlib.lookup("radixsort").orElseThrow();  
FunctionDescriptor desc = FunctionDescriptor.ofVoid(MemoryLayout.paddingLayout(ValueLayout.ADDRESS.byteSize()));  
MethodHandle radixSort = linker.downcallHandle(segment, desc);  
// 分配内存  
String[] str = {"mouse", "cat", "dog", "car"};  
SegmentAllocator allocator = SegmentAllocator.implicitAllocator();  
MemorySegment offHeap = allocator.allocateArray(ValueLayout.ADDRESS, str.length);  
for (int i = 0; i < str.length; i++) {  
    MemorySegment cStr = allocator.allocateUtf8String(str[i]);  
    offHeap.setAtIndex(ValueLayout.ADDRESS, i, cStr);  
}  
// 调用函数  
radixSort.invoke(offHeap, str.length, MemoryAddress.NULL, '\0');  
// 将结果复制回 JVM 堆  
for (int i = 0; i < str.length; i++) {  
    MemoryAddress cStr = offHeap.getAtIndex(ValueLayout.ADDRESS, i);  
    str[i] = cStr.getUtf8String(0);  
}
```
## 虚拟线程
#实验性功能 

Virtual Thread，由 JVM 而非操作系统实现的轻量级线程，多虚拟线程共享一个线程
- 避免上下文切换的额外开销
- 简化并发程序的复杂性

虚拟线程通过 `Thread.ofVirtual().name("name").unstarted(runnable)` 创建，或通过 `Thread.startVirtualThread(runnable)` 快速创建并运行

虚拟线程创建后，对象类型仍为 `Thread` 对象，其余 API 使用方法与普通线程类似
- `isVirtual()`：线程是否为虚拟线程
- `Executors.newVirtualThreadPerTaskExecutor()`：创建一个线程池，线程池创建的线程都是虚拟线程

虚拟线程需要通过 `--source 19 --enable-preview` 参数开启预览功能才能使用

**注意：**
- 虚拟线程旨在增大系统并发量，对于高度依赖于 CPU 的工作并不会提升性能
- 虚拟线程支持 `ThreadLocal`，且虚拟线程之间，虚拟线程与平台线程之间的对象是互相隔离的
- 虚拟线程不应池化，因为虚拟线程非常轻量
- `synchronized` 会使虚拟线程被固定在平台线程上，应使用 `ReentrantLock` 替换
## 结构化并发
#实验性功能 

将不同线程中运行的多个任务视为单个工作单元，简化错误处理，提高可靠性和可观察性

```java
try (StructuredTaskScope<Object> scope = new StructuredTaskScope<>()) {  
    Future<Integer> future1 = scope.fork(() -> 10);  
    Future<String> future2 = scope.fork(() -> "Hello");  
    // ...  
      
    scope.join();  
}
```
# Java 20


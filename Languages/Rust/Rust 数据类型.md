Rust æ˜¯é™æ€ç±»å‹è¯­è¨€ï¼Œä»»ä½•å€¼éƒ½éœ€è¦ä¸€ä¸ªæ•°æ®ç±»å‹ï¼Œæ•°æ®ç±»å‹å¯ä»¥åˆ†ä¸ºæ ‡é‡å’Œå¤åˆã€‚

ç¼–è¯‘å™¨é€šå¸¸ä¼šæ¨æ–­å‡ºæˆ‘ä»¬æƒ³è¦ç”¨çš„æ•°æ®ç±»å‹ï¼Œä½†å¦‚æœå¤šä¸ªç±»å‹éƒ½å¯èƒ½ç¬¦åˆæ—¶ï¼Œå¿…é¡»å¢åŠ ç±»å‹æ³¨è§£

```rust
let num: u32 = "42".parse().expect("Not a number!"); // num = 42
```
# æ•°å­—

|       é•¿åº¦       |  æœ‰ç¬¦å·  |  æ— ç¬¦å·  |
|:--------------:|:-----:|:-----:|
|     8 bit      |  i8   |  u8   |
|     16 bit     |  i16  |  u16  |
|     32 bit     |  i32  |  u32  |
|     64 bit     |  i64  |  u64  |
|    128 bit     | i128  | u128  |
| å¹³å°ç›¸å…³(32 or 64) | isize | usize |

æ•´å½¢å­—é¢å€¼å¯ä»¥æœ‰ä¸‰éƒ¨åˆ†ç»„æˆ - å‰ç¼€è¡¨ç¤ºè¿›åˆ¶ï¼Œä¸­é—´ä¸ºå€¼ï¼Œåç¼€è¡¨ç¤ºç±»å‹

```rust
let x = 1; // i32 ç±»å‹ åè¿›åˆ¶ 1
let y = 0xffi64; // i64 ç±»å‹ åå…­è¿›åˆ¶ FF
let z = 0o77usize; // usize ç±»å‹ å…«è¿›åˆ¶ 77
let w = b'A'; // u8 ç±»å‹ 'A' (åè¿›åˆ¶ 65)
```

åè¿›åˆ¶ä¸éœ€è¦å‰ç¼€ï¼Œå…«è¿›åˆ¶ä¸º `0o`ï¼Œåå…­è¿›åˆ¶ä¸º `0x`ï¼ŒäºŒè¿›åˆ¶ä¸º `0b`ï¼Œ char ç±»å‹è½¬åŒ–ä½¿ç”¨ `b`ã€‚

åç¼€ä¸»è¦ç”¨äºæŒ‡å®šæ•´å‹ç±»å‹ï¼Œé»˜è®¤ä¸º i32ï¼›`b` å‰ç¼€ç”¨äºè½¬åŒ–å­—ç¬¦çš„ç±»å‹åªèƒ½æ˜¯ u8ã€‚æ³¨æ„è¿™é‡Œæ˜¯å­—é¢é‡çš„ç±»å‹ï¼Œä¸å˜é‡ç±»å‹å¯ä»¥ä¸åŒï¼Œå…è®¸å®‰å…¨è½¬åŒ–ã€‚

æ•´å‹æº¢å‡ºï¼šå½“è¿ç®—ç»“æœè¶…è¿‡æ•´å‹æœ€å¤§å€¼çš„æƒ…å†µè¢«ç§°ä¸º æ•´å‹æº¢å‡ºã€‚debug æ¨¡å¼ä¸‹ Rust ä½¿ç¨‹åº panicï¼Œrelease æ¨¡å¼ä¸‹ä½¿ç”¨äºŒè¿›åˆ¶è¡¥ç åŒ…è£…ã€‚ 
æ•´å‹æº¢å‡ºä¸€èˆ¬è¢«è®¤ä¸ºæ˜¯ä¸€ç§é”™è¯¯ï¼Œä½†è‹¥ä¾èµ–äºè¿™ç§è¡Œä¸ºï¼Œå¯ä½¿ç”¨ `Wrapping` åŠŸèƒ½ã€‚
 - `wrapping_*` æ–¹æ³•æ€»æ˜¯å°†æº¢å‡ºå€¼ä»¥äºŒè¿›åˆ¶è¡¥ç åŒ…è£…ï¼Œåœ¨ debug æ¨¡å¼ä¸‹ä»èƒ½è¿è¡Œ
 - `checked_*` æ–¹æ³•è¿”å›ä¸€ä¸ª Option å¯¹è±¡ï¼Œå½“æº¢å‡ºæ—¶è¿”å› None
 - `overflowing_*` æ–¹æ³•è¿”å›ä¸€ä¸ª `(self, bool)` ç±»å‹å…ƒç»„ï¼Œå‰è€…ä»¥è¡¥ç åŒ…è£…ï¼Œåè€…ä¸ºæ˜¯å¦æº¢å‡º
 - `saturating_*` æ–¹æ³•å¯¹å€¼çš„æœ€å¤§å€¼æˆ–æœ€å°å€¼è¿›è¡Œé¥±å’Œå¤„ç†

```rust
// Integer overflow: 254+1=255
println!("Integer overflow: 254+1={}", 254u8+1u8);
// attempt to compute `254_u8 + 2_u8`, which would overflow
// println!("Integer overflow: 254+2={}", 254u8+2u8);
// Wrapping add: 254+1=255
println!("Wrapping add: 254+1={}", 254u8.wrapping_add(1u8));
// Wrapping add: 254+2=0
println!("Wrapping add: 254+2={}", 254u8.wrapping_add(2u8));
// Check: 254+1=255
println!("Check: 254+1={}", 254u8.checked_add(1u8).get_or_insert(0u8));
// Check: 254+2=0
println!("Check: 254+2={}", 254u8.checked_add(2u8).get_or_insert(0u8));
let oa = 254u8.overflowing_add(1u8);
// Overflowing: 254+1=(255, false)
println!("Overflowing: 254+1=({}, {})", oa.0, oa.1);
let oa = 254u8.overflowing_add(2u8);
// Overflowing: 254+1=(0, true)
println!("Overflowing: 254+1=({}, {})", oa.0, oa.1);
// Saturating: 254+1=255
println!("Saturating: 254+1={}", 254u8.saturating_add(1u8));
// Saturating: 254+2=255
println!("Saturating: 254+2={}", 254u8.saturating_add(2u8));
```

Rust æµ®ç‚¹åˆ†ä¸º `f32` å’Œ `f64` ä¸¤ç§ï¼Œä»£è¡¨ IEEE-754 æ ‡å‡†å•ç²¾åº¦/åŒç²¾åº¦æµ®ç‚¹æ•°ï¼Œé»˜è®¤ä¸º f64ï¼Œå› ä¸ºåœ¨ç°ä»£ CPU ä¸­ 64 ä½æµ®ç‚¹æ•°çš„é€Ÿåº¦ä¸ 32 ä½å‡ ä¹ç›¸åŒä¸”ç²¾åº¦æ›´é«˜ã€‚

```rust
let x = 1.0; // f64
let y: f32 = 2.2; // f32
```
# å­—ç¬¦

Rust å­—ç¬¦ç±»å‹ `char` å­—é¢é‡ä»¥ `''` å¼•ç”¨ï¼Œä»£è¡¨ä¸€ä¸ª 4 å­—èŠ‚ Unicode æ ‡é‡å€¼

```rust
let c = 'z';
let z = 'â„¤';
let heart_eyed_cat = 'ğŸ˜»';
```
# å¸ƒå°”

å¸ƒå°”å€¼ `bool` å¤šç”¨äºæ§åˆ¶è¯­å¥ï¼ŒåŒ…å« `true` å’Œ `false` ä¸¤ä¸ªå€¼ã€‚
# å…ƒç»„

å…ƒç»„ tuple å°†å¤šä¸ªå€¼ç»„åˆæˆä¸€èµ·ï¼Œä½¿ç”¨ `()` åˆ›å»ºï¼Œä½¿ç”¨ `,` åˆ†å‰²å…ƒç´ 

å…ƒç»„é•¿åº¦å›ºå®šï¼Œå†…éƒ¨å…ƒç´ å¯ä»¥äº’ç›¸ä¸åŒä½†æ¯ä¸ªä½ç½®çš„ç±»å‹ä¹Ÿæ˜¯å›ºå®šçš„ã€‚

```rust
let tup1 = (500, 6.4, 1);
let tup2: (i32, f16, u8) = (500, 6.4, 1);
```

è®¿é—®å…ƒç»„å¯ä½¿ç”¨ç´¢å¼•ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨æ¨¡å¼åŒ¹é…è§£æ„ã€‚

```rust
let tup = (500, 6.4, false);

// Tup=(500, 6.4, false)

// ç´¢å¼•è®¿é—®
println!("Tup=({}, {}, {})", tup.0, tup.1, tup.2);

// æ¨¡å¼è®¿é—®
let (a, b, c) = tup;
println!("Tup=({}, {}, {})", a, b, c);
```

ä¸€ä¸ªæ²¡æœ‰ä»»ä½•å…ƒç´ çš„å…ƒç»„æˆä¸ºå•å…ƒå…ƒç»„ `()`ï¼Œå•å…ƒå…ƒç»„ä»…æœ‰ä¸€ä¸ªå€¼ `()`ï¼Œæ‰€æœ‰æ–¹æ³•è‹¥æ²¡æœ‰è¿”å›å€¼åˆ™éšå¼è¿”å›å•å…ƒå…ƒç»„
# æ•°ç»„

æ•°ç»„æ˜¯ä¸€ç»„åŒ…å«äº†ç›¸åŒå…ƒç´ å’Œå›ºå®šé•¿åº¦çš„å€¼ï¼Œä»¥ `[]` åˆ›å»º

```rust
// i32 ç±»å‹æ•°ç»„ [1, 2, 3, 4, 5]
let arr1 = [1, 2, 3, 4, 5];
// æ˜¾å¼æŒ‡å®šç±»å‹å’Œæ•°é‡ i64 ç±»å‹æ•°ç»„ [1, 2, 3, 4, 5]
let arr2: [i64, 5] = [1, 2, 3, 4, 5];
// æŒ‡å®šç›¸åŒå…ƒç´ å’Œä¸ªæ•° i32 ç±»å‹æ•°ç»„ [3, 3, 3, 3, 3]
let arr3 = [3; 5];
```

æ•°ç»„ä½¿ç”¨ç´¢å¼•è®¿é—®

```rust
let arr = [3; 5];
// Value at index 3 = 3
println!("Value at index 3 = {}", arr[3]);
```

å½“ç»™å®šç´¢å¼•æ— æ•ˆæ—¶ï¼Œå°†å¼•å‘ panicï¼šindex out of bounds
# never type

Rust ä¸­æœ‰ä¸€ä¸ªç‰¹æ®Šçš„ç±»å‹ `!`ï¼Œè¯¥ç±»å‹æ²¡æœ‰ä»»ä½•å®ä¾‹ï¼Œä¹Ÿæ— æ³•åˆ›å»ºä»»ä½•å®ä¾‹ï¼Œè¡¨ç¤ºä¸è¿”å›ä»»ä½•å€¼ã€‚ç”±äºæ²¡æœ‰ä»»ä½•å€¼ï¼Œæ‰€ä»¥å¯ä»¥æ˜¯ä»»ä½•ç±»å‹ã€‚

```rust
fn bar() -> ! {
    // do something
}
```

æ— è¿”å›å€¼çš„å‡½æ•°ç§°ä¸ºå‘æ•£å‡½æ•°ï¼Œä½†ç”±äº `!` æ²¡æœ‰å€¼ï¼Œæ‰€æœ‰ä¸å¯èƒ½åˆ›å»ºè¿”å›å€¼ä¸º `!` çš„å‡½æ•°ã€‚`!` ä¸»è¦ç”¨äºè¯­è¨€ä¸­å®é™…æ²¡æœ‰è¿”å›å€¼ä½†è¯­æ³•ä¸Šæœ‰çš„æƒ…å†µï¼š
- `continue` å¯ä»¥åœ¨ `match` ç­‰åˆ†æ”¯/å¾ªç¯ç­‰ç»“æŸå¾ªç¯ï¼ŒæŒ‰è¯­æ³•å¯èƒ½æœ‰ä¸€ä¸ªå€¼ï¼Œä½†å®é™…æ²¡æœ‰å€¼è€Œæ˜¯è¿”å›ä¸‹ä¸€ä¸ªå¾ªç¯çš„å€¼ï¼Œæ­¤æ—¶è¿”å› `!`
- `panic!` å®çš„è¿”å›å€¼
# ç±»å‹åˆ«å

Rust å…è®¸ä½¿ç”¨ `type` ä¸ºç±»å‹åˆ›å»ºåŒä¹‰è¯

```rust
type Kilometers = i32;

let x = 5;
// y is i32
let y: Kilometers = 10;
let z = x + y;
```

ç±»å‹åˆ«åå¯ä»¥ç®€åŒ–ç±»å‹ï¼Œè¯¦è§[[#æ³›å‹]]

```rust
type Trunk = Box<dyn Fn() + Send + 'static>;

fn main() {
    let f: Box<dyn Fn() + Send + 'static> = Box::new(|| println!("hi!"));
    let f2: Trunk = f;
    call(f2);
}

fn call(f: Trunk) {
    f();
}
```

ç±»å‹åˆ«åä¹Ÿå¸¸ä¸ `Result` ç±»å‹æ­é…ä½¿ç”¨ï¼Œè¯¦è§[[Rust æµç¨‹æ§åˆ¶]]

```rust
type Result<T> = std::result::Result<T, std::io::Error>;

pub trait Write {
    fn write(&mut self, buf: &[u8]) -> Result<usize>;
    fn flush(&mut self) -> Result<()>;
}
```

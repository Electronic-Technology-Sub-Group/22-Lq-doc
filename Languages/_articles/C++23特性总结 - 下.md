---
参考资料: https://zhuanlan.zhihu.com/p/562383556
---

## 标准库 - T2 - 其他

### `std::function`的伙伴：函数参数增强

`move_only_function`

[cppreference](https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/utility/functional/move_only_function) - [P0288R9](https://link.zhihu.com/?target=https%3A//wg21.link/P0288R9) - [[func.wrap.move]](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/func.wrap.move) - 2021.10

支持：GCC 12, Clang not yet, MSVC 19.32

主要头文件：`<functional>`

测试：`__cpp_lib_move_only_function >= 202110L`

(P0792已推迟)

`move_only_function`是一个很有趣的标准库组件——可以说，这是一个迟到的改正。换句话说，本来C++11加入的就应该是`move_only_function`，而原来的`std::function`应该作为`copyable_function`在之后加入。

为什么这么说呢？`move_only_function`实际上才是真正的“任意调用对象”的包装类（曾经的名称确实就是`any_invocable`），它是一个比`std::function`要求更加宽松的包装对象，并且解决了`function`的一大遗留问题。

从名称中其实就可以看出，`move_only_function`放松的就是`function`对包装对象最重要的要求之一：拷贝性。其实这个名称有点迷惑性在里面的——一般人肯定以为`move_only_function`对包装对象的要求就是可以移动，然而实际上比这个还要宽松——`move_only_function`只要求包装对象可调用（即有`operator()`），连移动性都没有要求。这个名称的`move_only`实际上指的是这个类本身，无论包装对象有何种性质，都是只能移动，不能拷贝的。

那么，既然包装对象可以不具有移动性，怎么构造`move_only_function`呢？这种情况下，通常常用的`move_only_function(F&&)`构造函数是不能用的，但是`move_only_function`加入了新的就地构造函数，从而可以在对象中直接构造包装物，不用移动。用法是将`std::in_place_type<T>`放在第一参数（`T`是包装对象的类型，这个tag的类型是`std::in_place_type_t<T>`），后面像各种`emplace`函数一样传入构造函数的参数就行了：

```cpp
struct NonMovable
{
    NonMovable(NonMovable&&) noexcept = delete;
    explicit NonMovable(int a, int b) {/* ... */}
    void operator()(int c) const {/* ... */}
};
std::move_only_function<void(int) const> mf(std::in_place_type<NonMovable>, 2, 3);
mf(4); // NonMovable(2, 3)(4)
```

另外，这里也支持`initializer_list`作为第一参数的构造函数。

除此之外，`move_only_function`解决的`function`最重要的问题就是`const`正确性。`std::function<R(Args...)>`本身的`operator()`调用操作符是有`const`限定的，但是内部调用并没有`const`，也就是说一个`const std::function`对象仍然可以调用非`const`函数：

```cpp
struct A
{
    void operator()() {/* ... */} // not const!
};
const std::function<void()> func(A{});
func(); // okay!
```

这在多线程环境下会造成一些问题，毕竟一个`const`成员却能够变动对象内部的内容，违反了“多个`const`调用同时执行不会产生竞争条件“这一普遍原则。`move_only_function`利用了一个极其鲜为人知的语言特性，[Abominable Function Types](https://link.zhihu.com/?target=https%3A//wg21.link/P0172R0)解决了这个问题：`move_only_function<void()>`的`operator()`没有`const`修饰，`move_only_function<void() const>`的`operator()`则有，也就是说`operator()`的修饰完全由模版参数决定：

```cpp
struct A1
{
    void operator()() const noexcept;
};
struct A2
{
    void operator()() noexcept;
};

const std::move_only_function<void()> mf1(A1{});
// void()后面没有const/noexcept，所以mf1::operator()没有const和noexcept标记
mf1(); // error!
std::move_only_function<void()> mf2(A1{});
mf2(); // fine
noexcept(mf2()); // false
const std::move_only_function<void() const> mf3(A1{});
// void()后面有const，没有noexcept，所以mf3::operator()有const，没有noexcept标记
mf3(); // fine
noexcept(mf3()); // false
const std::move_only_function<void() const noexcept> mf4(A1{});
// void()后面有const，有noexcept，所以mf4::operator()有const，有noexcept标记
mf4(); // fine
noexcept(mf4()); // true
std::move_only_function<void() const> mf5(A2{});
// error! A2不能在const环境下调用
```

简单的说就是想要`const`调用就得显式指明`R(Args...) const`（这种情况下只有带`const operator()`的类才能构造）

除此之外，`move_only_function`解决的另一个`function`问题就是空对象调用。当对一个空对象（默认构造/`nullptr`构造/moved-from）调用`operator()`的时候，`function`会抛出`bad_function_call`异常，而`move_only_function`就是UB。简单的说就是在这种情况发生比较少的前提下，用UB来提高了正常调用的性能，不用再检测是不是空对象了。

除了这三点（本身move-only，支持不能移动/拷贝的对象，不抛异常）以外，另一个小一点的变动是去掉了本身就非常鲜为人知的`target()/target_type()`两个得到RTTI信息的成员函数，从而尽量和RTTI分离开。除了这些之外，`move_only_function`的API设计和`std::function`完全相同——依然可以接受任意函数对象（指针，lambda，仿函数，成员函数指针，etc），因此可以作为一个直接的（更好的）替代品。`move_only_function`的调用/构造效率和`function`完全相同，所以替代之后也不会有性能损失。

```cpp
std::move_only_function<void()> mf1([]{});
if (mf1) {/* ... */} // 判空
void some_function();
std::move_only_function<void()> mf2(some_function);
swap(mf1, mf2); // 交换
// etc etc
```

使用这个类要注意的有：

- `move_only_function`的参数类型是`R(Args...) cv ref noexcept(noex)` ，后面可以加`const`，`noexcept`，`&`和`&&`，加了之后它的调用操作符就会有相同的修饰（注意`volatile`成员函数是不支持的，因为太少见了）
- `move_only_function::swap`是一个Hidden Friend，因为它是C++20以后的新类型。

### `spanstream`：`strstream`的替代品

`spanstream` / A `strstream` replacement using `span<charT>` as buffer

[cppreference](https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/header/spanstream) - [P0448R4](https://link.zhihu.com/?target=https%3A//wg21.link/P0448R4) - [[span.streams]](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/span.streams) - 2021.06

支持：GCC 12, Clang not yet, MSVC 19.31

主要头文件：`<spanstream>`

测试：`__cpp_lib_spanstream >= 202106L`

作为一门ISO标准语言，往C++中添加内容是很难的（提案往往要几年才能最终批准），但是从C++中删除内容是更加难的，因为谁都想维持老旧代码不被破坏，不引入API Break。要知道，语言中犯的错误和老旧库内容从来都不是天经地义必须删除的——Java的策略就是不断地标注废弃（deprecated），但是永远不删除那些老旧内容，这样最大程度地维持了代码兼容性。

可能让很多人比较意外的是，素来有发展缓慢名称的C++并不是这样的语言。正相反，从第一个标准化版本开始，C++就不断地标记各种各样的语言特性和库特性为废弃，并且在之后真的加以移除（当然，某些厂商可能会仍然将原来的特性作为扩展提供，但是这跟标准清理它们没关系）。C++11是第一个移除语言特性的发行版（以`auto`和`export`的原功能移除为最知名），而C++17是第一个移除库特性的发行版（以`auto_ptr`的移除为最知名）。在如此多年的发展之后，标准基本上已经形成了废弃-移除cycle，对于语言特性，一般废弃两个周期（6年）之后就可以移除干净，有些紧急的设计缺陷甚至可以不经过废弃直接移除。库特性相比之下要难移除的多，因为一般必须要有能够完美替代的库内容（比如`std::bind`替代`bind1st/bind2nd`）才会移除，不过C++17和20也移除了大把库特性。

遗憾的是，随着P2139的搁浅（没有足够LEWG review时间），C++23没能移除大量原本到了移除时机的特性（比如`std::rel_ops`，数组的互相比较等等），不过还是通过单独小提案的方式完成了`[a, b]`语法的废弃，删除（不是废弃）了C++11的垃圾收集支持，废弃了`aligned_storage`，以及将C头文件从废弃状态放回了标准正文。这样，在C++20大规模清理，C++23这一波小调整之后，废弃特性列表（附录D）只剩下了26个特性（其中语言9个，库17个）。而其中在C++11及以前废弃的只剩下了两个顽固的特性（C++98废弃一个，C++11一个），剩下24个都是C++17到23废弃的。这也反映出了C++17/20做的清理还是不错的。

当然，一个废弃的特性居然能在标准中继续存在10年甚至25年，本身就是很有故事的。C++11的遗留问题是特殊函数的自动生成——即在加入移动构造/赋值这两个特殊函数的时候，标准要求了定义一个就不会自动生成另一个，但是当时（C++11）已经无法改变原来的拷贝构造/赋值函数的语义，这两个定义了一个还是会自动生成另一个，于是标记了废弃。C++20/23两次review这个废弃特性的时候，都觉得去掉breakage太大，于是“留给后人解决”了。而C++98的那个遗留问题则更加有故事，毕竟在标准化之初就废弃的特性自然很不寻常，25年后仍然没有替代品更加离奇。这就是这一段的主角：库类型`strstream`。

前面`std::print`那一节已经简单介绍过了`sprintf` -> `stringstream` -> `format`这一段演变的历史，不过在C++标准化之前，`strstream`也曾经是被寄予厚望的下一代字符串格式化输入/输出流标准。然而，后来在IOStreams库的标准化过程中，`stringstream`因为更好的内存封装性和安全性被WG21相中，取代了`strstream`成为了标准在长达22年之中推荐的格式类型。自那以后，`strstream`只是作为`stringstream`的一个“不安全的”替补仍然在标准中存在，但是也正因如此在C++98中就被标记为了废弃。

不过，`strstream`也有着自己的优点。相比于`stringstream`来说，最重要的优点就是可以避免内存分配——`stringstream`为了安全性一定会自己管理内存，分配所需的缓冲区，而`strstream`既可以使用分配好的缓冲区，也可以让类自己管理内存。在许多情况下，栈上分配好的缓冲区往往比堆上动态分配的缓冲区性能高，这也是`strstream`的优点之一。不过，当`strstream`自己管理内存的时候，除了通常的`str()`获取结果以外，还需要显示调用`freeze(false)`去掉缓冲区的冻结效果才能避免内存泄漏，这种潜在的危险性也是它被废弃的重要原因。

当然，在C++20以后，标准推荐的输出方式已经变成了`std::format`，而`strstream`这个使用预分配缓冲区的功能也被`std::format_to`取代。那么为什么还不移除`strstream`呢？因为比起`format`家族，它至少还有两大优点：

- 支持输入
- 可以使用现有的IOStreams设施（比如`operator<<`重载）

正因如此，在C++23中，`strstream`也迎来了自己的继任者：`spanstream`。这是一个“取其精华”的类型，只提供了使用既有缓冲区的功能，去掉了原来有内存泄漏危险的自己管理内存那部分功能。另一个重要的改进是将原来使用`const char*`指向缓冲区的技术换成了C++20的新技术，`std::span`（这也是名字的由来）。使用方法实际上很简单，和IOStreams的其他部分一样，`spanstream`有三个变种，`ispanstream`，`ospanstream`，`spanstream`，分别只支持输入，输出和两个都支持。在构造时就要传递进一个缓冲区：

```cpp
char input[] = "10 20 30";
std::ispanstream iss{std::span<char>{input}};
int i, j, k;
iss >> i >> j >> k;
```

注意参数是`std::span<char>`或者（仅限`ispanstream`）一个可以转换为`std::span<const char>`的Range。构造函数的第二个参数是打开方式，对于`ispanstream`默认值就是`std::ios_base::in`，所以一般不用指定。

对于输出来说，也和`ostringstream`除了构造方式以外几乎完全一样：

```cpp
char output[30] = {};
std::ospanstream{std::span<char>{output}};
os << 10 << 20 << 30;
const auto sp = os.span();
// sp.size() == 6, sp.data() = &output[0]
// output == "102030\0\0...."
```

这里要注意几点：

- `span()`是得到底层缓冲区的成员函数，实际上因为使用的是`std::span`，这个函数返回的结果（的`data()`指针）只不过是指向了原来给它的缓冲区。
- `span()`同样也可以更换底层缓冲区，像`os.span(sp2)`一样传一个参数就可以变。
- 和IOStreams的其他部分一样，这几个类型的真实面目实际上是`basic_spanstream<charT, traits>`，而`spanstream`就是`basic_spanstream<char>`的别名而已。
- 同样和IOStreams库的设计一样，这些流的底层缓冲区是`basic_spanbuf`，通过`rdbuf()`成员函数可以访问；这个`buf`提供`seekoff`/`seekpos`保护成员函数。
- 自然，所有三个`spanstream`变种以及`spanbuf`都是move-only类型。而且除了最基础的别名以外，还提供了`wspanstream`/`wspanbuf`四个宽字符别名。`spanbuf`也单独提供了`u8`/`u16`前缀的别名。
- 和`strstream`库的原始设计一样，`ospanstream`**不会**在输出之后自动添加`\0`；不过返回的是`std::span<char>`，这个类型本来就没有NUL结尾的约定，所以也算符合常理；以前返回`const char*`的时候这可就是危险性之一了。

### Monadic `std::optional` & `std::expected`：看齐其他语言

(1) Monadic operations for `std::optional`

[cppreference](https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/utility/optional%23Monadic_operations) - [P0798R8](https://link.zhihu.com/?target=https%3A//wg21.link/P0798R8) - [[optional.monadic]](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/optional.monadic) - 2021.10

支持：GCC 12, Clang 14, MSVC 19.32

测试：`__cpp_lib_optional >= 202110L`

(*2) Monadic functions for `std::expected`

cppreference - [P2505R4](https://link.zhihu.com/?target=https%3A//wg21.link/P2505R4) - not yet in standard - 2022.11 (probably)

支持：GCC not yet, Clang not yet, MSVC not yet

测试：`__cpp_lib_expected >= 202211L` (也有可能不变)

又是Sum types的话题。我们知道，sum type实际上是vocabulary type的一种——也就是那些表征“概念”的类型。比如说，`std::optional<T>`表达的就是一个可空的`T`，而`std::expected<T, E>`表达的是一种可以有异常值的`T`。Vocabulary type是非常重要的一类类型——概念的表达使得它们经常作为参数或者返回值。因此，我们也希望尽量减少它们的语法噪音，从而达到让这些API得到更广泛使用的目的（这也是为什么`optional<T&>`的缺失是很大的问题）。

这之中，`optional<T>`和`expected<T, E>`这两个类型的API易用性又尤为重要——因为它们是异常这个语言特性以及已经被广泛使用的错误码返回值的直接竞争者。如果增加的语法繁琐度太大，那么即使使用这些sum type的确能提高性能，很多人也不想去用。因此，相对于错误码增加的各种便利成员函数就是它们最重要的特性之一。举个例子：

```cpp
std::errc stoi_error_code(string_view sv, int& out);
optional<int> stoi_sum_type(string_view sv); // or std::expected<int, std::errc>
int stoi_exception(string_view sv); // Throw std::invalid_argument
```

这是将字符串转化为整数的经典库函数`stoi`系列的三种实现方式，分别代表了错误码，sum type和异常三种方式。其中，第一种和第三种实际上有着极为悠久的历史——在标准库中，`std::from_chars`就是第一种的代表，`std::stoi`系列则是第三种的代表。因此，新兴的sum types想要取得优势，除了性能之外，在语法上也要简洁一些才行。单从函数签名上来看，是第三种（异常）最为简洁，因为异常是不在函数签名中表述的。不过在使用上，就不一定了。来个典型例子：如果转换不成功就返回-1

```cpp
string str = /* ... */;
{
    int result;
    if (stoi_error_code(str, result) != std::errc{})
        result = -1;
    return result;
}
{
    auto res = stoi_sum_type(str);
    return res ? *res : -1; // 注意，非最优写法
}
{
    try { return stoi_exception(str); }
    catch (std::invalid_argument&) { return -1; }
}
```

有趣的是，从这个naive的例子中，我们已经能够看到语法简洁带来的好处。`optional<T>`的设计是像指针语法靠拢的，毕竟指针就是人们最熟悉的可空物体实现。因此，我们可以直接`res`判断非空，然后直接解引用即可，这比`return res.has_value() ? res.value() : -1;`要简洁和明了多了，也让更多人愿意包装上这一层（当然，`*res`还比`res.value()`少一次检查，性能高一些）。

但是，这还不够。看看上面的三个实现，你或许会说——其中哪一个都不是很简洁，有点半斤八两的意思，毕竟都得两行（当然，输出参数显得更加繁琐一些）。这就是方便函数的用武之地了——由于"带默认值的取值"这个操作十分常见，各种语言都为它提供了便捷的运用方式：C#等语言直接把这个操作做进了核心语言（`res ?? -1`，C++最近也有提案提这个事情），C++则没有那么激进，但是它的努力体现在了`optional`和`expected`自加入标准库以来就有的第一个便捷成员：`value_or()`。

```cpp
return stoi_sum_type(str).value_or(-1);
```

这个成员函数实现当然很简单——一行`return has_value() ? operator*() : arg`就够了。但是它带来的语法便利是惊人的，现在终于可以说使用`optional`包装的版本和只返回`int`版本几乎没有差异了——只是在后面加一个函数调用就可以了。再和上面三个对比一下，很容易发现`value_or()`的必要性和优越性。

P0798/P2505引入的新便捷成员函数继承了`value_or()`的精神。这些新成员的实现往往都很简单，但是能够极大地简化常见场景的语法便捷性，从而吸引更多人使用sum types。这些新成员函数解决的是错误码曾经带来的一个痛点：函数式编程时的错误检查。我们知道，在FP环境中，嵌套多个函数是非常常见的情况，比如说：

```cpp
image process_img(const image& orig_img)
{
    return crop_img(
        add_blur(
            reduce_noise(
                increase_size(orig_img)
            )
        )
    );
}
```

在这样一个流水线式的函数调用链中，每一个函数的签名都是`image(const image&)`，这样传入的`image`就可以一路被处理好然后被直接返回，显得十分简洁。但是，这样一个函数回避了一个问题：如果其中有操作失败会怎么样？

如果使用的是异常，那确实不错——异常机制不影响语法的特征使得上面这段代码并不用改就可以自然地把异常传递出去。然而，这相当于是在使用异常作为控制流——一个让大部分C++ Guidelines都反对的行为，因为本质上编译器在暗地里还是要插入各种处理异常传递的底层代码，只是你看不见而已。错误码的表现更差——一方面，输出参数的普遍使用使得函数一般无法像这样被嵌套起来，另一方面相信大家都见过这样的代码：

```cpp
FILE* fp;
if (fp = fopen("xxx", "w")) {/* error */}
if (fputs("Hello", fp) == EOF) {/* ferror(...) */}
// ...
```

这样处理自然十分繁琐，每调用一个函数就要检查一遍错误，很多人甚至因此就直接假定`malloc`，`fopen`之类的函数永远不会出错直接调用了，留下了不少隐藏的bug。

Sum types在这个话题上的表现也没有好到哪里去（实际上`fopen`之类的指针返回值和`optional`很像）。如果每一个函数签名都是`optional<image>(const image&)`，那么想要把这几个函数组合起来，一种方式是嵌套带初始化值的if：

```cpp
optional<image> process_img(const image& orig_img)
{
    if (auto o1 = increase_size(orig_img))
        if (auto o2 = reduce_noise(*o1))
            if (auto o3 = add_blur(*o2))
                if (auto o4 = crop_img(*o3))
                    return *o4;
    return std::nullopt;
}
```

或者如果不想嵌套的话，就得一个个判断：

```cpp
optional<image> process_img(const image& orig_img)
{
    auto o1 = increase_size(orig_img);
    if (!o1) return {};
    auto o2 = reduce_noise(*o1);
    if (!o2) return {};
    auto o3 = add_blur(*o2);
    if (!o3) return {};
    auto o4 = crop_img(*o3);
    return o4;
}
```

相信谁也不会喜欢这么连续判断。而且，如果你遗漏了一个`if`，由于`operator*`并不会做检查，整个程序就是UB了。

正因为现有的几种方法都没能做到语法的简洁，P0798为`optional`增加了三个便捷成员，都跟这样的函数式编程风格有些关系。实际上，这已经是C++落后了——几乎所有的语言中的`Optional`，`Maybe`之类的类型都有这些操作，诸如Rust之类的语言甚至提供了更多的便捷成员（远远不止C++已有的4个）。

第一个是`transform`（其实应该叫`map`，但是和`views::transform`保持了一致的名字）。这个成员的用途是改变这个`optional`存放的类型或者值，用法是：

```cpp
optional<T>::transform(T => U) => optional<U>
```

也就是接受一个从T到U的函数，然后返回`optional<U>`。举个例子：

```cpp
optional<string> opt_string = /* ... */;
auto os = opt_string.transform([](auto&& s) {return s.size();});
// decltype(os) == optional<size_t>
```

就相当于把函数的返回值放进一个`optional`然后包装起来。

第二个是`and_then`，看名字就知道这个成员就是专门用来嵌套函数的——也就是前面提到的例子。这个函数的用法是

```cpp
optional<T>::and_then(T => optional<U>) => optional<U>
```

和`transform`的唯一区别就是参数代表的函数是返回一个`optional<U>`， 不是单纯的`U`。这样一来，如果`this`和函数返回值有一个是空`optional`，返回值就是空`optional`，否则就是函数的返回值。因此，上面的`image`例子就可以直接写成：

```cpp
optional<image> process_img(const image& orig_img)
{
    return orig_img
        .and_then(increase_size)
        .and_then(reduce_noise)
        .and_then(add_blur)
        .and_then(crop_img);
}
```

这样一来就清楚多了，而且可以一行写完，也不用费劲地把函数链倒过来理解了。

第三个便捷成员是`or_else`，这是一个专门为了错误处理而生的成员，签名是

```cpp
optional<T>::or_else(() => optional<T>) => optional<T>
```

用法也很简单，在`this`是空的时候就会调用函数，并且返回其返回值；否则就返回`*this`。这是用在出现错误时提供日志，异常之类的报告：

```cpp
std::optional<int> try_parse_int(std::string_view);
std::optional<int> log()
{
    std::cout << "Error!";
    return std::nullopt;
}
auto oi = opt_string.transform(try_parse_int)
                    .or_else(log);
```

比较可惜的是，原本`or_else`还能接受返回`void`的函数，这一特性在最终设计中被去掉了，因此我们必须加上`return std::nullopt;`。

这三个函数为我们提供了`optional`流水线的可能性，比如说：

```cpp
auto oi = opt_string.and_then(stoi)
                    .or_else(log)
                    .transform([](auto i) { return i * 2; });
```

这样的monadic函数调用链比起多次判断来说就要简洁多了。

对于`expected<T, E>`（P2505）来说，情况要更加复杂。一方面，`optional<T>`相当于一个`expected<T, std::nullopt_t>`，即相当于固定异常类型的`expected`，多出来的这一个`E`自由度会让成员函数更加复杂；另一方面，`expected`由于设计用来作为通用的返回值类型，有返回`void`的支持（`expected<void, E>`），来表示正常情况什么都不返回，但有可能返回错误这样的情况（比如`fclose`）。这两个复杂度让它的便捷成员函数设计更加复杂了一些。不过，基本思想还是一样的。

`expected<T, E>`同样会拥有`optional<T>`加入的这三个便捷成员，`transform`，`and_then`和`or_else`。`transform`最为简单——因为`expected`现在有两个自由度，正常值和异常值都是模版参数，所以`transform`也变成了两个函数：仍然只变动正常值的`transform`和变动异常值的`transform_error`：

```cpp
expected<T, E>::transform(T => U) => expected<U, E>
expected<T, E>::transform_error(E => F) => expected<T, F>
```

这两个函数的用法也和`optional`很类似：

```cpp
expected<int, errc> stoi(string_view sv);
auto et = stoi(some_string)
    .transform([](auto a) {return a * 2;})
    .transform_error([](auto e) {return make_error_condition(e);});
// decltype(et) == expected<int, error_condition>
```

而`and_then`同样变化不大，这次没有针对`error`的重载，只能直接改变正常值：

```cpp
expected<T, E>::and_then(T => expected<U, E>) => expected<U, E>
```

注意参数函数的返回值必须使用同一个`E`。这里的`and_then`仍然是嵌套函数的利器，比如多个函数都使用`std::errc`作异常值，那么就可以嵌套起来：

```cpp
expected<int, errc> stoi(string_view sv);
expected<double, errc> sqrt(int i);
expected<double, errc> negate(double d);
auto ed = stoi(some_string)
    .and_then(sqrt)
    .and_then(negate);
// decltype(ed) == expected<double, errc>
```

`or_else`则有了一些变化。由于`optional<T>`没有异常值，它的`or_else`接受的是一个无参函数，而`expected<T, E>::or_else`的参数自然可以接受`E`。因此，现在的签名是：

```cpp
expected<T, E>::or_else(E => expected<T, F>) => expected<T, F>
```

注意这里是可以更改异常值的类型的。`or_else`仍然可以在日志打印或者异常上使用...当然还是要注意返回值。比如说：

```cpp
auto ed = stoi(some_string)
    .and_then(sqrt)
    .or_else([](auto e) {std::println("Error!"); return expected<double, errc>(unexpected, e);})
    .and_then(negate);
```

另外，最后一个（第五个）由P2505添加的成员函数是`error_or`——`value_or`的异常值版本。这是`expected`原始提案的一个疏忽，现在也加上了这个可以提供异常值的默认值的函数。用法上，我们可以将正常值处理成`errc{}`来统一：

```cpp
expected<int, errc> ei = /* ... */;
auto code = ei.error_or(errc{}); // code is errc
process(code);
if (code) {/* ... */}
```

要注意的是，这五个函数都可以用在`expected<void, E>`上面，`transform`也可以把`T`变成`void`，或者把`void`变成`T`，这里是没有限制的。

### `[in]out_ptr`：指针作为输出参数的支持

`[in]out_ptr` / `out_ptr` - a scalable output pointer abstraction

[cppreference](https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/memory/out_ptr_t/out_ptr) - [P1132R8](https://link.zhihu.com/?target=https%3A//wg21.link/P1132R8) - [[smartptr.adapt]](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/smartptr.adapt) - 2021.06

支持：GCC not yet, Clang not yet, MSVC 19.30

主要头文件：`<memory>`

测试：`__cpp_lib_out_ptr >= 202106L`

C++11加入的智能指针（当然，C++98就有“智能”指针了，不过我相信所有人都想忘掉那段回忆）深刻地改变了所有人使用C++指针的方式，第一次在标准库中提供了RAII语义的安全智能指针，能够做到自动释放，定制删除器，自动引用计数等等功能。然而，虽然在现代C++中由于智能指针（和`observer_ptr`）的存在，很多时候原生指针已经不再被需要，但是作为一门脱胎于C的语言，和C库的互操作性永远是C++摆脱不开的话题，毕竟有太多的legacy库都是由C或者仿照C的惯例写出来的，直接调用C库的可能性也一直是C++的卖点之一。

在传统C库中，API参数里指针的使用一般有两种可能：引用传递和输出参数。引用传递很简单，毕竟默认情况是值传递，只有当参数是指针的时候才会做引用传递。在C++中，原生引用也对这种情况有了不错的支持。然而，输出参数就是另外一个故事了——输出参数指的是像`SomeLib_Init`这样的函数，将参数指针初始化成一段内存空间或者某个内部结构。往往输出参数使用返回值是更好的选择，但是一方面返回值只有一个，输出参数可以有任意多个；另一方面也有可能是像`realloc`这样的函数，将传进来的指针作出一定处理之后再传出。

当然，原生引用作为指针的语法糖，同样直接支持了输出参数这种用法——`from_chars`就是一个例子。不过，当我们把目光转向智能指针的时候，我们会发现它们支持作为引用传递的用法（直接调用`.get()`即可），但是却不支持输出参数。

举个例子：libavformat库里有下面这几个函数

```cpp
struct AVFormatContext {/* ... */};
AVFormatContext* avformat_alloc_context();
void avformat_free_context(AVFormatContext*);
int avformat_open_input(AVFormatContext**, /* a lot of options */);
void avformat_close_input(AVFormatContext**);
```

注意这里是一个典型的两步初始化例子——我们需要先分配context所需的内存，然后才能在context上打开输入文件（释放也是两步，先关闭文件再释放内存）。这里，`AVFormatContext**`这个二级指针参数并不表示二维数组，而是表示一个`AVFormatContext*`类型的输出参数（也就是像`realloc`一样，把分配好的内存接收进来，做文件操作然后返回新的内存指针）。自然，看到alloc-free这种两个函数的组合，一个很明显的改进是使用智能指针来避免忘记释放：

```cpp
using context_ptr = std::unique_ptr<AVFormatContext, decltype([](auto a)
{
    avformat_close_input(&a);
    avformat_free_context(a);
})>;
context_ptr ptr{avformat_alloc_context()};
// ???
```

到这里都还好，但是下一步，我们需要在这个智能指针上调用`open_input`，也就是要把它当成输出参数传进去。如果是普通指针，`&ptr`就行了，但是智能指针没有（也不应该，`CComPtr`，shame on you）重载地址操作符所以不能这么干。`get()`在这里帮不上忙，因为返回的是一个右值指针没法再取地址。因此，我们唯一的选择就是暂时让智能指针放弃自己的所有权：

```cpp
auto inner = ptr.release();
avformat_open_input(&inner, /* options */);
ptr.reset(inner);
```

且不说这样很繁琐，这让智能指针的所有意义全部消失（毕竟忘了调用`reset`的风险仍然存在）。

P1132提供的两个工具，`std::out_ptr`和`std::inout_ptr`，就是为了解决这个问题产生的。简单的说，它们的返回值都是智能指针之上的包装对象，可以自动隐式转换成`T**`，而且在析构函数中自动调用`reset`成员。因此，上面的例子就可以直接写成：

```cpp
avformat_open_input(std::inout_ptr(ptr), /* options */);
```

这样`release`和`reset`调用就会自动发生，不用再自己调用了。

这两个函数的区别其实也很明显。`std::out_ptr`是用作纯输出函数的，它只调用`reset`；`std::inout_ptr`是用在上面的情景，既用作输入又用做输出，就像`realloc`一样会先删除掉输入的指针，再重新分配一块内存。因此，假设我们有如下C API：

```cpp
struct c_api_t;
void c_api_create(c_api_t**); // 将输入指针重置为新内存空间（不删除）
void c_api_realloc(c_api_t**); // 删除输入指针再分配新内存空间
void c_api_free(c_api_t*); // 删除输入指针
using smart_t = std::unique_ptr<c_api_t, decltype([](auto a) {c_api_free(a);})>;
```

就可以分别使用：

```cpp
smart_t ptr;
c_api_create(std::out_ptr(ptr));
c_api_realloc(std::inout_ptr(ptr));
```

其实就是`inout_ptr`在传入函数之前会事先释放掉智能指针的占用，交给函数来删除输入的指针；`out_ptr`则不会，假设函数并不需要删除原来的指针，只是分配新的内存。

除此之外，`[in]out_ptr`也是支持自定义删除器的——只要传进构造函数就行：

```cpp
std::shared_ptr<c_api_t> ptr;
c_api_create(std::out_ptr(ptr, [](auto a) {c_api_free(a);}));
```

这些额外的参数会被直接转发给`reset`。

而且，指针类型并不一定非得是`T**`。很多C API（比如`malloc`/`free`）用的都是`void*`指针而不是一个更具体的类型，针对这种情况`[in]out_ptr`的返回值除了隐式转换成`T**`以外，还可以转换成`void**`，也就可以直接支持这样的API。自定义指针类型其实也是可以支持的，毕竟`[in]out_ptr`的模版参数可以指定：

```cpp
struct fd_wrap
{
    static constexpr auto invalid = static_cast<intptr_t>(-1);
    struct pointer
    {
        int handle;
        pointer() :pointer{nullptr} {}
        pointer(FILE* fp) :handle{fp ? fileno(fp) : invalid} {}
        explicit operator bool() const noexcept {return handle != invalid;}
        friend auto operator<=>(const pointer&, const pointer&) = default;
    };
    void operator()(pointer p) const
    {
        // fclose etc
    }
};
using smart_file = std::unique_ptr<int, fd_wrap>;
smart_file ptr;
fopen(std::out_ptr<FILE*>(ptr), "xxx.txt", "r");
```

要注意几点：

- 默认情况下，`out_ptr`支持任意包括`reset`成员的指针，`inout_ptr`支持任意包括`reset`和`release`成员的指针。（注意，这意味着`inout_ptr`不支持`std::shared_ptr<T>`）
- 这两个函数的返回值是`out_ptr_t`和`inout_ptr_t`，而且这两个返回值类型是可以特化的，如果需要自定义reset/release的行为就可以特化这两个模版。

### `std::unreachable`：此路不通

`std::unreachable()` / Function to mark unreachable code

[cppreference](https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/utility/unreachable) - [P0627R6](https://link.zhihu.com/?target=https%3A//wg21.link/P0627R6) - [[utility.unreachable]](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/utility.unreachable) - 2022.02

支持：GCC 12, Clang 15, MSVC 19.32

主要头文件：`<utility>`

测试：`__cpp_lib_unreachable >= 202202L`

"停机问题"可能是计算机领域历史最悠久的梦想之一，毕竟，让编译器能够决断一个程序是不是能够结束运行，这是一个非常强大的可能性；遗憾的是，这已经被证明是不可能实现的。不过，也正因如此，很多时候编译器是不能知道程序的某些部分是无法执行的，但是我们知道，于是就可以帮它一把；这也就是`std::unreachable()`的作用：标记某个部分不可到达。比如说：

```cpp
std::string colorCode(int level)
{
    switch (level)
    {
        case 1: return "Red";
        case 2: return "Blue";
        default: std::unreachable();
    }
}
```

这里我们就表述了一个编译器不知道的事实：这个函数只会以1或者2为参数，别的不可能。这样编译器就可以省掉判断`level <= 2`之后跳转前面的判断，从而提高性能。当然，如果你调用`colorCode(3)`，那就是UB了...

`std::unreachable()`本身的标准Wording也很有意思，调用就会立马产生UB，这也是它的用途所在；也有很多类似情况可以立马判断不会执行到，但是编译器不知道，又比如说：

```cpp
[[noreturn]] void kill_self()
{
    kill(getpid(), SIGKILL);
    std::unreachable();
}
```

既然后面`unreachable`了，那么编译器也不会再对这里`[[noreturn]]`发出警告了，也可以省掉`ret`这条汇编。这方面有大量可能的性能提高机会，所以几乎每个编译器都提供了这样一个"unreachable"函数（GCC/ICC/Clang `__builtin_unreachable`，MSVC `__assume(false)`），这也是为什么这个提案这么快被实现。

当然，读过前面假定表达式一节就会发现，这两个特性实际上是重复的——`[[assume(false)]];`就是一个永远不成立的假定，也就是无条件UB，和`std::unreachable()`完全等价。这里有一个先来后到的因素（P0627比P1774早一次Plenary进入C++23），而且`[[assume(false)]];`让一般人来看第一眼肯定反应不过来这是在干什么，`std::unreachable()`就清楚多了。

### `string::contains()`：Finally Here

`basic_string[_view]::contains()` / string contains function

[cppreference](https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/string/basic_string/contains) - [P1679R3](https://link.zhihu.com/?target=https%3A//wg21.link/P1679R3) - [[string.contains]](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/string.contains), [[string.view.ops]/26](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/string.view.ops%2326) - 2020.11

支持：GCC 11, Clang 12, MSVC 19.30

测试：`__cpp_lib_string_contains >= 202011L`

看这标题，啥也不用说了——`std::string`作为标准的字符串类，居然自加入之起25年内都没有`contains()`这个成员函数...这一惊人的缺失有两个主要原因：一是在C++17周期WG21对成员函数十分不感冒，很多原本应该是成员函数的东西都被强行扔进全局空间，而且当时`basic_string`的成员函数太多已经成为了一个众所周知的问题，因此往里面加入任何新成员的提案都相当于被搁置了；另一方面，查找一个字符串是否包含另一个串这个操作早已经被支持——`string::find`已经存在了很多年，而`a.find(b) != string::npos`实际上就相当于`a.contains(b)`，因此WG21并没有动力去加一个“一行wrapper”。

不过，正如前面好几个提案所展现出来的，WG21在C++20周期终于醒悟，彻底地改变了自己之前的策略。一方面，成员函数限制被全面放开，`starts_with`和`ends_with`趁机加入了`string`；另一方面，WG21认识到了这样的“一行wrapper”对于许多初学者是十分必要的，对专家来说也能够让代码更清晰，因此第一次像标准库中添加了一大堆诸如`views::keys`，`set::contains`之类的便捷wrapper。C++23继续了这一趋势，除了前面提到了`optional`便捷成员，`ranges::contains`以外，`string`和`string_view`终于迎来了缺失的`contains`成员函数。

想必这个成员函数的用法就不用我再介绍了——实在是太明显了：

```cpp
std::string str = "Hello";
str.contains('H'); // true
str.contains("Hel"); // true
```

这个成员函数的内部实现就是直接转发给`find() != npos`。注意`contains`的参数可以是`string_view`，`const char*`和单个`char`，而且`string`和`string_view`都有这个成员函数。另外，和同期加入标准的`ranges::contains`不同，这里没有区分找元素和找子串，因为类型就可以区分开。

### `to_underlying`：`enum`类的增强支持

(1) `to_underlying`

[cppreference](https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/utility/to_underlying) - [P1682R3](https://link.zhihu.com/?target=https%3A//wg21.link/P1682R3) - [[utility.underlying]](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/utility.underlying) - 2021.02

支持：GCC 11, Clang 13, MSVC 19.30

测试：`__cpp_lib_to_underlying >= 202102L`

(2) `is_scoped_enum` / A proposal for a type trait to detect scoped enumerations

[cppreference](https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/types/is_scoped_enum) - [P1048R1](https://link.zhihu.com/?target=https%3A//wg21.link/P1048R1) - [[tab:meta.unary.prop]/16](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/tab%3Ameta.unary.prop%23row-16) - 2020.11

支持：GCC 11, Clang 12, MSVC 19.30

测试：`__cpp_lib_is_scoped_enum >= 202011L`

自从scoped enum在C++11加入标准以来，它就作为C enum的更优越的替代品风行于世：无论是更限制的名称可见性，不再能够隐式转换，还是更强的类型安全性，新的scoped enum无论在哪个方面都是更好的选择。

不过，有些时候，类型安全性的增强也会带来一些烦恼——毕竟不能隐式转换就意味着很多旧API不能直接调用

```cpp
enum class Flags
{
    read = 0x1, write = 0x2, exec = 0x4
};
void use(Flags flag)
{
    some_c_api("xxx.txt", static_cast<int>(flag));
}
```

这里必须显示转换成`int`。不过，`int`不一定是合适的选择——每个enum都有自己的底层类型，比如如果`Flags`里面有一个成员被赋值`0xFFFFFFFF`之类的，底层类型就会变成比`int`大的整形，而`static_cast`的显示使用就会让编译器不会对这些情况作出任何警告。

更好的方式就是直接转换成enum的底层类型，这样永远不会出现溢出，也就是

```cpp
static_cast<std::underlying_type_t<Flags>>(flag)
```

当然，这显然太繁琐了——很多人就因为这一点就放任`int`或者`size_t`之类的选择大行其道。Effective Modern C++的Item 10也因此推荐了一个`toUType`便捷函数来完成这项工作。最终，在C++20以来加入便捷函数的东风之下，`std::to_underlying`被加入了标准，其唯一作用就是把一个scoped enum转换成底层类型，也就是

```cpp
void use(Flags flag)
{
    some_c_api("xxx.txt", std::to_underlying(flag));
}
```

这样一来就安全了。

至于P1048，属于C++11 type traits库的一个疏失——里面只有`std::is_enum`，没法区分是不是scoped enum。当然理论上来说我们可以用是否能隐式转换区分开来（至少在CWG 2516解决之前我们可以这么干），但是标准库中提供`std::is_scoped_enum`（以及`std::is_scoped_enum_v`）显然是更好的选择。这个type traits和其他的一样，类型是scoped enum就返回`true`。

### `string_view`的Ranges构造函数：一个混乱的故事

(1) Range constructor for `std::string_view` 2: Constrain Harder

[cppreference](https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/string/basic_string_view/basic_string_view) - [P1989R2](https://link.zhihu.com/?target=https%3A//wg21.link/P1989R2) - [[string.view.cons]/11](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/string.view.cons%2311) - 2021.06

支持：GCC 11, Clang 14, MSVC 19.30

测试：无

(2) `string_view` range constructor should be explicit

[cppreference](https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/string/basic_string_view/basic_string_view) - [P2499R0](https://link.zhihu.com/?target=https%3A//wg21.link/P2499R0) - [[string.view.cons]/11](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/string.view.cons%2311) - 2022.07

支持：GCC 12.2, Clang 16, MSVC 19.34

测试：无

不得不感叹，`string_view`和`span`这两个类型真是难兄难弟——作为C++标准库中最先加入的两个视图容器（`initializer_list`不算），在起到探路先锋作用的同时也带来了一大堆需要解决的问题。不过，具体到这两个类型上面，它们好像自带争吵体制，无论是构造函数还是成员函数都能引发激烈的争吵：`span`的`initializer_list`构造函数先是被扔出C++20，然后它的提案（P2447）又因为争议过大被推过了C++23截止期限，到现在甚至都没有足够的动力在WG21中推进；而它的成员函数`cbegin`和`cend`又经历了得而复失而又得的惊险故事，在标准中几进几出。`string_view`没好到哪里去，先是成员函数`substr`到底应该返回`string`还是`string_view`引起争议，`string::operator string_view`甚至被设计者都说是失败的选择，然后又出了Range构造函数这档子事情，4篇相似提案互相掐架直到最近才分出胜负。明明`span`的那个隐式Range构造函数没人有意见为什么这里就吵起来了呢？还是值得仔细分析一下的。

首先，我们要知道`string_view`和`span`在概念上分别代表什么样子的视图。作为视图，它们都是对一个序列的引用——也就是对象内部不保存元素，只保存序列的指针。`span`相对来说比较简单，创造这个类型的唯一目的就是为所有连续序列提供统一的抽象类型——也就是`span`可以指代任意连续Range。因此，一个不指定元素个数的`span`自然需要能够从任意连续Range隐式构造，从而允许下面的用法：

```cpp
void fun(span<const int> sp);
vector vec{1, 2, 3};
fun(vec);
```

由于`span`主要是一个参数类型，这种传递任意连续Range进入函数的用法是很重要的。

那么，`string_view`也是一个参数类型，也是用来接受任意字符串参数（`const char*`，`string`，都能接受）传进参数，也有人说`string_view`和`span<const char>`是重复类型，那么我们能否得出一样的结论，也就是`string_view`也应该能够从任意元素类型为`const char`的连续Range隐式构造呢？

在C++20周期中，提案[P1391R3](https://link.zhihu.com/?target=https%3A//wg21.link/P1391R3)就根据这一思路，提出了为`basic_string_view`增加从迭代器-哨兵对和任意连续Range隐式构造的构造函数。当时的想法非常美好：让C++中各种第三方字符串类（比如`QString`，`fbstring`之类的）都能被`string_view`代理，`string_view`不就可以成为通用的字符串视图了吗？

```cpp
void fun(string_view sv);
fbstring s = "Hello";
fun(s); // okay?
```

而且另一个优势是很多时候，`vector<char>`，`span<const char>`之类的序列如果看成`string`来处理也是合理的（毕竟C中字符串和字符数组并不能区分开来），这样我们让`vector<char>`也可以传递进`fun`里面，就成为了通用的字符串处理函数了，也可以让更多人愿意使用`string_view`。因此，P1391R3提议增加两个构造函数：

```cpp
template<typename R>
requires contiguous_range<R> && sized_range<R> && /* ... 元素可转换为char，避免抢夺其他构造函数 ... */
basic_string_view(R&& r);
template<contiguous_iterator I, sized_sentinel_for<I> S>
requires /* ... */
basic_string_view(I i, S s);
```

注意这里没有`explicit`，因为我们希望任意连续，sized，元素是char的Range都能隐式构造。

然而，在Belfast (2019-11)对P1391的最终LWG讨论中，第一个构造函数（Range那个）的限制条件被发现不够强，也就是说有一些不应该能够构造的东西却能够隐式构造`string_view`。在时间已经不够了的情况下，最终被C++20接受的[P1391R4](https://link.zhihu.com/?target=https%3A//wg21.link/P1391R4)只保留了第二个迭代器-哨兵函数，而Range构造函数被分离进了[P1989R2](https://link.zhihu.com/?target=https%3A//wg21.link/P1989R2)并被推迟到了C++23周期。

在新周期中，P1989对这个构造函数进行了详尽的设计：P1391发现的主要问题有两个，一是很多类型已经仿照`std::string`的做法，提供了向`string_view`隐式转换的操作符（成员`operator basic_string_view`），而在有这个操作符的情况下我们可以直接调用它，不用自己提供构造函数；另一方面，如果目标（也许是另一个第三方字符串类）有`traits_type`成员类型定义的话，那么我们也希望它指代的类型和`basic_string_view`的类型一样，因为我们不希望允许从`other_string<char, Trait1>`到`basic_string_view<char, Trait2>`的隐式转换。因此，在2021年中由C++23接受的P1989R2最终为`string_view`添加的这个Range构造函数有整整6个限制条件，可以说是很努力了。

遗憾的是，最终证明这些努力都是没有什么意义的。在C++23设计周期临近尾声的时候，两篇竞争提案[P2499R0](https://link.zhihu.com/?target=https%3A//wg21.link/P2499R0)与[P2516R0](https://link.zhihu.com/?target=https%3A//wg21.link/P2516R0)被提出，不约而同地指出了P1391+P1989的共同问题：努力方向不对。`string_view`和`span`不同，前者并不是一个通用的连续Range抽象层——`string_view`引入的唯一目的就是做一个字符串的抽象层，也就是包装`const char*`和`std::string`，并不包括其他的char序列。其实本质上来说就是隐式转换的设计问题——一个类的隐式转换通常不应该引入信息损失或者重大性能瓶颈，而`string_view`的Range构造函数是有可能有信息损失的：

```cpp
const char[] str = "Hello";
string_view sv = str; // sv.size() == 5
span<const char> sp = str;
string_view sv2 = sp; // sv2.size() == 6!
```

本质上字符串其实是以`\0`结尾的序列，并不是任意`char`序列都可以作为字符串的——也就是说，如果想要让这个构造函数做正确的事情，我们就必须像`strlen`一样计算正确的长度，这就引入了性能损失了，从而不适合继续做一个隐式构造函数。

字符串和char序列的问题在预支缓冲区的背景下或许更加清楚。在C和C++中，一个很常见的手法是先搞一块缓冲区然后再放进字符串，比如说

```cpp
void get_string(span<char> buffer);
void use_string(string_view sv);
char buf[100] = {};
get_string(buf);
use_string(buf);
```

这里并没有什么问题，但是如果我们遵循现代C++的建议，使用`array<char, 100>`而不是原生数组的话，就出了问题——`string_view`的隐式Range构造函数会产生作用，收到的`sv.size()`就是100而不是正确的长度了。

因此，P2499和P2516提出了不同的解决方案——P2499建议把这个构造函数变成显式的，这样就可以把选择权交还给用户，在需要这一转换的时候就可以显式调用；而P2516认为这个构造函数本质上就是错误的，建议从标准中删除P1391+P1989的wording。最终，LEWG在2022年2月的投票中，P2499获得了赞同-中立-反对=20-1-0，支持远强于P2516的12-4-3，毕竟这个转换在部分情况下还是有用的（比如把`vector<char>`看成字符串处理），直接删掉不太好。最终，P2499R0被C++23接受，从而现在`basic_string_view`的构造函数变成了

```cpp
basic_string_view(I, S);
explicit basic_string_view(R&&);
```

因此现在必须显式转换到`string_view`才能看成字符串，避免了隐式转换带来的各种问题。

### `invoke_r`：带返回值类型的`invoke`

`invoke_r`

[cppreference](https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/utility/functional/invoke) - [P2136R3](https://link.zhihu.com/?target=https%3A//wg21.link/P2136R3) - [[func.invoke]/3](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/func.invoke%233) - 2021.06

支持：GCC 12, Clang not yet, MSVC 19.31

主要头文件：`<functional>`

测试：`__cpp_lib_invoke_r >= 202106L`

TLDR: `invoke_r<R>(func, args...)`就是`static_cast<R>(invoke(func, args...))`，结束（笑

认真的说，`invoke_r`的标准实现确实就是把`invoke`的返回值转换成`R`。不过，要知道为什么C++23又加入了这么一个单行wrapper（是不是很熟悉，这样的wrapper多了点啊），还是要从`invoke`家族历史的开头说起。

很多人没有意识到的是，`invoke`这一通用概念在C++11就已经出现——尽管`std::invoke`本身是一个C++17特性。引入这一概念的动机其实是C++11的`std::function`与`std::bind`（的结果）——作为取代C++98时代的`std::mem_fun`和Binder的通用函数，这两个类型是作为所谓的PFCW（perfect forwarding call wrapper，在C++11时代这个名词还没有前面的perfect）登场的，也就是所谓的完美转发包装器：

```cpp
template<class F>
struct PFCW {
    F f;

    template<class... Args>
    constexpr auto operator()(Args&&... args)
        noexcept(noexcept(f(static_cast<Args&&>(args)...)))
        -> decltype(      f(static_cast<Args&&>(args)...)) {
        return            f(static_cast<Args&&>(args)...);
    }
};
```

这样，所有传入PFCW的参数都会被完美转发给底层的函数对象/指针，也就实现了函数的包装（比如如果上面`f(static_cast<Args&&>(args)...)`前面加个`!`，就是`std::not_fn`的简略版实现了）

不过，PFCW的概念并没有这么简单。我们知道，像`std::bind`，`std::mem_fn`这几个函数，设计目的之一就是要取代C++98时代的`std::mem_fun`，所以它们是支持传入成员函数指针的。因此，在C++11标准中最后采用的办法是提供了通用的`INVOKE`伪函数：

> Define `INVOKE (f, t1, t2, ..., tN)` as follows:

```text
— `(t1.*f)(t2, ..., tN)` when `f` is a pointer to a member function of a class `T` and `t1` is an object of type `T` or a reference to an object of type `T` or a reference to an object of a type derived from `T`;
— [...]
— `f(t1, t2, ..., tN)` in all other cases.
```

(N3337 20.8.2)

实际上，`INVOKE(f, args...)`就是一个通用的“以`args...`为参数调用`f`”的表达式，其中`f`可以是成员指针，函数对象，lambda等等东西。然后，标准中用这个表达式制定了`bind`，`function`等类型/函数的预期行为，这样所有这些类型和函数就都被要求支持成员指针了。不过，在这个时候，`INVOKE`并不是真正的标准库函数，而只是一个被方便用来统一要求的伪函数（表达式）。

这一段定义后来又经过了多次改动。首先是在2012年底，[LWG issue 2219](https://link.zhihu.com/?target=https%3A//cplusplus.github.io/LWG/issue2219)提出要加上`INVOKE`表达式对于`reference_wrapper`第一参数+成员指针的支持，因为当时主要的目标就是`reference_wrapper<T>`要尽量像`T&`靠拢，所以这里只支持`T&`却不支持`reference_wrapper<T>`总归不太好。不过，这个issue在2015年中才被接受进C++17，在那之前又发生了好几件事情：

第一件是在2014年中，WG21认识到了INVOKE表达式可能的实际作用（比如用作其他库的底层实现，`not_fn`之类的wrapper实现起来也更方便之类的），因此终于在[N4169](https://link.zhihu.com/?target=https%3A//wg21.link/N4169)中将INVOKE表达式具现化成了C++17 `std::invoke`，从而我们可以将上面PFCW的实现直接换成三遍`std::invoke(f, std::forward<Args>(args)...)`，从而直接支持好成员指针。遗憾的是，在C++11标准中，INVOKE表达式并非只有一种形式，在上面那一种之后还有这一段：

> Define `INVOKE(f, t1, t2, ..., tN, R)` as `INVOKE(f, t1, t2, ..., tN)` implicitly converted to R.

也就是说，INVOKE(..., R)不过就是把INVOKE的结果转换成R。引入这个形式的主要目的应该是支持`std::function<R(Args...)>`和`std::bind<R>`重载。在这两个重载中，返回值类型是被明确指定了的，所以我们可以直接帮用户做好转换：

```cpp
double f();
std::function<int()> fun(f); // okay
const char* get_str();
auto s = std::bind<std::string>(get_str)(); // okay
```

这里的主要目的其实就是方便，不用外面套一层`static_cast`了。

然而，N4169在看标准中的INVOKE表达式的时候，说了一段：

> First revision of the paper definied second overload of the proposed function (`invoke<R>(args...)`), mapped to `INVOKE` expression with explicit specification of return type (`INVOKE(args..., R)`). Mentioned version is leftover from TR1 implementation, were result type was determined using `result_of` protocol or has to be specified at call side and, after the introduction of type interference in C++11, it becomes obsolete.

遗憾的是，这段话并不正确。即使是在C++11 `decltype`的加持下，`INVOKE(..., R)`也并不是没有用的，一方面是少写一个`static_cast`带来的便捷性，另一方面，紧接着N4169发布（2014年底）的[LWG issue 2420](https://link.zhihu.com/?target=https%3A//cplusplus.github.io/LWG/issue2420)当场就打了脸...这个issue的主要成果是允许了R=void的情况，毕竟事实上任何类型到`void`也是一个合法的转型（就是丢弃任意结果），所以C++17开始下面的写法也有效了：

```cpp
int f();
std::function<void()> fun(f);
fun();
```

因此，如果N4169在这个issue之后发布的话，就可以看到`std::invoke<R>`的更多作用——然而这一错过就再等了7年。

在接下来的几年里，`INVOKE(..., R)`也有了更多的发展。先是在C++17即将定稿的最后阶段（2017年初），NB Comment提出了[LWG issue 2926](https://link.zhihu.com/?target=https%3A//cplusplus.github.io/LWG/issue2926)，表示`INVOKE(f, t1, t2)`和`INVOKE(f, t1, R)`太过接近，于是C++17在最后阶段接受了[P0604R0](https://link.zhihu.com/?target=https%3A//wg21.link/P0604R0)，除了将`INVOKE(f, t1, R)`改成了现在的`INVOKE<R>(f, t1)`以外，还引入了像`is_invocable`等type traits的`_r`版本，让能够测试能否调用的基础上还能测试结果类型是否可以隐式转换成`R`（另外，也是这个提案用`invoke_result`替代了`result_of`）。

接下来，2018年中，C++20接受了[P0655R1](https://link.zhihu.com/?target=https%3A//wg21.link/P0655R1)，在已有的`bind<R>`，`is_invocable_r`以外加入了`visit<R>`，用来表示将`std::visit`的返回值转换为`R`。这个形式有它更大的作用，因为正常的`visit`在函数对于`variant`中不同类型返回类型不一样的时候就无法得出固定的结论，比如说：

```cpp
std::variant<int, double> v{2};
std::visit([](auto a) {return a * 2;}, v);
// int or double? 错误!
```

也就是即使是这样的常见情况也会因为返回值类型不一致而报错。使用`visit<double>`就没有这个问题了。另一个增强是我们可以使用`visit<variant<int, double>>`实现类似`optional::transform`的效果。

至此，`_r`家族已经有了三个成员，然而最底层的`INVOKE<R>`表达式还是一个伪函数，并没有真正加入标准库——其实当初本就应该在加入`std::invoke`的时候用它替代标准中所有的`INVOKE`表达式，当初N4169犯懒没有做这个工作。结果，2016年初[LWG issue 2690](https://link.zhihu.com/?target=https%3A//cplusplus.github.io/LWG/issue2690)就提出了为`INVOKE<R>`增加对应的`std::invoke`版本，结果C++17，20周期大家都太忙没处理这个issue，直到C++23周期才终于由P2136加上了`std::invoke_r`。因此，当初看起来只是多一个转换的`invoke_r`实际上由多年的历史，用法除了省略`static_cast`以外，`invoke_r<void>`丢弃表达式结果也是可以的用法。当然本身语法上跟`invoke`完全一样，第一个参数是函数/对象/指针，后面都是完美转发的参数；只是要多提供一个模版参数`R`而已。

### `std::byteswap`：Have Fun

`std::byteswap` / Byteswapping for fun&&nuf

[cppreference](https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/numeric/byteswap) - [P1272R4](https://link.zhihu.com/?target=https%3A//wg21.link/P1272R4) - [[bit.byteswap]](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/bit.byteswap) - 2021.10

支持：GCC 12, Clang 14, MSVC 19.31

主要头文件：`<bit>`

测试：`__cpp_lib_byteswap >= 202110L`

这可能是整个T2列表中最简单的特性之一了——毕竟就是一个convenient wrapper。

背景上来说，在C++20周期中，[P0553R4](https://link.zhihu.com/?target=https%3A//wg21.link/P0553R4)为标准库的`<bit>`头文件增加了一批字节操作函数，比如`std::rotl`，就是把参数的二进制表示循环左移一位：

```cpp
int i = 0b00011101;
std::println("i = {:b}", i);
std::println("rotl(i, 1) = {:b}", std::rotl(i, 1));
std::println("rotl(i, 4) = {:b}", std::rotl(i, 4));
// 输出：
// i = 00011101
// rotl(i, 1) = 00111010
// rotl(i, 4) = 11010001
```

另外还有众所周知的`popcount()`（二进制1的个数），`countl_zero`等等。这些函数表面上看起来很无厘头（并不是很常用），但是实际上它们和`std::unreachable()`一样，是对底层指令的包装——所有这些函数在很多平台上都有可以直接用的汇编指令，并不需要真的用位运算算出来（比如x86平台中的`rol`/`popcnt`等指令），从而可以以一种最大化效率的形式提供这些操作的跨平台实现。

`std::byteswap`实际上也是一样——P0553忘了这个函数，P1272本来也是C++20周期的提案，只是被拖了一年半。顾名思义，`byteswap`就是把整个数的字节全部反转——

```cpp
std::uint32_t i{"0xDEADBEEF"};
std::println("i = {:x}", i);
std::println("byteswap(i) = {:x}", std::byteswap(i));
// 输出：
// i = DEADBEEF
// byteswap(i) = EFBEADDE
```

注意，是对所有字节（8个二进制位，2个16进制位）进行反转。（另外，`std::byteswap`只支持整形，包括`int`和`uint64_t`之类的类型；浮点和指针得先`bit_cast`一下）

### `string::resize_and_overwrite()`：String Resize的效率改进

`std::basic_string::resize_and_overwrite()`

[cppreference](https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/string/basic_string/resize_and_overwrite) - [P1072R10](https://link.zhihu.com/?target=https%3A//wg21.link/P1072R10) - [[string.capacity]/7](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/string.capacity%237) - 2021.10

支持：GCC 12, Clang 14, MSVC 19.31

测试：`__cpp_lib_string_resize_and_overwrite >= 202110L`

创造一个对象分成两步：分配内存和在内存上调用构造函数。这实际上自从C被广泛使用以来已经成为了普遍统一的真理——C中`malloc`和`somelib_init`的分离，C++98中的`new T`表达式也只不过是把两个本质上分离的操作包装了一下，你还是可以调用`operator new`和placement new来分别分配（未初始化）内存和构造对象，标准分配器更是从一开始就把`allocate()`和`construct()`明确分开了。也正是因为这样的两段构造模型，很多时候我们可以预先分配内存，却暂时不初始化它们来为以后做准备：

```cpp
std::vector vec{1, 2, 3, 4, 5};
vec.reserve(100);
// push_back 90 more times...
```

这里那100个元素占用的内存并没有完全初始化，而以后`push_back`的时候也就不用分配内存了。

当然，这里用的是更加智能化的`vector`，如果我们更底层一点，用原生数组的话，我们依然可以手动调用`operator new[]`分配内存。即使是夹在中间的智能指针也在C++20中获得了`_for_overwrite`系列函数，让你能够只分配内存，不初始化内容：

```cpp
std::unique_ptr<double[]> ptr = std::make_unique_for_overwrite<double[]>(1024);
// ptr内所有元素均未被初始化
for (int i = 0; i < 1024; ++i) ptr[i] = ...;
```

这里`make_unique_for_overwrite`比起`make_unique`的区别就是不会初始化成0，所以在后面会直接进行覆盖的情况下不初始化能够省掉一个`memset`。

不过，即使是最智能的容器，`reserve()`也并不完美——预留空间之后，内存分配确实省掉了，但是每次`push_back`/`append[_range]`都要检查一遍是不是超过了现在的capacity，这个检查虽然开销比内存分配小得多，但是终究也是可以省去的。因此，为了达到极限效率，C++23中加入了`basic_string::resize_and_overwrite`，让我们连这个检查的开销都可以省掉了。

一看这个名字，两个问题立马就出来了：为什么是`string`？为什么是`and_overwrite`而不是`for_overwrite`？

先说第一个。P1072这个提案只为`basic_string`一个容器增加了这样的成员，而更常用的连续容器（`vector`，`deque`）并没有加。主要原因是`basic_string`的模版参数必须是char-like类型——非数组，平凡，标准布局，etc，基本就是“啥都很平凡”的类型。像`basic_string<A>`这样的自定义类型是放不进去的（然而三家厂商好像有两家都支持这么写，笑）。因此，由于元素类型必然是平凡的，我们就可以直接去掉对于`allocator_traits::construct`/`destroy`的调用，而不带来可见的副作用；对于非平凡类型就不能轻易的去掉这些调用，从而`vector`可能需要更加复杂的解决方案。

那么，为什么是`and`而不是`for`呢？如果遵循`for_overwrite`家族的基础，我们容易想到，`resize_for_overwrite`的作用就是做一个resize，但是只分配内存不初始化：

```cpp
std::string s = "Hello";
s.resize_for_overwrite(100); // 假想
// s.size() == 100，但是s[5]到s[99]都没初始化
// 必须在读之前覆写
```

但是，这样一来，我们就必须允许`basic_string`内部存放未初始化的元素而不（直接）引起UB（只有真正读了未初始化内存才是UB）。对于智能指针，这不算什么，它们本来就是指针的轻量包装，也没有额外加强类约束的必要；但是`basic_string`作为容器，这样削弱容器的完整性最终被LEWG认为是不可接受的，所以最终采用了更严格的写法：

```cpp
std::string s = "Hello";
s.resize_and_overwrite(100, [](char* buf, std::size_t n) {
    for (int i = 5; i < n; ++i)
        buf[i] = 'A';
    return n;
});
// s.size() == 100而且全部元素均已初始化
```

这里做的改动就是加了一个第二参数，必须是一个可调用物，签名是`(char*, size_t) -> size_t`——实际上的用法是string内部会先重新分配内存，然后调用第二参数，传入的指针就是`s.data()`的新值（重新分配内存之后的第一个元素地址），长度则就是你申请resize的长度。调用的返回值会作为`s`的新长度，所以如果你没有用到所有的空间就可以在这里返回正确的长度（返回值必须<=传入长度，要不然就是UB）

还是看一个例子可能更容易理解这个第二参数的运作方式。假设我们有一个C API用来压缩字符串，API是

```c
int compress(char* out, size_t* out_size, const char* in, size_t in_size);
int compress_bound(const char* in, size_t in_size);
```

这里`compress`是实际做压缩的函数，而`compress_bound`是压缩后长度的上界，也就是压缩之后最坏情况也能保证的长度。自然，我们希望在存放结果时直接按照上界一次性分配好内存，压缩之后再回到正确的结果长度。我们可以这样写：

```cpp
std::string input = ...;
std::string result;
result.resize_and_overwrite(
    compress_bound(input.data(), input.size()),
    [&input](char* buf, std::size_t n) {
        std::size_t result_size;
        int ret = compress(buf, &result_size, input.data(), input.size());
        if (ret != 0) {/* error ... */}
        return result_size;
    }
}
// 最终result.size() == result_size
```

这里我们的resize请求是上界，因此`result_size <= compress_bound`成立，结果就是一次性分配`compress_bound`那么多内存，`compress`直接覆盖之后再返回正确的长度，`size()`就会是正确的值了。

这里要注意几点：

- 传入的指针`buf`是新的内存开头地址，这样你就可以覆盖原有的元素了；当然大部分情况下都是在空串上调用这个成员，所以没啥区别。
- 同理，传入的长度是resize请求的长度，不是原来字符串的长度。
- 如果`buf[0]`到`buf[result_size - 1]`有元素没初始化，那么这个调用是UB，所以要返回正确的长度避免basic_string内部出现未初始化元素。
- 返回长度必须<=传入长度（传入长度是上界）
- 现在`basic_string`的构造并不一定调用`allocator_traits::construct`了（因为这个成员就是让用户自己construct）
- 如果第二参数调用的时候抛出异常，也是UB，所以错误处理需要另找办法...
- 在调用期间，`result`（被resize的字符串）刚刚分配完内存没有初始化，是一种不稳定的非法状态，所以不要用`&result`捕获，会出UB。

### `allocate_at_least`：独木难支

`std::allocate_at_least` / Providing size feedback in the Allocator interface

[cppreference](https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/memory/allocate_at_least) - [P0401R6](https://link.zhihu.com/?target=https%3A//wg21.link/P0401R6) - [[allocator.traits.other]](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/allocator.traits.other) - 2021.06

支持：GCC not yet, Clang 15, MSVC 19.30

测试：`__cpp_lib_allocate_at_least >= 202106L`

在C++20周期和23周期，都发生了不止一起语言和库脱节的事情；由于语言工作组和库工作组是两套不同的架构，一个提案的语言部分和库部分往往有着不同的进度，最后导致了只有语言没有库支持（或者反过来）的半截特性。比如说，`std::start_lifetime_as[_array]`原来是P0593的一部分，但是由于C++20 LWG超载掉出去了一大批提案，导致P0593R6最后只有语言部分（隐式创造对象生命期）进入了C++20，它的库函数支持直到C++23才补上。

P0401也是一样，原本来说，更加基础（也更加有用的）语言提案[P0901R9](https://link.zhihu.com/?target=https%3A//wg21.link/P0901R9)应该是和P0401一起进入C++23的，提供对于返回大小的operator new/分配器在语言和库层面提供完整的支持；然而P0901因为设计争议最后掉了出去，P0401只加入分配器的返回大小支持就显得很尴尬，毕竟其实P0901就是P0401的底层实现。

其实P0401和上面的P1072很像——都是为了解决`resize()`/`reserve()` API的缺陷。当然，这次的问题不同——P0401/P0901解决的问题是超分配问题。这个问题简单的说，就是你申请（无论是`operator new`还是分配器）内存的时候，得到的往往比申请的多；比如你`operator new(12)`申请12个字节，很多内存池会返回给你一个16个字节大小的内存空间（向上取整）。这种行为也是被C++标准允许的，只要返回空间的大小>=申请大小就可以。

不过，这段“赠送”的分配空间却并不能为用户所用——现标准中，申请了12个字节你就只能访问12个字节，即使后面送了你4个字节，访问那些还是UB。自然，我们希望能访问所有字节——比如说，`vector::resize(12)`就可以直接把capacity设成16，下次push_back就不用重新分配内存了。

一个最容易想到的办法就是让内存池提供一个接口，回答“当我申请N个字节的时候，实际上我会得到多少字节？”（也就是TCMalloc的`nallocx` API）。不过，这个API有三个问题：

- 效率不高，很多时候知道“能得到多少字节”这个信息的唯一途径就是实际分配一遍内存（比如遍历一遍链表），而后面我们实际分配的时候就相当于做了两遍同样的工作。
- 返回值可能比较保守。N -> 实际字节这个映射实际上并不是常数，有可能两次`malloc(12)`一次返回16字节，一次32字节，但是`nallocx(12)`永远只能返回最保守的猜测。
- 损失实际大小。`nallocx`得到数值之后，我们每次只会使用这个数值的字节做分配请求（比如想要12/13/14字节都会申请16字节），这可能会让内存池对于实际内存需求的预估出现偏差从而损失效率。

说到这里，实际可行的解决办法其实已经呼之欲出了——只要在分配的时候，除了返回指向分配内存的指针，还返回实际分配的大小就行了；这样三个问题都解决了。P0401采用的就是这个方法——在分配器API既有的`allocate()`函数之外，增加了`allocate_at_least()`函数：

```cpp
std::allocator<int> alloc;
auto p1 = alloc.allocate(12);
auto [p2, sz] = alloc.allocate_at_least(12);
```

唯一区别就是会返回一个

```cpp
template<class Pointer>
struct allocation_result {
    Pointer ptr;
    size_t count;
};
```

而不是仅仅一个指针，这里用结构化绑定就可以拿到实际分配的大小（保证>=12），从而我们可以使用`p2[0]`到`p2[sz - 1]`的所有内存（而不是只到`p2[11]`）。在释放的时候，`allocator::deallocate(ptr, n)`的第二参数只要是12<=n<=sz即可，即请求大小<=释放大小<=实际大小即可，不用非得保存实际大小。

另外，为了兼容性，增加了一个全局函数`std::allocate_at_least(a, n)`（参数是分配器和大小）。这个函数是一个兼容垫片，在`a.allocate_at_least`存在时调用它，不存在就返回`{a.allocate(n), n}`（即直接认为请求大小=实际大小）。标准容器的`resize`就可以使用这个全局函数，从而没有`allocate_at_least`只有`allocate`的第三方分配器仍然可以被支持，而有前述接口的升级版分配器就能获得性能提升。

（顺带提一句，`std::allocator<T>::allocate_at_least`的默认实现实际上需要依赖P0901的新版`operator new`，但是由于P0901没进，现在就只能很尴尬地写"it is unspecified when and how this function (`operator new`) is called"，以标准中unspecified的形式来强行避开这个问题）

### `forward_like`：Deducing This的附加功能

`std::forward_like`

[cppreference](https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/utility/forward_like) - [P2445R1](https://link.zhihu.com/?target=https%3A//wg21.link/P2445R1) - [[forward]](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/forward) - 2022.07

支持：GCC not yet, Clang 16, MSVC 19.34

测试：`__cpp_lib_forward_like >= 202207L`

（其实`forward_like`也有点半截特性的意思——P0847提了`like_t`和`forward_like`，后者进了前者（P1450 `copy_cvref_t`）掉出去了）

`std::forward`可能是C++11最著名的库特性之一，完美转发和万能引用的广泛使用使得这个“无用”函数在几乎所有用到模版的C++代码中都会多次出现。当然，一般的用法是完美转发参数：

```cpp
void fun(/* ... */);
template<typename T>
void pass(T&& arg)
{
    fun(std::forward<T>(arg));
}
```

去掉少数几个完美转发失效的情况，这样写的函数基本还是能够做到完美的——`pass(arg)`和`fun(arg)`无论传入的是左值还是右值，无论是不是常量，都能正常运作。

然而，往往我们需要的并不仅仅是完美转发参数——有时候可能会想转发参数的成员，比如内部有一个指针指向实际对象。自然，一个简单的想法就是换成`std::forward<T>(arg).member`，而且这在大部分情况下真的是可以成立的。这里我们有几种情况（见[Godbolt](https://link.zhihu.com/?target=https%3A//godbolt.org/z/1Enzo9cWf)的完整示例）：

```cpp
struct Test
{
    int i;
    std::optional<int> opt;
    std::vector<int> vec;
    std::unique_ptr<int> ptr;
};

template<typename T>
void pass_bad(T&& t)
{
    sink(std::forward<T>(t).i);
    sink(std::forward<T>(t).opt.value());
    sink(std::forward<T>(t).vec[0]);
    sink(*std::forward<T>(t).ptr);
}
```

看下这几种类型的成员，都用`forward`+成员访问会怎么样。对于最简单的成员`i`（直接存放对象）来说，这么做是可以的——一个右值的`t`意味着`t.i`就是右值，常量同理，所以这里`forward<T>(t).i`也能够完美转发`t`的表达式类型（左右值/常量）。

接下来是不那么简单的情况，成员被包了一层（指针，容器，optional），那么这时会怎么样呢？对于`std::optional<int> opt`，我们走运了——`std::optional<T>::value`有四个重载：

```cpp
constexpr T& value() &;
constexpr const T& value() const &;
constexpr T&& value() &&;
constexpr const T&& value() const &&;
```

这样对于每一个不同的表达式类型，可以返回对应的包装值，比如`move(t).opt.value()`也是一个右值（`move(t)`是右值 => `move(t).opt`是右值访问表达式 => 调用`value() &&` => 返回右值），因此这里`forward<T>(t).opt.value()`同样是完美转发成功了。

然而，到了容器这里，事情就没那么好办了——容器`operator[]`只有两个重载，只区分了常量性：

```cpp
constexpr reference operator[](size_type pos);
constexpr const_reference operator[](size_type pos) const;
```

因此，`as_const(t).vec[0]`确实是一个`const int`类型的左值，然而`move(t).vec[0]`还是一个左值，并不是右值——这里常量性可以转发下去，左/右值丢失了。考虑到绝大多数第三方类也是这么写`operator[]`和其他getter的（只区分常量性），我们可以认为通常情况下`forward<T>(t).vec[0]`这种写法只能保留常量性。

指针（原生和智能都一样）则是最差的情况：容器只要愿意，提供一个右值`operator[]`重载是没有技术难度的；但是指针从设计上来说就是浅层`const`的：

```cpp
int i = 2;
int* ptr = &i;
*as_const(ptr) = 4; // fine!
```

对的——解引用一个`T* const`会给你一个`T&`，永远不会给你常量左值——除非原来的指针就是指向常量的指针。正因如此，智能指针也只提供了一个`operator*`

```cpp
reference operator*() const;
```

对，`const unique_ptr<T>`就是`T* const`，解引用它必然是非常量左值。但是这也就意味着我们的`*forward<T>(t).ptr`压根不是一个完美转发——任何情况下这都是一个非常量左值。而且这个行为是不可修改的。

要知道，像`optional<T>`这样提供四个重载的getter的类绝对是极少数——绝大多数第三方包装类都是容器和指针的情况。因此，P2445引入了`std::forward_like`专门解决这个问题：

```cpp
template<typename T>
void pass_good(T&& t)
{
    sink(std::forward_like<T>(t.i));
    sink(std::forward_like<T>(t.opt.value()));
    sink(std::forward_like<T>(t.vec[0]));
    sink(std::forward_like<T>(*t.ptr));
}
```

注意这里的区别：先写完表达式，外面再套`forward_like`，而不是先`forward`再写表达式。这里`forward_like`的模版参数是“拥有者”的类型，内部没有任何实际操作，只是一个转型，从而达到完美转发的效果。

在Deducing This语境下，`forward_like`更是能够大放异彩。毕竟需要完美转发成员的情况不多，但是Deducing This之下返回本类的成员也可以用这个直接完美转发——比如上面`optional::value()`，之前写成

```cpp
template<typename T>
struct optional
{
    T* value;
    T& operator*() & {return *value;}
    const T& operator*() const & {return *value;}
    T&& operator*() && {return std::move(*value);}
    const T&& operator*() const && {return std::move(*value);}
};
```

现在，我们可以直接完美转发自己的成员：

```cpp
template<typename T>
struct optional
{
    T* value;
    template<typename Self>
    decltype(auto) operator*(this Self&& self)
    { return std::forward_like<Self>(*self.value); }
};
```

在lambda语境下，这个特性甚至更加有用：毕竟lambda不能简单地重载，在这之前我们完全不可能这么实现`not_fn`这样的完美转发包装器：

```cpp
#define RETURNS(x) noexcept(x) -> decltype(x) { return x; }
template <typename F>
auto not_fn(F&& f) {
    return [f = std::forward<F>(f)](this auto&& self, auto&&... args)
        RETURNS(
            !std::invoke(
                std::forward_like<decltype(self)>(f),
                std::forward<decltype(args)>(args)...)
        );
}
```

现在就这么几行，SFINAE，常量，左/右值传参和调用都搞定了...

对于更喜欢技术内容的人，除了这样的总体效果以外我们可以稍微深入一点：`forward_like`和`forward`一样只是一个转型，常量是两个参数的常量性取或，**值类型用的是拥有者（模版参数）的值类型**（比如说，`int k; std::forward_like<int>(k)`返回一个`int&&`右值，尽管传进去的是左值也会被忽略）

## 标准库 - T3

### 自定义Range适配器支持

自定义Range适配器支持 / Pipe support for user-defined range adaptors

cppreference - [P2387R3](https://link.zhihu.com/?target=https%3A//wg21.link/P2387R3) - [[range.adaptor.object]/2.2](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/range.adaptor.object%232.2) - 2022.02

支持：GCC not yet, Clang not yet, MSVC 19.34

测试：`__cpp_lib_ranges >= 202202L`

C++20 Ranges库带来的新内容主要有三个方面：Ranges算法，迭代器工具与Ranges视图（或者说适配器）。这其中，Ranges视图有着最高的关注度和使用频率，因为它既是唯一一块Old STL完全没有涉及的新内容，又是使用最方便的一块内容。无论是`views::take`，`views::filter`等常用的过程适配器，还是`views::iota`，`views::zip`等工厂适配器都有着自己的使用场景，也是很多人最喜欢Ranges库的部分（毕竟真的很方便）

```cpp
std::vector vec{1, 2, 3, 4, 5};
std::println("{}", vec | views::take(2)); // [1, 2]
std::println("{}", vec | views::transform([](auto a) {return a * 2;})
                       | views::filter([](auto a) {return a > 5;})
                       | views::drop(1)); // [8, 10]
```

不过，新内容也就意味着新的复杂度，Ranges视图也是三大板块中最难自定义的一块。自己写Ranges算法很好办，只不过是一个lambda加上一些Concept限定而已。迭代器稍微复杂一点，但是也只不过是提供`iterator_category`加上一些运算符重载而已。然而，想要自己写一个Range视图，这个难度就有点大了——一方面，Range视图的调用形式非常多，为了用户方便`views::take`实际上支持下面所有的调用形式：

```cpp
views::take(vec, 2)
vec | views::take(2)
views::take(2)(vec)
views::take(2) | views::join

// 最后一种是指vec | (views::take(2) | views::join)这样的形式
```

也就是同时有简单函数调用，管道，部分绑定以及适配器组合四种形式。要让自己写的Range视图同时支持这四种形式的难度还是很大的，尤其是最后一种，由于标准并没有针对Range视图的Concept，实际上我们自己是没法写出这个`operator|`的，只能让标准库来提供支持。

因此，在C++23中，P2387为自定义Range视图提供了一个初步的支持。首先，要明确一个概念：Range视图实际上有两种，有额外参数的RAO（Range适配器对象）和没有额外参数的RACO（Range适配器闭包对象）。RACO是指可以进行如下调用的对象（其中`R`是Range，`C`和`D`是RACO）：

```cpp
C(R)
R | C // 并且和C(R)等价
C | D // 并且R | (C | D)和(R | C) | D等价
```

很容易看出这三种形式就是简单调用，管道和组合，也就是像`views::join`和`views::take(2)`（部分绑定的结果）就是RACO。P2387对RACO的支持是一个CRTP父类`ranges::range_adaptor_closure<C>`，从这个父类CRTP继承会自动帮你做好`R | C`和`C | D`的支持（`R | C`会直接转发到`C(R)`，`C | D`会生成另一个RACO），也就是你只要自己支持`C(R)`就好了（毕竟这是一个成员`operator()`重载，标准库没法帮你实现`C(R)`）。以`views::join`为例，按照惯例我们假设已经有一个`join_view{R}`存在，只需要在其上包装一个RACO。那么写法就比较简单：

```cpp
struct join_closure : public ranges::range_adaptor_closure<join_closure>
{
    template<ranges::input_range R>
        requires ranges::viewable_range<R>
    constexpr operator()(R&& r) const
    { return join_view{views::all_t<R>(std::forward<R>(r))}; }
};
```

实际上就是直接转发给`join_view{views::all(r)}`，实现好`operator()`之后管道就被自动支持了。

当然，对每个RACO都这么来一下可能有一点繁琐，我们也可以写一个通用的RACO构造类：

```cpp
template<typename F>
class closure : public ranges::range_adaptor_closure<closure<F>>
{
private:
    F f;
public:
    constexpr closure(F func) :f{func} {}
    template<ranges::viewable_range R>
        requires std::invocable<const F&, R>
    constexpr operator()(R&& r) const
    { return f(std::forward<R>(r)); }
};
```

然后对每一个RACO直接用一个lambda初始化即可：

```cpp
inline constexpr closure join =
    []<ranges::input_range R>
        requires ranges::viewable_range<R>
    (R&& r)
    { return join_view{views::all_t<R>(std::forward<R>(r))}; }
```

RAO则是一个更加复杂的概念，适用于有额外参数的Range视图：对一个RAO `A`，如下构造成立（`R`为Range，`args...`为任意参数）：

```cpp
A(R, args...)
A(args...)(R)
R | A(args...)
// 并且三种形式的结果等价
```

容易看出，`views::take`，`views::transform`等Range视图就都是RAO。P2387并没有在标准中直接支持自定义RAO——而是旁敲侧击地提供了一个工具函数：`std::bind_back`。顾名思义，`bind_back`就是`std::bind`固定所有参数在末尾的形式：

```cpp
void fun(int a, int b, int c);
auto f2 = std::bind_back(fun, 2);
f2(1, 3); // fun(1, 3, 2)
```

由于`std::bind`本身需要`_1`这种placeholder，所以没法直接实现这样的效果；在C++17周期，`std::bind_front`（`f2(1, 3)`调用`fun(2, 1, 3)`）因此加入了标准，当时考虑过`bind_back`但是因为觉得没人用就没加，现在P2387在C++23周期补上了这一半。

那么`bind_back`和RAO有什么关系呢？仔细看一下上面的三种调用，我们可以发现只要让`A(args...)`是一个RACO，那么后两种调用自然就等价了，因此有了RACO支持，我们实现RAO其实也不难：（以`views::take`为例）

```cpp
struct take_closure // 注意，views::take自己并不是RACO，所以不用继承
{
    template<typename... Args>
    constexpr operator()(Args... args) const
    {
        if constexpr (sizeof...(Args) == 1)
        {
            // views::take(2)
            return closure{std::bind_back(
                [](auto&& R, auto N) {return take_view{std::forward<decltype(R)>(R), N};},
                std::forward<Args>(args)...)};
        }
        else
        {
            // views::take(vec, 2)
            static_assert(sizeof...(Args) == 2);
            return take_view{std::forward<Args>(args)...};
        }
    }
};
```

也就是说，只要你的`operator()`支持了`A(R, args...)`和`A(args...)`（后者返回RACO），那么管道就会自动支持。当然，我们仍然可以把这个形式抽象成一个RAO构造类：

```cpp
template<typename F>
class adaptor
{
private:
    F f;
public:
    constexpr adaptor(F func) :f{func} {}
    template<typename... Args>
    constexpr operator()(Args&&... args) const
    {
        if constexpr (std::invocable<const F&, Args...>)
        { return f(std::forward<Args>(args)...); }
        else
        { return closure{std::bind_back(f, std::forward<Args>(args)...)}; }
    }
};

inline constexpr adaptor take =
    []<ranges::viewable_range R, std::integral N>
        requires ranges::input_range<R>
    (R&& r, N n)
    { return take_view(std::forward<R>(r), n}; }
```

### `constexpr`扩展：`<cmath>`与更多

(1) `constexpr` for `<cmath>` and `<cstdlib>`

[cppreference](https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/numeric/math/fabs) - [P0533R9](https://link.zhihu.com/?target=https%3A//wg21.link/P0533R9) - [[library.c]/3](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/library.c%233) - 2022.02

支持：GCC 4.6 (partial), Clang not yet, MSVC not yet

测试：`__cpp_lib_constexpr_cmath >= 202202L`

(2) Making `std::unique_ptr` `constexpr`

[cppreference](https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/memory/unique_ptr/unique_ptr) - [P2273R3](https://link.zhihu.com/?target=https%3A//wg21.link/P2273R3) - [[unique.ptr.single.general]](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/unique.ptr.single.general) - 2022.02

支持：GCC 12, Clang 16 (partial), MSVC 19.33

测试：`__cpp_lib_constexpr_memory >= 202202L`

(3) A more `constexpr` `bitset`

[cppreference](https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/utility/bitset) - [P2417R2](https://link.zhihu.com/?target=https%3A//wg21.link/P2417R2) - [[template.bitset.general]](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/template.bitset.general) - 2022.07

支持：GCC not yet, Clang 16, MSVC 19.34

测试：`__cpp_lib_constexpr_bitset >= 202207L`

(4) `constexpr` `from_chars` & `to_chars` / Add Constexpr Modifiers to Functions `to_chars` and `from_chars` for Integral Types in `<charconv>` Header

[cppreference](https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/utility/from_chars) - [P2291R3](https://link.zhihu.com/?target=https%3A//wg21.link/P2291R3) - [[charconv.from.chars]](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/charconv.from.chars), [[charconv.to.chars]](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/charconv.to.chars) - 2022.07

支持：GCC not yet, Clang not yet, MSVC 19.34

测试：`__cpp_lib_constexpr_charconv >= 202207L`

(5) Making `std::type_info::operator==` `constexpr`

[cppreference](https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/types/type_info/operator_cmp) - [P1328R1](https://link.zhihu.com/?target=https%3A//wg21.link/P1328R1) - [[type.info]](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/type.info) - 2021.06

支持：GCC 12, Clang not yet, MSVC 19.33

测试：`__cpp_lib_constexpr_typeinfo >= 202106L`

就像每个标准都会在语言中放松`constexpr`函数的限制一样，C++11以来的每个标准也都向越来越多的标准库内容增加了`constexpr`。C++14为`<array>`, `<chrono>`与`<complex>`增加了`constexpr`标注，C++17为type traits增加了`constexpr`的`_v`版本，C++20为`vector`/`string`增加了`constexpr`支持。C++23在这里也没有停下脚步，一共五篇提案接着为一批标准库内容增加了`constexpr`标注，也让更多类型能够在编译期使用。

五篇里面最重要的应该是P0533，为`<cmath>`和`<cstdlib>`中的部分数学函数增加了`constexpr`限定。在C++23之前，整个`<cmath>`都是几乎没有任何`constexpr`的——像`fabs`，`floor`，`ceil`之类的函数因而根本不能在编译期使用。但是，我们并不能一股脑地把整个`<cmath>`中的函数（比如`sqrt`）加上`constexpr`，因为这样做会遇到一个重要的问题：`errno`和其他全局错误状态。作为C标准库中的一部分，`<cmath>`中几乎所有函数都是通过`errno`和浮点异常（注意这不是C++异常，而是`FE_INEXACT`之类的异常旗帜）来报告错误的，毕竟它们也没有别的办法——`sqrt(-1)`会返回什么？也只能报告错误了。

但是，众所周知，`constexpr`函数自然没法变动全局运行期数据。那么，难道所有C函数都没办法在编译期使用了吗？并不一定。自从C++11开始，`constexpr`环境下的浮点四则运算（比如`constexpr double f = 1.0 * 2.0;`）就是被支持的，而这些运算本来就有可能报错：

```cpp
constexpr double f = numeric_limits<double>::max() * 2;
// 报告FE_OVERFLOW和FE_INVALID
```

但是，这并没有阻止`*`在编译期的使用，只不过上面的语句本身不是编译期常量而已。

另一个麻烦的地方是浮点舍入模式，这决定了像`1.0 / 3.0`之类的运算结果如何舍入。不过，虽然舍入模式也是全局运行期数据，我们还是可以使用一样的理由——`1.0 / 3.0`现在也是合法的编译期运算，只不过现在它的结果是实现定义的而已。无论如何，舍入模式的改变对于这类运算结果的影响是极小的，所以我们可以忽略这里的依赖。然而，`nearbyint()`这类函数就是另一个故事了——它们就是舍入模式的直接体现，这里我们避不开舍入模式的问题（因为如果这也是实现定义的结果，那么这个函数就没意义了）

总的来说，考虑以上两个方面，P0533为C++23标准库添加`constexpr`的主要原则是选择`<cmath>`和`<cstdlib>`中满足如下两个条件的函数：

- 在有理数集（或者其一个在实数集上无处稠密的子集）上闭合（忽略除0/0的对数的情况）
- 不强依赖于舍入模式（就是不像`nearbyint`那样不考虑舍入模式就没意义了）

这样，选中的函数实际上就是那些“四则运算的组合“形成的函数；比如`sin`/`cos`/`sqrt`这样的函数因为不满足第一个条件就被排除了（其实这里有些保守，GCC libstdc++中`sqrt`也是编译期可用的；但是现阶段保守一点以后再增加也不是坏事）。最终，被选中的函数包括：（每一个函数名，比如`ilogb`，都是`ilogb(float)`/`ilogb(double)`/`ilogb(long double)`/`ilogbf(float)`/`ilogbl(long double)`这样五个函数的家族）

- `<cstdlib>`中的`abs`/`labs`/`llabs`, `div`/`ldiv`/`lldiv`
- `<cmath>`中的`frexp`, `ilogb`, `ldexp`, `logb`, `modf`, `scalbn`, `scalbln`, `abs`, `fabs`, `ceil`, `floor`, `round`/`lround`/`llround`, `trunc`, `fmod`, `remainder`, `remquo`, `copysign`, `nextafter`, `nexttoward`, `fdim`, `fmax`, `fmin`, `fma`, `fpclassify`, `isfinite`, `isinf`, `isnan`, `isnormal`, `signbit`, `isgreater`/`isgreaterequal`/`isless`/`islessequal`/`islessgreater`, `isunordered`

所有这些函数现在都可以在编译期使用了。

接下来是P2273。C++20核心语言中对于`constexpr`最重要的增强之一就是允许了编译期的内存分配与释放。然而，不幸的是，标准库再一次没跟上——所有智能指针都没能支持`constexpr`，从而在编译期我们还是只能手动管理内存。最终，P2273为C++23迈出了支持智能指针的第一步——让最简单的智能指针，`std::unique_ptr<T>`，支持了`constexpr`的编译期使用场景。在C++20引入了`new`/`delete`编译期支持之后，这一支持实际上比较直观，基本就是把所有成员函数加一遍`constexpr`就行。不过，要注意的是，有五个非成员——`operator<`等比较函数——是没有加`constexpr`的，也就是说在编译期两个`unique_ptr`是没法比较大小的（比较相等可以，和`nullptr`比较大小也可以）。具体来说：

```cpp
unique_ptr<int> u1, u2;
u1 == u2; // okay
u1 != u2; // okay
u1 == nullptr; // okay
u1 > nullptr; // okay
u1 < u2; // error!
```

禁止的有且只有两个`unique_ptr`做`<`/`>`/`<=`/`>=`/`<=>`这五种比较的情况，相等比较以及和`nullptr`的比较是允许的，所有其他成员/非成员也可以在编译期使用。具体禁止的原因就是两个`T*`之间比大小的结果是未定义的，而编译期我们要禁止所有UB。当然，涉及原子操作和控制块分配的`shared_ptr<T>`不可能这么简单，于是只能等待以后再标准化了。无论如何，下面的代码在C++23算是合法了：

```cpp
constexpr auto fun() {return *std::make_unique<int>(2);}
int main()
{
    constexpr int i = fun();
    static_assert(i == 2);
}
```

（要注意，C++20编译期内存分配必须是透明的，也就是不能把分配的内存返回到函数外面去）

接下来，在C++20成功搞定了最常用的`vector`/`string`之后，又一个容器——`std::bitset<N>`——被P2417成功拉进了编译期可用的名单中。实际上在C++23之前`bitset<N>`已经部分编译期化了，不过之前被标注`constexpr`的只有默认构造函数，整数构造函数和`operator[]`，实在是太少了。这一次，整个类的所有成员和非成员都被标注成为了`constexpr`（当然，IOStreams输入/输出函数除外），包括内嵌的`bitset::reference`也完全编译期可用了。因此现在我们可以写：

```cpp
constexpr bitset<5> b = 0b11001;
b.flip(2);
static_assert(b.to_ulong() == 0b11101ul);
```

接下来，P2291为C++23编译期支持增加了另一个重要的模块——`std::from_chars`/`std::to_chars`现在在编译期可用了。由于`to_string`等函数之前也没有编译期支持，在C++23以前实际上是完全没有标准的整数/字符串编译期互转函数的，现在终于有了。不过，要特别注意的是，只有**整型**版本的`from_chars`/`to_chars`被标记了，也就是只能在编译期做整形和字符串的互转；浮点数是转换不了的。这一选择最大的原因就是浮点数版本的这两个函数在三大标准库厂商中的实现遇到了重大困难，以至于GCC长达三个版本，MSVC长达两年，Clang长达七个大版本都在已经实现整型版本的情况下完全无法实现浮点数版本的`from/to_chars`（直到现在Clang都没有浮点数`from_chars`），所以还是别忙着让它们编译期可用吧，还是需要更加成熟一些。

最后一个小的更新是P1328，它为C++23增加了一个小函数的编译期支持：`type_info::operator==`。在C++20中，`typeid`和`dynamic_cast`（即RTTI支持）在编译期中可用了，但是`typeid`得到的`type_info`对象完全没有`constexpr`成员，所以完全没法用；P1328迈出了编译期支持的第一步，为`operator==`（只有它）添加了`constexpr`标记，所以至少`static_assert(typeid(int) == typeid(i))`这样的语句可以成立了。其他的成员还得再等一等。

### _tuple-like_：类`tuple`类型的完全支持

`tuple-like` / Compatibility between `tuple`, `pair` and _tuple-like_ objects

cppreference - [P2165R4](https://link.zhihu.com/?target=https%3A//wg21.link/P2165R4) - [[tuple.like]](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/tuple.like) - 2022.07

支持：GCC not yet, Clang 2.9 (partial), MSVC not yet

测试：`__cpp_lib_tuple_like >= 202207L`

在C++98 STL中，`std::pair<T, U>`是一个很有意思的类。就其本身来说，其实就是一个`struct {T t; U u};`两个值的`struct`，用来存放两个逻辑关系上紧密相关的值。一个最典型的例子就是`std::map<K, V>::insert`的返回值：这个返回值实际上既要返回插入后的迭代器，又要返回插入是否成功，因此C++98 STL在这里用了一个`pair<iterator, bool>`作为返回值，以弥补C++没有多返回值的缺憾。当然C++98有`bind1st`这种特别注重前两个参数的模版的情况下，`pair`也完全是为了两个值而设计的（当时没有不定长模版），甚至其中还有成员变量`first`和`second`来提供便捷的访问函数：

```cpp
std::map<int, double> mp = /* ... */;
bool b = mp.insert(std::make_pair(5, 1.0)).second;
```

这也是在STL中极为罕见的`public`成员变量的出现场合之一，因为这里`first`/`second`是变量而不是函数。即使到了C++11周期，也有着越来越多的函数接受了`pair`作为参数或者返回值，比如需要同时返回最小和最大值的`std::minmax`：

```cpp
auto p = std::minmax(3, 5);
// p.first == 3, p.second == 5
```

不过，遗憾的是，以现代的目光看回去，`std::pair`很有可能是一个设计错误（或者说，“历史局限性”）。这是因为实际上无论是作为返回值还是作为参数都有着比它更好的选择：

- 第一，`std::pair`本身限死了两个参数，不能少也不能多，而很多函数需要返回三个或者更多参数；
- 第二，也是更重要的：`std::pair`并不能清晰地表达出这两个成员是干什么的，毕竟什么都是`first`/`second`。

因此，针对第二个问题，C++20 Ranges终于还是醒悟了，使用了具名`struct`和清楚命名的成员而不是`std::pair`来从Ranges算法中返回多个值，不过这是后话了。

在C++11中，第一个问题的重要性也慢慢显现出来，再加上核心语言已经有了变长模版，于是，`std::tuple`类登场了。这是一个任意参数个数版本的`std::pair`——一个参数可以`tuple<int>`，三个可以`tuple<int, double, float>`。当然，缺点就是我们失去了`first`/`second`这样方便的成员访问函数，而必须用`std::get<0>(t)`这样的语法进行访问。

不过，很尴尬的一点是，在C++11终于标准化了这个更通用的“集合”类的时候，`pair`已经存在了很多年。因此，尽管`pair<T, U>`和大小为2的`tuple<T, U>`除了成员访问以外完全一样（因此`pair`实际上已经是多余的了），WG21仍然没有办法移除这个多余的类。最终，在C++11中提供的方案是找到一个转换路径——让`pair<T, U>`可以隐式转换成`tuple<T, U>`，但是反过来则不行，这样来鼓励人们多使用`tuple<T, U>`（反正库函数的返回值可以转换过去）。标准带着这个解决办法继续上路了，十年又过去了，`pair`仍然留在了标准之中，这个转换关系仍然是单向的，没有改变；但是众所周知`tuple`的使用率仍然不算高，绝大多数人还是在用`pair`。

当然，这十年中`tuple`并没有停留不前。C++17周期中，结构化绑定第一次在标准中引入了_tuple-like_，类`tuple`类型的概念。这一概念引入的初衷是让用户可以自定义结构化绑定的行为，即让`auto [a, b, c] = t;`对于`t`是自定义类型也能够成立。在这里，类`tuple`类型实际上有两种不同的含义——第一种是最简单的，只要`T`的所有成员都是`public`的，那么就可以直接解绑定到每一个成员：

```cpp
struct S
{
    int i; double d; float f;
};

S s{1, 2.0, 3.0f};
auto [a, b, c] = s; // okay, a == 1, b == 2.0, c == 3.0f
```

但是，这种方式没有留下任何自定义的空间。

第二种方式，也是唯一一种能够自定义绑定结果的方式，就是让你的类型实现所谓的`tuple-like`协议。具体来说，要特化/重载下面三个STL type traits/函数：

- `std::tuple_size_v<T>`需要合法，并且结果是一个非负整数代表等价`tuple`的长度
- `std::tuple_element_t<i, T>`（`i`为0到`std::tuple_size_v<T> - 1`的任意整数）需要合法，并且结果是等价`tuple`的第`i`元素的类型
- `t.get<i>()`或者`get<i>(t)`（ADL `get`）必须有一个合法，并且返回等价`tuple`的第`i`个元素的值

举个简单的例子，为一个全`private`的类实现`tuple-like`协议：

```cpp
class People
{
private: std::string name;
    int age;
public:
    People(std::string_view n, int a) :name{n}, age{a} {}
    const std::string& getName() const {return name;}
    int getAge() const {return age;}
};

template<>
struct std::tuple_size<People> : std::integral_constant<int, 2> {};
template<>
struct std::tuple_element<0, People>
{ using type = std::string; };
template<>
struct std::tuple_element<1, People>
{ using type = int; };
template<int i>
auto get(const People& people)
{
    static_assert(0 <= i && i <= 1);
    if constexpr (i == 0) return people.getName();
    else return people.getAge();
}

People p{"Peter", 22};
auto [name, age] = p; // okay
// name == "Peter", age == 22
```

然而，类`tuple`类型的支持也就到此为止了——只有结构化绑定支持它们；`std::tuple`并不能从任意类`tuple`类型构造（只有`tuple`/`pair`能够构造另一个`tuple`），任意类`tuple`类型也不能和`std::tuple`比较，像`apply`，`make_from_tuple`也并不支持不是`std::tuple`的类型。不过，标准在这里留了一点余地，`std::tuple_cat`实际上是允许实现额外支持类`tuple`类型的（有一个Note提了一句），然而除此之外就没了。

这种类`tuple`类型的标准库支持缺失对标准库的其他部分并不是没有影响的。比如说，STL关联容器的API（构造函数，`insert`返回值等等）中使用的是`std::pair<T, U>`，而不是大小为2的`tuple`（毕竟C++98决定好的东西已经没法改了）。因为不是`tuple`而只是一个类`tuple`类型，这导致了整个关联容器API都不能和`tuple`互相转换：

```cpp
std::vector<std::tuple<int, double>> vec{{1, 2.0}, {3, 4.0}};
vec | ranges::to<std::map<int, double>>(); // error!
```

因为这样`std::tuple`的Range都没法转换成关联容器了，毕竟`tuple`没法转换成`pair`。不幸的是，像`views::zip`，`views::cartesian_product`等等常用的Range视图的结果元素类型都是`tuple`，毕竟多个序列`zip`起来自然就应该生成`tuple`，但这也就意味着

```cpp
std::vector vec{1, 2, 3}, vec2{4, 5, 6};
views::zip(vec, vec2) // 元素类型tuple<int&, int&>
| ranges::to<std::map<int, int>>(); // error???
```

自然我们不希望`zip`的结果没法转换成关联容器。在range-v3和2022-02标准草案中，这个问题的解决方式是让这两个视图的结果元素类型是`tuple-or-pair<Ts...>`：

```cpp
template<typename... Ts>
using tuple_or_pair = std::conditional_t<sizeof...(Ts) == 2,
    pair<Ts...>, tuple<Ts...>>;
```

对，就是强行让只`zip`两个Range的时候结果元素类型是个`pair`，这样上面就可以`ranges::to`成为关联容器了。

当然，这是一个看上去就很荒谬的解决方案，不是吗？最终，P2165在C++23周期迈出了支持类`tuple`类型的第一步：对于所有**标准**类`tuple`类型，现在STL提供了如下支持：

- 任意标准类`tuple`类型可以转换成`std::tuple`，并且可以比较大小/相等 - 任意长度为2的标准`tuple`类型可以转换成`std::pair`，并且可以比较大小/相等
- 任意两个标准类`tuple`类型之间有`common_reference`和`common_type`（就是都能转换到的那个`tuple`）
- 任意标准类`tuple`类型现在都可以用做`tuple_cat`/`apply`/`make_from_tuple`的参数

遗憾的是，这样的完整支持目前只对标准类`tuple`类型有效——也就是STL中实现了`tuple-like`协议的类型（包括`tuple`, `pair`, `array`, `ranges::subrange`）。这种限制主要是因为`std::get`到底是不是一个CPO仍然在探（chao）讨（jia）之中，所以自定义类型的这些支持得再等等了。不过无论如何，标准类`tuple`类型和`std::tuple`之间终于可以随便互操作了：

```cpp
std::array arr{2, 3, 4, 5};
std::tuple<int, int, int, int> t = arr; // okay!
auto p = std::tuple{1, 2};
std::pair p2 = p; // okay!
p2 < p; // okay!
arr >= t; // okay!
```

这样，由于`pair`也顺带可以转换成`tuple`了，`views::zip`和`views::cartesian_product`在C++23终稿中就可以永远使用`std::tuple`，而不用再对2个Range的情况特殊处理了。

这里要注意一个遗漏下来没有支持的点：`std::tuple`的CTAD推导指引是没变的，也就是说：

```cpp
std::array arr{2, 3, 4, 5};
std::tuple t{arr}; // std::tuple<std::array<int, 4>>

// 注意，现在标准中tuple仅仅对pair有特判，array和subrange默认会推导出长度为1的tuple而不是使用tuple-like协议。
std::pair p{2, 3};
std::tuple t{p}; // okay, std::tuple<int, int>
std::array arr{2, 3};
std::tuple ta{arr}; // std::tuple<std::array<int, 2>>!
```

除了这个小问题（`vector`其实也有一样的问题）之外，现在对类`tuple`类型的支持相对来说比较完整了，所以只要等着自定义类型也能被支持（从而比如，`People`可以隐式转换成`tuple`）就好了。

### 异质容器成员：最后的拼图

关联容器的异质擦除成员 / Heterogeneous erasure overloads for associative containers

[cppreference](https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/container/map/erase) - [P2077R3](https://link.zhihu.com/?target=https%3A//wg21.link/P2077R3) - [[associative.reqmts.general]/122](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/associative.reqmts.general%23122) - 2021.10

支持：GCC not yet, Clang not yet, MSVC 19.32

测试：`__cpp_lib_associative_heterogeneous_erasure >= 202110L`

容器的异质成员是标准中近10年突然兴起的一股潮流，也标志着WG21对容器成员的效率问题关注度提高到了一个新的高度。由于异质成员可以说是“幕后付出”，用户往往并不知道它们的存在，但是却能实打实地为不少常用场景带来20%甚至更高的效率提升（这点和移动语义倒是很像），所以了解它们的由来，历史与发展对于高效率地使用STL容器还是很重要的。

一切都要从C++98说起（废话，笑），当时的初版STL实际上分为四个部分，除了我们熟悉的容器，算法与迭代器以外，函数适配器也是Old STL很重要的组成部分之一。这一部分包括`binder1st`这样的旧版绑定对象，`mem_fun`这样的成员函数指针适配器，也包括这一段的主角：运算符函数对象（`std::less<T>`家族）。

（题外话：函数适配器这一部分跟被诅咒了一样，基本上所有内容到C++11都相当于是被废弃了，全部推倒重来了一遍：`binder1st`家族变成了`std::bind`/`bind_front`/`bind_back`，也不再暴露函数适配器类型；`mem_fun`变成了`mem_fn`，在lambda存在的情况下显得也有些尴尬；`not1`/`not2`变成了`not_fn`；然后运算符函数对象也都被异质版本取代了。或许这也是为什么一般只认为Old STL有三个部分，因为那三个部分在C++20之前没怎么变，原来的函数适配器部分则几乎完全消失了。当然，诅咒是开玩笑的，能看出来，C++11变长参数模版其实是所有这一切推倒重来的最重要原因）

在C++98中，运算符函数对象总共有18个，都和`std::less<T>`差不多，总计是加减乘除+取模取负+六种比较运算符+三种条件运算符+位运算符（`&`, `|`, `^`）这些。（比较搞笑的是，很容易发现这个列表里缺了位运算符`~`，但是当年就是忘了；直到C++14才想起来赶紧把`std::bit_not<T>`扔进标准）。这些运算符函数对象的写法都是

```cpp
template<typename T>
struct less
{
    /* constexpr(C++14) */ bool operator()(const T& lhs, const T& rhs) const
    { return lhs < rhs; }
};
```

其实就像看上去一样简单：把对应的运算符包装成函数对象而已。这一提升最重要的作用就是让这些运算符能够直接传递给各种STL算法的函数参数：

```cpp
std::vector<int> vec = /* ... */;
sort(vec.begin(), vec.end(), std::greater<int>()); // 反向排序
```

当然，这属于当年没有lambda的一个曲线救国方案，但是现在回头来看，即使有了lambda，现在的语法还是没有这么简单。

在C++98 STL中，这些看似简单的运算符函数对象其实除了STL算法之外，还有另外一个用法：关联容器的比较器参数。我们知道，`std::set`（和其他关联容器）的完整模版参数是：

```cpp
template<
    class Key,
    class Compare = std::less<Key>,
    class Allocator = std::allocator<Key>
> class set;
```

这里的第二参数就是比较器。传入的比较器会被当作“小于”操作的实际定义——或者说，`set`内部会认为`Compare()(a, b)`为`true`就意味着`a < b`。因此，和STL算法一样，`set<int, greater<int>>`就可以直接创造出一个最大元素在前的`set`。（当然，C++20给lambda匿名类加了默认构造函数之后，这里可以把`decltype([](int i, int j) {return i > j;})`当作第二参数传进去，不过这是后话了）

不幸的是，这个看似还可以的设计最终被证明是有一些小问题的：首先是一个不少人应该已经看出来的缺陷：每次使用这些函数对象的时候都要指明类型，即`greater<int>`，`plus<std::string>`这样的。但是这完全是不必要的——只要我们能够把模版放到成员函数上去而不是类本身：

```cpp
struct less
{
    template<typename T>
    constexpr bool operator()(const T& lhs, const T& rhs) const
    { return lhs < rhs; }
};
```

突然，这个`less`就不用再是模版类了：只需要`sort(vec.begin(), vec.end(), less{})`，我们就可以直接让编译器推导出所需的比较类型，省掉一堆字母和一对尖括号。

另外一个重要的问题是这些函数对象的签名：`bool(const T&, const T&) const`。这个签名最重要的限定就是两个参数的类型必须一样，虽然看上去没什么大不了的（毕竟通常情况下`a + b`，`a`和`b`的类型都一样），但是很明显，C++运算符重载的自由度就代表了这个限制是过于严厉的。具体来说有下面这几种不符合这个签名的可能：

- 异质运算符，即`a + b`，`a`和`b`类型不相等的情况。最简单的例子就是`std::equal(vec_int.begin(), vec_int.end(), vec_double.begin(), std::equal_to<double>{})`这样，明明是`int == double`我们却必须先转换成`double`才能用同质的函数对象。
- 效率问题。比如说，在一个`vector<const char*>`中二分查找`std::string`，如果把`greater<std::string>`传给`lower_bound`就有效率问题了——每一个元素都要构造成`string`才能比较，显然非常之浪费，`greater<const char*>`又传不进去。

最终，认识到了C++98运算符函数对象的这些问题，C++14接受了提案[N3421](https://link.zhihu.com/?target=https%3A//wg21.link/N3421)，在标准库中提供了异质的通用运算符函数对象。具体实现其实很简单：

```cpp
struct less
{
    template<typename T, typename U>
    constexpr decltype(auto) operator()(T&& t, U&& u) const
    { return forward<T>(t) < forward<U>(u); }
};
```

对，就是在成员函数模版的基础上用两个万能引用参数接受，然后完美转发给运算符。这样，上面的问题就没有了：

```cpp
vector<const char*> vec = /* ... */;
std::string str = /* ... */;
std::lower_bound(vec.begin(), vec.end(), str, greater{});
```

就会自动生成一个`const char*`和`string`比较的成员`operator()`，从而达到最大效率。

遗憾的是，在C++14意识到这个问题的时候，`std::less<T>`和其他函数对象已经在标准库中存在了16年了，而这些函数对象的语义又决定了没法轻易换名字（想象一下，要是STL里同时有`std::less<T>`和`std::less_than`，会迷惑多少人）。因此，最后N3421选择了一条妥协的路：

```cpp
template<typename T = void>
struct less {/* 原来的less<T> */};

template<>
struct less<void> {/* 新的异质运算符函数对象 */};
```

也就是说，用之前非法的`less<void>`来做万能对象，然后保留原来的同质函数对象。这样，虽然使用上稍微繁琐了一点（得用`std::less<>{}`而不是`std::less{}`），但是也算可以接受：

```cpp
std::lower_bound(vec.begin(), vec.end(), str, std::greater<>{});
```

（后来，C++17 CTAD又一次去掉了`<>`，使得`std::greater{}`也合法了，所以这算是个成功的妥协故事）

最终，在C++20 Ranges全面翻新的大潮中，WG21终于找到了完美的新名字：`less_than`和`less`容易混淆，我们可以加个命名空间做成`std::ranges::less`嘛！这样就能保留原来的好名字还能更新内容了。于是，C++20中，六个比较运算符（注意只有这六个，剩下的没更新）被提升进了`std::ranges`命名空间，并且顺带和Ranges算法一样被加上了Concept：

```cpp
struct less
{
    template<typename T, typename U>
        requires totally_ordered_with<T, U>
    constexpr decltype(auto) operator()(T&& t, U&& u) const
    { return forward<T>(t) < forward<U>(u); }
};
```

注意这个Concept就意味着新的`ranges::less{}`实际上比`std::less<void>`要求更严，后者只需要`t < u`合法就行，但是前者需要所有六个比较运算符都是合法的才行。另外，随着三相比较操作符加入标准，`std::compare_three_way`（对应`<=>`）也成为了标准库第20个，也是至今为止最后一个运算符函数对象。

回到C++14周期，我们知道，异质运算符函数对象加入标准最重要的原因之一就是效率问题——STL算法（比如`lower_bound`）有可能会将元素和传入的（不同类型）对象进行比较，从而传入异质运算符函数对象避免了构造临时对象的开销。但是，STL算法的特殊设计意味着异质运算符可以在这里使用，原来的`std::less<T>`应用到的另一个领域——STL关联容器——则就没有这么好的设计了。关联容器本身也有`find()`成员函数，和`std::lower_bound`的行为很像；而且也有着同样的效率问题：

```cpp
std::set<std::string> ss = /* ... */;
ss.find("key"); // !!
```

注意这个场景甚至比`lower_bound`更加常见——毕竟`const char*`的容器不太常见，像这样把字符串字面量传进去查找可就太常见了。遗憾的是，`find()`的签名是

```cpp
iterator find(const Key&);
const_iterator find(const Key&) const;
```

这里也就意味着字符串字面量会被先构造成一个临时`std::string`对象，然后再跟`set`元素比较。自然，这个效率问题很好解决，直接用上模版不就好了？

```cpp
template<typename K> iterator find(const K&);
template<typename K> const_iterator find(const K&) const;
```

不过，这时候，另一个C++98的选择出来搅局了——`std::set<T>`的默认比较器是`std::set<T, std::less<T>>`，而且在C++14那时候已经没法改这个默认值了，因为改了就是ABI Break；于是，如果还使用`less<string>`做比较器，上面的模版`find()`就是无用功了，甚至还更恶化了性能——原来`find("Key")`只是在调用时构造一个临时对象，现在变成了每次比较都要构造一个临时对象了。

于是，C++14最后接受的提案[N3657](https://link.zhihu.com/?target=https%3A//wg21.link/N3657)同样采用了一个折中方案：只有在你使用`std::less<>`作为比较器的时候，`std::set`才会有上面的模版`find()`重载。具体来说，`std::less<>`和其他的异质函数对象会遵守透明协议，即提供一个`is_transparent`成员类定义：

```cpp
template<>
struct less<void>
{
    using is_transparent = void; // =什么不重要，有这个类型定义就行
    // ...
};
```

（甚至你写个`struct is_transparent {};`也行，只要是个类型就行）。`std::set`和其他有序关联容器在传入遵守透明协议的比较器作为第二参数的时候（这样第三方函数对象也可以获得性能提升），就会将`find()`，`count()`，`lower_bound()`，`upper_bound()`，`equal_range()`这五个用于比较的成员函数（当然，还有C++20的`contains()`）按照上面的方式模版化；如果没有遵守透明协议，就还是原来的同质重载。也就是说：

```cpp
std::set<std::string> ss = /* ... */;
ss.find("Key"); // 效率问题，产生1个临时对象
std::set<std::string, std::less<>> ss2 = /* ... */;
ss2.find("Key"); // 没有效率问题
```

换句话说，`std::set<T, std::less<>>`就应该是默认使用的`set`类型，只是没法再改默认参数而已（PMR `set`也没能改正这个错误，有点可惜）。

这只解决了1/4的问题。首先，这些新的模版成员只适用于有序关联容器（`set`/`map`/`multiset`/`multimap`和它们的平坦版本），无序关联容器还没有解决。另一方面，除了查找系列函数，擦除和插入/访问成员函数也可以通过模版化来提高效率。这两个维度的扩展首先由C++20接受的提案[P0919R3](https://link.zhihu.com/?target=https%3A//wg21.link/P0919R3)作出：将查找系列函数的模版化扩展到了无序关联容器。不过，无序容器的解决方案更加复杂一些。

表面上来看，我们完全可以采用和异质运算符函数对象一样的方法，提供一个异质的哈希算法对象：

```cpp
template<typename T = void> struct hash;

template<>
struct hash<void>
{
    template<typename T>
    std::size_t operator()(T&& t) const
    {
        return std::hash<std::decay_t<T>>{}(std::forward<T>(t));
    }
};
```

然后指定`unordered_set<string, hash<>>`不就可以同时`hash`字符串常量了吗？遗憾的是，无序容器除了哈希算法以外，还要（在第三参数）指定等价关系（默认是`std::equal_to<T>`），而哈希算法必须和等价关系尽量形成一个双射（即`a == b`一定意味着`hash(a) == hash(b)`）。然而，在异质情况下，即使我们指定异质等价关系`std::equal_to<>`，这个双射也不会再成立：

```cpp
-1L == -1.0 // okay
hash<long>{}(-1L) == hash<double>{}(-1.0) // 多数平台false
```

推广开来，不同的两个类型一般哈希算法也不一样，所以即使跨类型比较能够相等它们的哈希值也不会相等。（不是双射的后果就是对于一个`unordered_set<double, hash<>, equal_to<>>`，插入`-1L`会成功，但是之后再用模版`find()`查找`-1L`的时候会查找失败，因为哈希值不相等会找到错误的bucket去）

因此， P0919最后的解决办法是引入跟透明比较协议类似的一个透明哈希协议。对于一个哈希算法对象（比如`std::hash<T>`）来说，要遵守透明哈希协议就要提供一个成员类型定义`transparent_key_equal`，指向一个遵守透明比较协议的等价关系类（最常用的肯定就是`std::equal_to<>`）。比如说：

```cpp
struct string_hash
{
    using transparent_key_equal = std::equal_to<>;
    using hasher = std::hash<std::string_view>;
    std::size_t operator()(std::string_view sv) const
    { return hasher{}(sv); }
    std::size_t operator()(const char* sv) const
    { return hasher{}(sv); }
    std::size_t operator()(const std::string& sv) const
    { return hasher{}(sv); }
};
```

这就是一个符合透明哈希协议的类。要注意的是，这里我们采用的手段是把所有类字符串的类型全部（隐式）转换成`string_view`，然后用同一个hasher进行哈希；注意千万不能用`hash<const char*>`，`hash<string>`和`hash<string_view>`分别进行哈希，要不然就掉到同一个陷阱里了，而且标准库并没办法检查你给的函数是不是双射，只能相信你。

（题外话：标准库提供不了`std::hash<>`，但是完全可以仿照上面的类提供一个`std::hash_to<T>`啊，估计又懒了，这种透明哈希类只能自己写了）

这样，当你将无序关联容器的第二个模版参数指定成一个透明哈希类的时候，你就不用再写第三个模版参数了——会自动使用你的`transparent_key_equal`作为等价关系类（如果写了，你也只能写一样的等价关系类；写不一样的会编译错误）。这样：

```cpp
std::unordered_set<std::string, string_hash> us;
us.find("Key"); // 无临时对象
```

另一个维度，即扩展到除了查找之外的更多成员函数，首先由C++23接受的P2077进行推进。P2077将这种异质模版成员推广到了擦除函数上，即关联容器的`erase()`和`extract()`。这两个函数比起查找成员更加复杂一点，它们有一个重载`erase(const_iterator)`，传入一个迭代器而删除掉指向的元素。如果我们还是加`erase(const auto&)`作为异质模版，那么就会和这个迭代器重载产生冲突。为了解决这个问题，`erase()`和`extract()`的模版成员使用了万能引用（即签名是`erase(T&& arg)`），然后在`T&&`能够转换成`iterator`或者`const_iterator`的时候关闭模版重载。（这对用户来说唯一的区别就是不能把bit-field传进去了而已）。当然，有序/无序容器的两种透明协议没有改变，有透明比较/哈希函数就会开放这些模版异质重载，没有就不会出现这些模版成员。总结起来就是调用形式不用变，提供透明对象就能获得免费的性能提升。

P2077只是初步扩展（多了两个成员），在这个维度上的进一步扩展则由C++23周期的提案[P2363R3](https://link.zhihu.com/?target=https%3A//wg21.link/P2363R3)进行。这一提案以完全一致的方式将异质成员扩展到了插入和访问函数，即`set`的`insert()`，`map`的`insert_or_assign()`，`try_emplace()`，`at()`，`operator[]`，以及无序关联容器的`bucket()`成员。毕竟，用户不用改调用代码，加上一个透明对象就可以获得性能提上，这当然是不错的。这一提案本已通过LEWG Electronic Poll，离最终接受只差LWG的一次review，但是遗憾的是，在C++23周期的末尾，和C++20周期末尾一样的事情发生了：LWG在50多个待review提案的压迫下最终耗尽了所有时间，在C++23定稿日到来之前的两周，被迫扔掉了几个提案来保证相对来说更重要的提案（比如那些新的Ranges适配器）能够进入C++23。P2363在这一波变动中最终被扔出C++23周期，只能在C++26周期进行接受了。（同样被扔掉的还有P1885，P0792这些也很重要的提案）

不过，也是在定稿前最后几周，非常搞笑和巧合的一件事情发生了——C++23的平坦容器（P0429 `flat_map`和P1222 `flat_set`，见上篇的介绍）是在2022年6月中旬通过LWG review，最终成功进入C++23的；当时P2363还在LWG队列中没有掉出去，因此P0429和P1222进行了相应的修改（毕竟同一个标准版本接受嘛），将P2363提出的这些异质模版成员加入了`flat_set`/`flat_map`的API。然而，仅仅两周之后，P2363掉了出去，这导致了一个很有意思的局面：`flat_set`/`flat_map`（和`multi`版本）是有`at()`，`insert()`之类的成员函数的异质模版重载的，但是`std::map`/`std::set`却没有这些成员函数的模版重载，从而平坦容器能够获得又一个性能优势——我个人希望这个插曲能够让某个NB Comment捞一下P2363，就跟P2505一样；不过现在看来希望渺茫。

### Ranges迭代器与pre-C++20算法支持

让pre-C++20算法支持Ranges迭代器 / Ranges Iterators As Inputs To Non-Ranges Algorithms

cppreference - [P2408R5](https://link.zhihu.com/?target=https%3A//wg21.link/P2408R5) - [[algorithm.requirements]/4.4](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/algorithms.requirements%234.4) - 2022.07

支持：GCC not yet, Clang not yet, MSVC 19.34

测试：`__cpp_lib_algorithm_iterator_requirements >= 202207L`

C++20 Ranges库在引入一大批新东西（Ranges算法，适配器，etc）的同时，也彻底改变了C++98以来的迭代器模型——一方面是迭代器-哨兵模型取代了迭代器对，另一方面Ranges库也用C++20 Concepts完全重写了迭代器的要求，使得现在我们终于可以在定义算法模版的时候就直接要求特定的迭代器类型：

```cpp
template<ranges::random_access_iterator I,
         std::sentinel_for<I> S>
void sort(I it, S sentinel);
```

这样就可以直接要求一个随机访问迭代器，传一个`list<int>::iterator`进来就会直接报错，而不是到比较的时候再报错。

不过，由于C++17时代迭代器是使用文字制定的要求，而C++20使用了Concepts（代码）来严格地指定迭代器要求，所以这两个时代的迭代器要求是有一些区别的。举个例子，在C++17时代前向迭代器的要求是：（[[forward.iterators]](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/forward.iterators)）

> A class or pointer type `X` meets the requirements of a forward iterator if  
> - X meets the Cpp17InputIterator requirements,  
> - X meets the Cpp17DefaultConstructible requirements,  
> - if `X` is a mutable iterator, `iterator_traits<X>::reference` is a reference to `T`; if `X` is a constant iterator, reference is a reference to `const T`,  
> - the expressions in Table [tab:forwarditerator] are valid and have the indicated semantics, and  
> - objects of type `X` offer the multi-pass guarantee, described below.  
> … [tab:forwarditerator]:  
> - `r++`: Return type convertible to `const X&`, semantics …  
> - `*r++`: Return type is `iterator_traits<X>::reference`

而C++20时代，前向迭代器Concept `std::forward_iterator<I>`的要求是：（[[iterator.concept.forward]](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/iterator.concept.forward)）

```cpp
template<class I>
  concept forward_­iterator =
    input_­iterator<I> &&
    derived_­from<ITER_CONCEPT(I), forward_iterator_tag> &&
    incrementable<I> &&
    sentinel_­for<I, I> &&
    /* multi-pass guarantee */;
```

乍一看，并没有什么区别，都是在输入迭代器的基础上要求可默认构造（C++20 `sentinel_for<I, I> -> semiregular<I> -> default_initializable<I>`），多遍遍历，和可自增。然而，实际上`Cpp17ForwardIterator`和`std::forward_iterator`的要求有两点不同：

1. `Cpp17ForwardIterator`要求了`Cpp17InputIterator`要求了`Cpp17Iterator`要求了`Cpp17Destructible`。这个概念的要求（[[tab:cpp17.destructible]](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/tab%3Acpp17.destructible)）是”All resources owned by `u` are reclaimed, no exception is propagated.”，也就是不让异常离开析构函数就行，并没有要求析构函数必须标注`noexcept`（比如说，用`catch`捕获异常就行，写`noexcept(false)`也能满足要求）。而`forward_iterator -> input_iterator -> input_or_output_iterator -> weakly_incrementable -> movable -> move_constructible -> constructible_from -> destructible`这一长串依赖看到底，`std::destructible<I>`明确要求了`is_nothrow_destructible_v<I>`，也就是析构函数必须明确标注`noexcept`。
2. `Cpp17ForwardIterator`明确要求了（上面第三条）可变迭代器的`iterator_traits::reference`是`T&`或者`const T&`，`std::forward_iterator -> input_iterator -> indirectly_readable`只要求了`iter_reference_t<X>`存在，没有要求它必须是一个引用。

当然，这第一条区别有一点吹毛求疵，毕竟所有析构函数默认都是`noexcept`的，这个区别不太可能造成问题（明确写`noexcept(false)`析构函数的迭代器？即使有这么写的也该改改了）。不过，第二条区别（注意第一条适用于所有迭代器，第二条只有前向迭代器有这个区别）可就有意义了：`iterator_traits<I>::reference`不是原生引用并不是一个很奇怪的事情，最典型的例子就是代理迭代器。`vector<bool>::iterator`的引用类型是`vector<bool>::reference`，并不是一个引用类型，所以这个迭代器只是一个C++17输入迭代器，尽管除了这一条要求之外它满足C++17随机访问迭代器的所有其他要求，而这个迭代器完全是一个符合标准的C++20随机访问迭代器。标准库中的其他代理迭代器包括`zip_view::iterator`（引用类型为`tuple<T&, U&, ...>`）和`flat_map::iterator`（引用类型为`pair<const K&, V&>`），这些都是C++20前向迭代器（或者更高）但是只能是C++17输入迭代器。

如果我们只考虑C++17/20的输入迭代器，这两个概念还有另一个重要区别：后置自增运算符`operator++(int)`的返回值。正常情况下，后置自增运算符应该返回自增之前的值的拷贝，而`Cpp17InputIterator`也是这么要求的（`*r++`返回值要能转换成`T`）。不过，对于输入迭代器来说，由于只能单遍遍历，自增运算符是有可能让自增之前的值失效的——最典型的例子就是`istreambuf_iterator`，其自增运算符会从从输入流中读取字符，所以直接返回自增前的迭代器就是一个失效值了。因此，这个迭代器被迫实现了一个代理类，内部存放了读取的值，让后置自增运算符返回。Ranges TS时代中的提案[P0541R1](https://link.zhihu.com/?target=https%3A//wg21.link/P0541R1)去掉了这个要求，从而C++20的输入迭代器的后置自增运算符不用返回`T`——事实上，所有的标准库中的C++20输入迭代器的后置自增运算符返回的都是`void`。这是一个安全措施，因为下面的代码是危险的：

```cpp
some_input_iterator it = /* ... */;
auto pre = it++;
*pre; // 危险！
```

在第三条语句中`pre`已经失效了，因此唯一合法的使用方式就是`*it++`这样直接解引用（这也是`Cpp17InputIterator`唯一要求合法的形式）。C++20让`it++`不再返回任何东西，因此虽然`*it++`也不合法了，但是安全性得到了保证。因此，像`istream_view`，`join_view`（输入Range）之类的C++20输入迭代器的`operator++(int)`返回值都是`void`。

这也就意味着两件事情：

- 一个C++20前向迭代器一定是一个C++17输入迭代器，但是有可能不是一个C++17前向迭代器
- 一个C++20输入迭代器有可能连C++17迭代器都不是

为了解决这个迭代器类型不相符的问题，C++20迭代器将原来的类型指示器`iterator_category`拆成了两个部分：`iterator_category`和`iterator_concept`，前者表示C++17迭代器类型，后者表示C++20迭代器类型。而标准库中决定迭代器类型的概念`ITER_CONCEPT(I)`（[[iterator.concepts.general]](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/iterator.concepts.general)）则会先看`iterator_concept`，没有再看`iterator_category`，从而就可以同时兼容C++20新迭代器和C++17旧迭代器（只提供category就代表前后迭代器类型没变）。因此，上面的两种类型的不相符体现到代码上就是：

- 像`iota_view<W, Bound>::iterator`这样的C++20新（前向）迭代器，`iterator_category`永远都是`input_iterator_tag`（因为它的引用类型是`W`，不是一个引用），而它的`iterator_category`最高有可能是`random_access_iterator_tag`。这就表示它是一个C++17输入迭代器，但是有可能是一个C++20随机访问迭代器。
- 像`istream_view::iterator`这样的C++20新输入迭代器，它完全没有提供`iterator_category`成员类型，而提供了`iterator_concept`为`input_iterator_tag`。这就表示它不是一个C++17迭代器，但是是一个C++20输入迭代器。（注意，这种情况下`iterator_traits`也是一个空类）

后一种情况是由C++23周期的（给C++20的DR）提案[P2259R1](https://link.zhihu.com/?target=https%3A//wg21.link/P2259R1)引入的，其中明确了标准库中的所有C++20输入迭代器都不是C++17迭代器，从而不提供`iterator_category`成员类型。

但是，这只是解决了Ranges适配器的迭代器类型问题，Ranges算法的问题并没有解决——准确的说，Ranges算法当然没问题（它们用的是新的C++20迭代器Concept），但是Old STL中的算法仍然用的是C++17迭代器概念：

```cpp
auto idxs = std::views::iota(0, N);
std::transform(std::execution::par,
               begin(idxs), end(idxs), begin(sqrts),
               [](int x) { return std::sqrt(float(x)); }); // error!
```

这里`transform`要求传入的迭代器是`Cpp17ForwardIterator`，而根据之前的讨论，`iota_view::iterator`是C++20随机访问迭代器，但是只是C++17输入迭代器，所以这个调用理论上是非法的。不过，在实际实现中，这些C++17算法引入的时候并没有Concept支持，所以很多实现都没有检查`Cpp17`迭代器概念的满足程度，而依赖于实际运算报错，所以上面的例子在这些实现（比如libstdc++）中不会报错。MSVC STL严格地检查了这些算法的迭代器概念，所以上面的例子在MSVC中会报错。

你可能会问：这不就是Ranges算法引入的原因吗？使用新的迭代器类型，从而上面的例子用`ranges::transform`就没问题了。不过，pSTL算法的Ranges版本可能还要等很久很久才能进入标准（要和Executors协调），而这和迭代器-哨兵/迭代器对的区别还不一样（虽然旧算法要求迭代器对，大部分情况下`views::common`包一层就行），没有标准适配器来帮你把`iota_view::iterator`包装成一个C++17随机访问迭代器。

最终，P2408采用了比较激进的手段，直接让所有这些Old STL算法使用了新的C++20迭代器类型。具体来说，所有要求常量迭代器+C++17前向迭代器的Old STL算法， 现在都会使用C++20的新迭代器概念，从而上面的例子就是合法的了。注意，这里只改变了要求常量迭代器的算法（比如`std::transform`的输入迭代器对）要求可变迭代器的算法并不能直接这么放松，因为它们无法正确处理代理迭代器：将`zip_view::iterator`传给`std::sort`是不会成功排序的（因为其中使用的是标准`std::swap`，三变量交换是没法正确交换两个代理迭代器的），而使用`ranges::iter_swap`的`ranges::sort`就能成功。当然，旧算法使用的还是迭代器对，所以对于非common Range可能需要`views::common`包一层，但是除此之外新的C++20 Range应该可以无缝用做Old STL算法的输入参数了。

### Reference Binding to Temporary：生命周期错误检测

检测生命期扩展的type traits / A type trait to detect reference binding to temporary

[cppreference](https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/types/reference_constructs_from_temporary) - [P2255R2](https://link.zhihu.com/?target=https%3A//wg21.link/P2255R2) - [[tab:meta.unary.prop]](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/tab%3Ameta.unary.prop) - 2022.02

支持：GCC 13 (partial), Clang not yet, MSVC not yet

测试：`__cpp_lib_reference_from_temporary >= 202202L`

生命期扩展（lifetime extension）是一个很有趣的C++98标准小bug（当然也可以叫_特性_，笑）。即使在最新标准中，这个小玩意也在发挥着自己的重要作用，大部分时候你都感觉不到它的存在（因为扩展是自动的），但是你要是感觉到了估计就是出问题的时候。最简单的生命期扩展例子是：

```cpp
int main()
{
    const int& i = 1;
}
```

我们知道，和可变引用只能绑定到左值不同，一个常量引用是可以绑定到右值（具体来说，prvalue和xvalue都可以，这里是前者）的，这也是为什么C++98时代的guidelines普遍建议使用常量引用而不是值传递作为参数：不损失用法优势（左右值都能传递）的同时避免了拷贝的存在。但是，作为引用，`i`一定是要绑定到一个具体的地址上的（毕竟底层就是指针），这里右边的1不过是一个字面量，哪里来的地址呢？这里，标准要求编译器必须将临时值（1）的生命周期延长到和引用`i`一样，也就是说编译器会自动生成下面的代码：

```cpp
int main()
{
    const int __temp = 1;
    const int& i = __temp;
}
```

这里隐藏的`__temp`变量会和`i`的生命周期完全一样，同时构造也同时析构。

这条生命期扩展的规则要求很严格：右侧必须是一个临时值（也就是prvalue）才能考虑延长，xvalue可不行！比如说：

```cpp
int fun1(const int& x) { return x; }
const int& r1 = fun1(1); // okay, lifetime extension

const int& fun2(const int& x) { return x; }
const int& r2 = fun2(1); // dangling! 悬挂引用
```

这里`fun1(1)`返回的prvalue临时值会像刚才一样，自动生成一个隐形的变量把生命周期延长到和`r1`一样；但是`fun2(1)`返回的并不是临时值，而是另一个引用，所以这里字面量1的生命期延长仅限和`x`一样，在这个语句结束之后`r2`立刻成为了悬挂引用。

生命期延长并不严格限制左右必须是同类型——绑定到某个对象的**直接**子对象的引用也会导致整个对象的生命周期被延长：

```cpp
struct S
{
    int x;
    const int& getX() const { return x; }
};
S getS();

const int& r = getS().x; // ok! 返回值生命期被延长
// 等价于
const S s = getS();
const int& r = s.x;
```

注意这里仅限直接子对象（包括成员变量访问，父类对象绑定，数组元素之类的，标准直接在[[class.temporary]/6](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/class.temporary%236)把所有能延长的表达式列了个表），如果我们写的是`const int& r = getS().getX()`的话，这里直接就是悬挂引用了，因为函数返回的引用并不会引发任何生命期扩展。

你可能会想，谁会故意用引用接受函数返回的临时变量呢？上面的例子也太造作了一点吧。不过，生命期扩展实际上作为幕后的功臣，在我们耳熟能详一个语言构造上有着不可或缺的重要作用：range-based `for`循环。如下形式的`for`实际上是一个非常常见的构造：

```cpp
for (auto&& elem : getVector()) ...
for (const auto& elem : getRange()) ...
for (auto elem : vec | views::reverse) ... // reverse_view{vec}，右值哦！
```

按照[[stmt.ranged]](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/stmt.ranged)中的标准形式展开，第一个循环展开出来就是：

```cpp
{
    auto&& range = getVector(); // <==
    auto begin = ranges::begin(range);
    auto end = ranges::begin(range);
    for (; begin != end; ++begin)
    {
        auto&& elem = *begin; // <==
        /* body */
    }
}
```

注意，这里`range`的定义直接就依赖于生命期扩展才能成立——将`getVector()`返回的右值扩展到至少在整个循环都有效。除此之外，`elem`的定义也有可能使用生命期扩展，比如如果这是一个prvalue Range（比如`vec_of_int | views::transform([] (auto a) {return std::to_string(a);})`这种很常见的构造就是一个prvalue `std::string`的Range），那么这一行也相当于把`operator*`返回的右值扩展到了在整个循环体都有效。

这也引出了range-based `for`循环的一个重要缺陷：如下的常见构造实际上是UB：

```cpp
struct S
{
    vector<int> vec;
    const vector<int>& getVector() const {return vec;}
};
S getS();

for (auto elem : getS().getVector()) /* UB! */
```

原因就是刚才说过的，生命期扩展只能用于直接子对象，拿一个函数返回引用就会使得`vec`的生命期没有被扩展，从而上面的展开中`range`从第三行开始就是悬挂引用了。C++20的带初始化语句的range-based `for`循环就是特意为解决这个缺陷而生的：

```cpp
for (auto&& s = getS(); auto elem : s.getVector()) /* ... */
```

这里`getS()`的返回值生命周期直接被延长了，所以后面的循环就没事了。

在很多其他细微的方面，生命期延长也发挥着一定的作用。比如说：

```cpp
vector<bool> vb = /* ... */;
for (const auto& elem : vb) // elem = *begin那条实际上延长了返回的vector<bool>::reference的生命期

struct S
{
    const std::string& getString() const;
    int getInt() const;
};
S s;
const auto& i   = s.getInt();
const auto& str = s.getString();
// 语法统一，两条初始化也都成立；以后getInt()改成返回引用这里也不用改
```

不过，很多时候，（缺少）生命期扩展也会带来一些很细微的问题。比如说，成员引用变量如果初始化成一个临时值，这里是没有生命期扩展的（直接搬[[class.base.init]/11](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/class.base.init%2311)的例子，注释有亮点）

```cpp
struct A {
  A() = default;        // OK
  A(int v) : v(v) { }   // OK
  const int& v = 42;    // OK
};
A a1;                   // error: ill-formed binding of temporary to reference
A a2(1);                // OK, unfortunately
```

这里`a1.v`构造完就是悬挂引用，所以C++14接受的DR [CWG Issue 1696](https://link.zhihu.com/?target=https%3A//wg21.link/CWG1696)干脆直接禁止了这种情况调用构造函数——也就是`a1`的构造是ill-formed。然而，标准也承认，不幸的是，`a2`的构造是成立的，但是构造函数`A(int)`内部成员引用会直接绑定到`v`这个参数，而这个参数函数执行完就被销毁了，所以`a2.v`构造完也是悬挂引用…

当然，这里确实用`A(const int& v)`就没有问题了。但是，即使用引用传递，也并不能完全避免缺少生命期扩展带来的悬挂引用，比如说`std::tuple`。`std::tuple<const std::string&>`这个实例化的模版大概长这个样子：

```cpp
struct tuple<const string&>
{
    const string& member;
    // ...
    template<typename UTypes> tuple(UTypes&& u)
    : member(forward<UTypes>(u)) {}
};
```

这里用的是万能引用，那么没问题了吗？

```cpp
tuple<const string&> ts{"222"s}; // okay... but
tuple<const string&> ts2{"222"}; // !!!
```

`ts`倒是确实没问题，但是`ts2`产生的构造函数`tuple(const char (&)[4])`在`member`的成员初始化列上就会就地生成一个临时`std::string`对象；这个对象虽然会被生命期延长，但是只会延长到函数参数`u`被销毁的地方，也就是这个构造函数一结束`member`就是悬挂引用了。标准也“不幸地”没有禁止这种情况调用构造函数。

既然核心语言没法禁止，那么标准库就只能自己上了，这也就是P2255的目的：提供必要的工具使得`ts2`这样的构造函数调用被禁止。具体来说，两个新的type traits被提出：`std::reference_constructs_from_temporary<T, U>`和`std::reference_converts_from_temporary<T, U>`，它们都是专门用来检测生命期延长是不是发生的，前者检测直接初始化，后者则是拷贝初始化。具体来说，这两个type traits的`T`都必须是个引用类型并且可以被`U`构造/转换（否则一定是`false`），然后如果`T t(e)`/`T t = e`（其中`decltype(e) == U`）这样的构造表达式会造成`e`的生命期被延长，那么type traits的结果就是`true`。举一些例子：

```cpp
template<typename T, typename U>
inline constexpr bool RCFT = std::reference_constructs_from_temporary_v<T, U>;

int getInt();
int&& getIntRef();
long&& getLongRef();

RCFT<int&&, int>; // true, int&& t(getInt())有生命期延长
RCFT<const int&, int>; // true, 同样
RCFT<int&&, int&&>; // false, int&& t(getIntRef())没有生命期延长
RCFT<int&&, long&&>; // true, int&& t(getLongRef())有生命期延长（不是直接绑定，要先生成临时对象）
```

这样，对于`std::tuple`来说，我们只需要：

```cpp
template<typename... Ts>
struct tuple
{
    // ...
    template<typename... Us>
    tuple(Us&&... us)
    requires (reference_constructs_from_temporary_v<Ts, Us&&> || ...)
    = delete;
};
```

我们就可以拒绝上面的`ts2`构造了。

P2255为`std::pair`，`std::tuple`和所有使用`INVOKE<R>`表达式的类型（`std::function`/`std::visit<R>`/`std::bind<R>`/`std::packaged_task`/`std::invoke_r`/`std::move_only_function`）都做了这样的更改。`INVOKE<R>`也做是为了防这个情况：

```cpp
std::function<const std::string&()> func = []{ return std::string{}; }
// 注意，return语句中的临时变量不会被生命期扩展
```

### 禁止`nullptr`构造`string`：半截解决方案

禁止`std::basic_string[_view]`从`nullptr`构造 / A Proposal to Prohibit `std::basic_string` and `std::basic_string_view` construction from `nullptr`.

[cppreference](https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/string/basic_string/basic_string) - [P2166R1](https://link.zhihu.com/?target=https%3A//wg21.link/P2166R1) - [[basic.string]](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/basic.string) - 2021.06

支持：GCC 12, Clang 13, MSVC 19.30

测试：无

```cpp
struct customer_id
{
    int x;
    customer_id(int v) :x(v) {}
};

void fun(const std::string& name);
void fun(customer_id id);

int main()
{
    fun(111); // Great
    fun("Peter"); // Great
}
```

假设我们有这么一个重载集，传递一个顾客作为参数既可以传ID又可以传名字…看起来没啥问题？

```cpp
fun(0);
```

嗯？

`fun(0)`这个调用实际上是有二义性的：`customer_id`自不必说，还是可以从`int`构造，但是`std::string`怎么能从0构造呢？还是老生常谈的C遗留问题：0既是一个整数字面量又是一个指针字面量：

```cpp
std::string str = "Hello"; // string(const char*)
std::string str = 0; // string(const char*)
std::string str = nullptr; // string(const char*)
```

嗯，第一个构造当然是很合理的，会调用接受`const char*`的构造函数…然而这个构造函数同样会接受第二个和第三个构造。当然，这里“接受”仅仅意味着能够成功编译，将空指针传给`string`构造函数当然是个UB，因为构造函数要求传入的是一个合法的字符串起始位。然而，运行期UB显然不是一个很好的结果，毕竟能在编译期检测出来的错误就不要拖到运行期。（这个例子估计看起来很造作，但是即使是像LLVM这样的大工程中居然也真的会赤裸裸出现`string str = nullptr`这样的语句。另外，在模版中这样的用法也更加常见：

```cpp
template<typename T>
void fun(const T& val)
{
    auto init = T(0);
    init += ...;
}
```

当然这里实际上应该用`T{}`而不是`T(0)`，但是确实有这么写的）

P2166用最简单粗暴的方式部分解决了这个问题：直接禁掉了`string`和`string_view`从`nullptr`构造的构造函数。具体来说，`basic_string`和`basic_string_view`两个模版类都会增加一个构造函数：

```cpp
basic_string(nullptr_t) = delete;
```

这样，一个直接的`string str = nullptr`就会调用这个构造函数，从而得到一个编译期错误。注意`string str = 0`也能防住（`int`到`const char*`/`nullptr_t`的转换是二义性的），但是这仍然是一个部分解决方案——

```cpp
const char* ptr = nullptr;
std::string str = ptr;

// 更现实一点，有可能是下面这种情况
const char* getString(); // 可能返回NULL
std::string str = getString(); // OOPS
```

这就没法从编译期防范了。好在大部分标准库实现构造函数里都有个`param != NULL`的断言，在调试模式下还是能抓住这种bug的。

### `fstream` Exclusive Mode：太迟了！

`fstream`的独占模式 / Support exclusive mode for `fstream`s

cppreference - [P2467R1](https://link.zhihu.com/?target=https%3A//wg21.link/P2467R1) - [[tab:ios.openmode]](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/tab%3Aios.openmode) - 2022.07

支持：GCC 12, Clang not yet, MSVC not yet

测试：`__cpp_lib_ios_noreplace >= 202207L`

这是一个有些匪夷所思的长达25年的疏忽。

`fopen`作为C标准库中打开文件的标准函数，用法想必大家都很熟悉：

```cpp
FILE* fp = fopen("xxx.txt", "w");
```

注意这里的第二参数，即打开文件的模式。模式有三种基础的：`r`读取，`w`写入（到开头），`a`附加（写入到结尾）。除此之外，我们还可以在这三种模式后面加`+`表示同时读写，或者加`b`表示是个二进制文件（比如`w+b`之类的模式也是合法的）。

不过，`w`模式有一个问题：它在文件存在的时候会打开已有文件，不存在的时候会创建一个新文件用来写入，这两种方式并没有安全的办法区分：

```cpp
FILE* fp = fopen("xxx.txt", "r");
if (!fp)
{
    // file does not exist
    fp = fopen("xxx.txt", "w");
    // write
}
else
{
    // file exist
    fclose(fp); // 避免覆盖已有文件
}
```

这样子的判断是不安全的，因为在多线程环境下两次`fopen`之间有可能这个文件突然被创建起来了。

POSIX标准函数`open(2)`为这个竞争问题提供了一个解决方案：它的第二参数（也是文件打开模式）除了常见的`O_RDONLY`之类的以外，有一个`O_EXCL`选项。提供这个（和`O_CREAT`一起）作为打开模式代表这个文件会被以独占方式创建（exclusive create）：在文件已存在的情况下直接返回`EEXIST`错误，而不是继续打开写入。遵循这一思路，glibc实现了`fopen()`的扩展，使得除了`+`和`b`以外，每一个合法的打开模式后面可以加上`x`来代表独占模式（比如`wx`，`r+bx`），这时如果文件已经存在就会报错（返回空指针）而不是打开它写入。（底层实现正是给`open(2)`传递`O_EXCL`）。这样，我们就可以直接

```cpp
FILE* fp = fopen("xxx.txt", "wx");
if (fp)
{
    // 一定是新创建的文件
    // write ...
}
```

由于这一附加模式在避免竞争上很有用，WG14接受了提案[N1339](https://link.zhihu.com/?target=https%3A//www.open-std.org/jtc1/sc22/wg14/www/docs/n1339.pdf)，将`x`模式加入了C11标准的`fopen()`函数中。由于C++17将基于的C标准库版本从C99更新到了C11，C++17也自动获得了这一新模式。

然而，说到底，`fopen()`仍然是一个C库函数，并不是C++打开文件的标准方法。标准方法自然是IOStreams库的文件流——

```cpp
std::fstream in("xxx.txt", std::ios::binary | std::ios::in);
```

这里第二参数是一个枚举`std::ios_base::openmode`，参数包括对应`fopen()`每一个打开模式的参数，比如`w`对应`ios::out`，`b`对应`ios::binary`等等，多个模式就是直接或起来。然而，这个枚举的内容自从C++98到C++20已经25年没变过了…

最讽刺的一点是，在1994年IOStreams库刚刚诞生时，`ios_base::openmode`这个枚举实际上是有`noreplace`这个值的，正好就是表示独占模式（即`fopen()`的`x`），以至于MSVC STL至今还留着一个`_Noreplace`的值。但是后来C++98标准化的过程中，由于当时的C90标准库没有`x`，这个值从枚举中被去掉了，这一去就是25年没再变过，即使C11添加了`x`，C++这边也已经10年没动静了。

最终P2467还是赶紧为C++23解决了这个疏忽，现在可以指定`noreplace`了：

```cpp
std::fstream in("xxx.txt",
    std::ios::binary | std::ios::in | std::ios::noreplace);
// 等价于fopen()的wbx
```

就有些尴尬，改的也太慢了…不过加上了就好，只能算是亡羊补牢吧。

### `string::substr() &&`：右值优化

`string::substr()`的右值优化 / `std::string::substr() &&`

cppreference - [P2438R2](https://link.zhihu.com/?target=https%3A//wg21.link/P2438R2) - [[string.substr]](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/string.substr) - 2022.07

支持：GCC not yet, Clang not yet, MSVC 19.34

测试：无

```cpp
void sink(const std::string& str);

void func(const std::string& str)
{
    std::println("{}", str);
    sink(str.substr(0, 3));
}
```

这样的函数再常见不过了吧——传入的字符串先log一下，然后将一个子串拿去处理一些东西。`string::substr`也因此成为了`std::string`最常用的成员函数之一。

Quiz：众所周知，C++17 `std::string_view`的引入目的是作为替代`const std::string&`的参数类型。如果我们把`sink()`和`func()`的参数类型都换成`string_view`，会有多少个地方获得性能提升？

首先，`func("Hello")`不会再创建临时`std::string`对象，而`sink`的调用也不会移动一次，所以`func("Hello")`原来是2构造+1移动，现在只剩1构造了，对吧……？

不对！换成`string_view`之后，连1次构造也没有了，`func("Hello")`完全不会有任何临时`std::string`对象出现。这是因为`string_view::substr`和`string::substr`的不同行为：后者会构造一个新的`std::string`对象来存放子串（从而其中的字符会被拷贝到新串），前者返回`string_view`，所以只需要返回一个指向子串的指针就行。这在提高了性能（不再拷贝字符）的同时，也是`string_view`不是`const string&`参数的完美替代品的一个重要原因：

```cpp
std::string str = "Hello";
auto sub1 = str.substr(0, 3);
str[0] = 'A'
// sub1[0] == 'H'

std::string str2 = "Hello";
std::string_view sv = str2;
auto sub2 = sv.substr(0, 3);
str2[0] = 'A';
// sub2[0] == 'A'
```

不过，在实际运用中，依赖于`substr`的额外对象这一特性的代码其实很少。更常见的情况往往这个额外对象只会造成性能负担，比如说：

```cpp
std::string getName();

bool isValid()
{
    return getName().substr(1, 3) == "Yes";
}
// 1次构造
```

这里这1次构造完全是没必要的：`getName()`返回的临时`std::string`对象生命期很快就要结束了，`substr()`完全可以接着用其中分配好的内存，调整一下指针和长度就行了。

这正是P2438做出的改动：现在，`basic_string::substr()`在C++23中将会有两个重载：

```cpp
basic_string substr(size_type, size_type) const &;
basic_string substr(size_type, size_type) &&;
```

左值重载和之前一样，创建一个新的`string`对象；新的右值重载因为本身`*this`是一个右值，从而相当于是一个临时对象，从而我们可以不创造新对象而是直接复用其中的内存空间。除此之外，另外一个创造子串的方法——构造函数——也做了类似的改动。因此，现在我们可以：

```cpp
std::string getName();

bool isValid()
{
    return getName().substr(1, 3) == "Yes";
}
// isValid()内部无临时std::string构造，直接复用返回值内存

void sink(const std::string&);
void use()
{
    sink(std::string(getName(), 1, 3));
    // 这个构造函数也不再创造临时对象了
}

void fun()
{
    std::string str = getName();
    std::println("{}", str);
    // ... use str ...

    sink(str.substr(1, 3)); // 这个还是会创造新对象的，是左值
    // ... use str ...

    sink(std::move(str).substr(1, 3)); // 显式转换成右值，从而不会创造临时对象
}
```

要注意，之前`move(str).substr(1, 3)`这种语句是不会改变`str`的内容的，现在它有可能改变了，这是一个breaking change（不过是好事，因为用`std::move`就意味着你不再需要`str`的值了）。另外，在使用自定义分配器的情况下，`std::string s(getName(), 1, 3)`只有返回值和`s`的分配器一样才会做这种优化。

### Move-only类型的Ranges支持：纯数学概念如何在C++中生存？

(1) 三相比较Concept的move-only类型支持 / Move-only types for `equality_comparable_with`, `totally_ordered_with`, and `three_way_comparable_with`

cppreference - [P2404R3](https://link.zhihu.com/?target=https%3A//wg21.link/P2404R3) - [[concept.comparisoncommontype]](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/concept.comparisoncommontype) - 2022.07

支持：GCC not yet, Clang not yet, MSVC not yet

测试：`__cpp_lib_concepts >= 202207L`

(2) Ranges适配器的move-only类型支持 / Relaxing range adaptors to allow for move only types

cppreference - [P2494R2](https://link.zhihu.com/?target=https%3A//wg21.link/P2494R2) - [[range.move.wrap]](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/range.move.wrap) - 2022.07

支持：GCC not yet, Clang not yet, MSVC 19.34

测试：`__cpp_lib_ranges >= 202207L`

假设我们有这么一个类：

```cpp
struct S
{
    S(int);
    S(const S&) = delete;
    S& operator=(const S&) & = delete;
    S(S&&) noexcept = default;
    S& operator=(S&&) & noexcept = default;
    auto operator<=>(const S&) const = default;
    bool operator==(const S&) const = default;
    std::strong_ordering operator<=>(int) const;
    bool operator==(int) const;
};
```

实际上就是一个move-only的整数包装类，比如说某些大整数类因为内部是个`vector`，拷贝起来很耗时，只允许移动到也是个合理的用法。自然，大整数类需要能够从整型隐式构造，然后也能和整型进行比较，比如说`S{1} < 2`当然应该成立。

然后假设我们有了一个`vector<S> s`…然后想要在其中找到第一个1。熟悉STL算法的你一定不会认为这有什么难的：

```cpp
auto it = std::find(s.begin(), s.end(), S{1});
```

或者，既然C++20 Ranges已经得到了比较广泛的支持，现代C++中我们自然可以

```cpp
auto it = ranges::find(s, S{1});
```

到这里都没什么问题。

可是为什么我们要构造一个临时对象呢？一方面这会带来额外的构造性能损耗（大整数类构造往往需要内存分配，之类的），另一方面`S`的API中已经有了和整型的异构`operator==`等价比较函数，而且这样还能省下三个字符：

```cpp
auto it = std::find(s.begin(), s.end(), 1);
```

当然，在现代C++中我们可以写：

```cpp
auto it = ranges::find(s, 1); // 编译错误！
```

wait, what?

仔细研究一下错误信息很容易发现问题出在了默认的等价比较函数，`ranges::equal_to`中。之前异构比较函数对象那里介绍过，这些是C++20 Ranges带来的对C++14 `std::equal_to<void>`这类异构比较对象的更新版本（而后者则是C++98 `std::equal_to<T>`的异构更新版本）。C++20对于这些函数对象的主要更新点就是和Ranges算法一样，引入了Concept限定:

```cpp
struct equal_to
{
    template<typename T, typename U>
        requires std::equality_comparable_with<T, U> // NEW
    constexpr bool operator()(T&& t, U&& u) const
    { return forward<T>(t) == forward<U>(u); }
};
```

这里相比于`std::equal_to<void>`，只有NEW那行的Concept限定是新增的。可是，明明`S::operator=(int)`存在，为什么`std::equal_to<void>`可以，`ranges::equal_to`就会出错呢？

这要追溯到2012年左右Ranges初创阶段的几个约定。在当时，Ranges中的各种概念往往依赖于传统离散数学中的对应概念，比如谓词`predicate`，纯函数`regular_invocable`。后来2017年左右的三相比较提案其实也是基于类似的想法——所谓的强弱等价/比较类型还有偏序关系这种概念本来就是从数学那边借过来的。本来这倒也没什么问题，毕竟数学中一个等价关系大概也就是要求自反射`a == a`，对称性`a == b => b == a`和传递性`a == b && b == c => a == c`，这些也是一个合格的C++ 强等价关系`operator==`应该遵守的三条定律。（浮点数等价关系并不遵守第一条，所以它只能是一个弱比较类型）

然而，离散数学中的等价关系是定义在一个集合`X`上的关系`~`，对所有`x in X`满足三条定律。数学中并没有针对两个集合`A`和`B`的异构等价关系。因此，当年的Ranges初稿采用的手段是将这种异构等价关系提升到一个集合，也就是`A`和`B`的并集。具体到C++中，也就是一个合法的`A`和`B`之间的异构等价关系必须是一个合法的在`A`并`B`上定义的等价关系。当然这里的`A`并`B`只有两个选择，`std::common_type_t<A, B>`或者`std::common_reference_t<A, B>`，由于我们需要十分注意值类型的问题（i.e. 要和万能引用&右值引用打交道），实际上我们只能选择后者。因此，现在的等价比较Concept实际上的定义是：

```cpp
template<typename T>
concept equality_comparable = /* t == t, t != t合法而且返回值可以条件转换为bool */;
template<typename T, typename U>
concept equality_comparable_with =
    equality_comparable<T> && equality_comparable<U> &&
    common_reference_with<remove_reference_t<T>, remove_reference_t<U>> &&
    equality_comparable<common_reference_t<
        const remove_reference_t<T>&,
        const remove_reference_t<U>&
    > && /* t == u, t != u, u == t, u != t合法而且返回值可以条件转换为bool */
```

也就是说，两个类型`T`和`U`之间的异构等价关系同时要求`T`本身，`U`本身，以及他们的常量引用的`common_reference_t`这三个类型都能自己和自己等价比较。这里的重点当然是第三个要求，也就是一方面`common_reference_t`要存在，另一方面它要有一个（同构）等价关系。

回到`S`的例子上，这里我们在问`S`和`int`是不是有异构等价关系。前两条要求自然没问题，那么`const S&`和`const int&`的`common_reference_t`是什么呢？因为`const int&`可以转换成`S`，而反向不行，自然他们的“共同引用类型”就是`S`。但是这就引出了真正的错误原因：一个“共同引用类型”`CR = common_reference_t<T, U>`要合法，那么`T`和`U`都得能转换成`CR`才行。看起来是废话？那么`const S&`能转换成`S`嘛？

当然不行！`S`是move-only类型，这个转换相当于做一个拷贝，当然不成立了（看看拷贝构造函数的签名）。当然，这其实是纯数学概念没有预料到的一个C++独有问题，数学中`A`当然就是`A`的子集，但是因为引用的存在C++中我们不能简单认为某种`S`的引用一定能转换成自身。

P2404重点解决的就是这个问题。这篇提案将Ranges的这个疏忽（不必要的额外copyable要求）解决了。现在，只要`T`或者`const T&`之一能够转换成`CR`即可（以前是必须要求`const T&`能够转换成`CR`），从而让上面的`ranges::find`调用合法了。注意，这个变动（对所有的三相比较Concept，`three_way_comparable_with`，`equality_comparable_with`和`totally_ordered_with`都改了）的代价当然就是这些Concept不再直接使用`common_reference_with`了，所以依赖这个包含关系的代码会被break掉（希望不会真有人写这种代码吧）。

P2494则是C++23周期中一个经久不衰，争论极大的问题——“到底什么样的类型能被称作Ranges视图？”——的最新回答（当然，远远不是最终答案）。众所周知，概念上Ranges视图（也就是`ranges::view<V>`这个Concept）是对一个Ranges的轻量视图，内部相当于存储一个指针，就像`span`/`string_view`那样；从而它们往往拷贝起来很轻量，同时生命期和底层Ranges绑定。但是，Concept要求我们在语法层面上能够将Ranges视图从其他Ranges中区分出来。

在Ranges TS最初引入视图这一概念的时候（当时视图叫Ranges，现在的Ranges叫Iterable，乱得很），视图被认为是具有准常规值语义的类型（C++20 `semiregular`概念），也就是可以拷贝构造，拷贝赋值，以及可以默认构造的类型。这也是C++中最常用也是最容易使用的类型，什么操作都可以进行。Ranges的最初设计中也指出了这些视图只不过是对底层Ranges的引用，因此拷贝它们会得到完全独立的另外一个视图，而且这个拷贝操作应该是常量时间的。这一概念在最近的三年中收到了大幅度的改动。

先是在C++20周期中，提案[P1456R1](https://link.zhihu.com/?target=https%3A//wg21.link/P1456R1)去掉了视图的拷贝要求；现在Ranges视图只需要可以移动（构造/赋值）就够了，不用支持拷贝。这一放松的重要目的就是支持像`views::single`这样的视图不再要求它的底层类型支持拷贝——毕竟move-only类型在C++中早已大行其道，而`single_view<T>`需要在视图中存储一个类型`T`的成员，自然也就要求`T`能够拷贝。除了这一目的之外，当时已经加入C++20的Coroutines也是一个重要的放松原因，因为`generator<T>`自然必须是一个move-only类型（Coroutine Handle无法拷贝），而我们很希望生成器是一个视图。

接下来，C++23周期为C++20做的DR中，提案[P2325R3](https://link.zhihu.com/?target=https%3A//wg21.link/P2325R3)又一次去掉了Ranges视图的默认构造要求。这一要求是原先要求值语义的遗留产品，而且导致不少视图必须支持一种“部分构造”状态，在默认构造函数执行之后还是需要赋值之类的来恢复正常的全构造状态。另外，这个要求也导致`span<T, N>`和`generator<T>`无法成为视图（毕竟对于不能默认构造的`T`，它们没办法提供默认构造函数）。

又过了几个月，又一个C++23周期的C++20 DR，提案[P2415R2](https://link.zhihu.com/?target=https%3A//wg21.link/P2415R2)终于对原始设计中仅剩的第三个要求——拷贝/移动/析构操作必须是常量时间——下手了：析构函数被发现并不需要是常量时间的，因为很多时候视图内部需要存储具体容器的成员，毕竟如果你不存储，Ranges视图的起始永远还是一个实体Range，这样你不仅需要担心悬挂引用问题而且效率还没提高（原来的实体Range还是需要被析构的）。这一条要求最终被放宽成了被移动过的move-from对象的析构是常量时间即可。

因此，在C++23修改过后，最终一个Ranges视图的语义要求是：

- 常量时间的移动构造/赋值
- move-from对象拥有常量时间的析构
- 要么不支持拷贝，要么拥有常量时间的拷贝构造/赋值

当然，常量时间没法用语法要求来保证，因此我们有`ranges::enable_view`这种手动开启视图支持的方法。在这个宽松定义下，实际上`std::vector<T>`已经很接近一个视图了——只要把拷贝操作禁止掉就是一个视图了（这实际上正是`ranges::owning_view<R>`所做的事情）

不过，不幸的是，P1456和P2325/P2415之间并没有做到很好的互动——上面提过，P1456放松的一个重要目的就是像`views::single`这样的视图不用再要求元素类型支持拷贝，但是直到2022年初，C++23标准草案中这些视图还有着这个要求，P2494最终修复了这个互动问题。现在，存储元素的那些视图（C++23标准库中是`single`，`repeat`和`zip_tranform`/`adjacent_transform`的函数对象）现在可以存储move-only类型了，也就是`views::single(make_unique<int>(2))`这种东西现在合法了。

（当然，上面那一大堆放松很多都是给生成器铺路，C++23也实现了这个愿望，`std::generator<T>`确实满足一个输入Ranges视图的要求）
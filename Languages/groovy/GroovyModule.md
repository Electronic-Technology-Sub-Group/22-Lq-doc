# Module

## Json

groovy.json 包中包含了对 Json 的序列化/反序列化类

### JsonSupplier

JsonSupplier 用于解析 Json 文本

| Json    | Groovy             |
| ------- | ------------------ |
| string  | String             |
| number  | BigDecimal/Integer |
| object  | LinkedHashMap      |
| array   | ArrayList          |
| boolean | Boolean            |
| null    | null               |
| date    | java.util.Date     |

解析器类型：通过创建时设置 type 属性设定，或 setType 方法

```groovy
new JsonSupplier(type: JsonParserType.INDEX_OVERLAY)
```



- JsonParserCharArray

  JsonParserType#CHAR_BUFFER，默认

  复制字符数组

- JsonFastParser

  JsonParserType#INDEX_OVERLAY

  最快的解析器，适用于 2MB 以下字符串

  解析时尽量不创建新对象，而是使用指向原始字符的指针，已解析内容会存于缓冲区中

  推迟创建解析对象

- JsonParserLax

  JsonParserType#LAX

  类似 JsonParserCharArray，不完全依赖于 ECMA-404，允许注解，允许无引号字符串

- JsonParserUsingCharacterSource

  JsonParserType#CHARACTER_SOURCE

  用于对 2MB 以上大文件的解析

### JsonOutput

将 Groovy 对象转换为 Json 字符串，支持Map，List，POGO

#### 格式化输出

使用 prettyPrint 方法进行格式化输出

#### Builder

使用 JsonBuilder 或 StreamingJsonBuilder 用过 DSL 自定义输出

## 数据库

Groovy 提供 groovy.sql 模块，作为 Java JDBC 的抽象

支持 HSQLDB，Oracle，SQL Server，MySQL 等

### 连接

连接需要 URL，用户名，密码，驱动名，使用 Sql.newInstance  工厂创建

```groovy
import groovy.sql.Sql

def url = 'jdbc:hsqldb:mem:yourDB'
def user = 'sa'
def password = ''
def driver = 'org.hsqldb.jdbcDriver'
def sql = Sql.newInstance(url, user, password, driver)
```

使用 close 关闭

```groovy
sql.close()
```

若需要自动管理，可使用 withInstance

```groovy
Sql.withInstance(url, user, password, driver) { sql ->
  // use 'sql' instance ...
}
```

#### 数据源

可使用 DataSource 或 Connection 对象创建 Sql，而不是 newInstance

```groovy
import groovy.sql.Sql
import org.hsqldb.jdbc.JDBCDataSource

def dataSource = new JDBCDataSource(
    database: 'jdbc:hsqldb:mem:yourDB', user: 'sa', password: '')
def sql = new Sql(dataSource)

// use then close 'sql' instance ...
```



#### @Grab

可使用 @Grab 注入数据库驱动

```groovy
@Grab('org.hsqldb:hsqldb:2.3.3')
@GrabConfig(systemClassLoader=true)
// create, use, and then close sql instance ...
```



### 执行 SQL 语句

可使用 execute 执行 SQL 语句

```groovy
// ... create 'sql' instance
sql.execute '''
  CREATE TABLE Author (
    id          INTEGER GENERATED BY DEFAULT AS IDENTITY,
    firstname   VARCHAR(64),
    lastname    VARCHAR(64)
  );
'''
// close 'sql' instance ...
```

#### 事务

使用 withTransaction 执行事务

```groovy
assert sql.firstRow('SELECT COUNT(*) as num FROM Author').num == 0
sql.withTransaction {
  sql.execute "INSERT INTO Author (firstname, lastname) VALUES ('Dierk', 'Koenig')"
  sql.execute "INSERT INTO Author (firstname, lastname) VALUES ('Jon', 'Skeet')"
}
assert sql.firstRow('SELECT COUNT(*) as num FROM Author').num == 2
```



```groovy
def maxFirstnameLength
def metaClosure = { meta -> maxFirstnameLength = meta.getPrecision(1) }
def rowClosure = {}
def rowCountBefore = sql.firstRow('SELECT COUNT(*) as num FROM Author').num
try {
  sql.withTransaction {
    sql.execute "INSERT INTO Author (firstname) VALUES ('Dierk')"
    sql.eachRow "SELECT firstname FROM Author WHERE firstname = 'Dierk'", metaClosure, rowClosure
    sql.execute "INSERT INTO Author (firstname) VALUES (?)", 'X' * (maxFirstnameLength + 1)
  }
} catch(ignore) { println ignore.message }
def rowCountAfter = sql.firstRow('SELECT COUNT(*) as num FROM Author').num
assert rowCountBefore == rowCountAfter
```



#### 批量执行

```groovy
sql.withBatch(3) { stmt ->
  stmt.addBatch "INSERT INTO Author (firstname, lastname) VALUES ('Dierk', 'Koenig')"
  stmt.addBatch "INSERT INTO Author (firstname, lastname) VALUES ('Paul', 'King')"
  stmt.addBatch "INSERT INTO Author (firstname, lastname) VALUES ('Guillaume', 'Laforge')"
  stmt.addBatch "INSERT INTO Author (firstname, lastname) VALUES ('Hamlet', 'D''Arcy')"
  stmt.addBatch "INSERT INTO Author (firstname, lastname) VALUES ('Cedric', 'Champeau')"
  stmt.addBatch "INSERT INTO Author (firstname, lastname) VALUES ('Erik', 'Pragt')"
  stmt.addBatch "INSERT INTO Author (firstname, lastname) VALUES ('Jon', 'Skeet')"
}
```



#### 分页

```groovy
def qry = 'SELECT * FROM Author'
assert sql.rows(qry, 1, 3)*.firstname == ['Dierk', 'Paul', 'Guillaume']
assert sql.rows(qry, 4, 3)*.firstname == ['Hamlet', 'Cedric', 'Erik']
assert sql.rows(qry, 7, 3)*.firstname == ['Jon']
```



#### 元数据

https://groovy-lang.org/databases.html#_fetching_metadata

```groovy
sql.eachRow("SELECT * FROM Author WHERE firstname = 'Dierk'") { row ->
  def md = row.getMetaData()
  assert md.getTableName(1) == 'AUTHOR'
  assert (1..md.columnCount).collect{ md.getColumnName(it) } == ['ID', 'FIRSTNAME', 'LASTNAME']
  assert (1..md.columnCount).collect{ md.getColumnTypeName(it) } == ['INTEGER', 'VARCHAR', 'VARCHAR']
}
```

```groovy
def md = sql.connection.metaData
assert md.driverName == 'HSQL Database Engine Driver'
assert md.databaseProductVersion == '2.3.3'
assert ['JDBCMajorVersion', 'JDBCMinorVersion'].collect{ md[it] } == [4, 0]
assert md.stringFunctions.tokenize(',').contains('CONCAT')
def rs = md.getTables(null, null, 'AUTH%', null)
assert rs.next()
assert rs.getString('TABLE_NAME') == 'AUTHOR'
```



#### 命名

```groovy
sql.execute "INSERT INTO Author (firstname, lastname) VALUES (:first, :last)", first: 'Dierk', last: 'Koenig'
sql.execute "INSERT INTO Author (firstname, lastname) VALUES (?.first, ?.last)", first: 'Jon', last: 'Skeet'

class Rockstar { String first, last }
def pogo = new Rockstar(first: 'Paul', last: 'McCartney')
def map = [lion: 'King']
sql.execute "INSERT INTO Author (firstname, lastname) VALUES (?1.first, ?2.lion)", pogo, map
```



#### 程序

https://groovy-lang.org/databases.html#_stored_procedures

### CRUD 操作

https://groovy-lang.org/databases.html#_basic_crud_operations

## XML

### 解析

基于 SAX 的解析

#### XmlParser

```groovy
def text = '''
    <list>
        <technology>
            <name>Groovy</name>
        </technology>
    </list>
'''

def list = new XmlParser().parseText(text)

assert list instanceof groovy.util.Node
assert list.technology.name.text() == 'Groovy'
```

- 解析返回 Node 对象
- 多用于同时读取和编辑

#### XmlSlurper

```groovy
def text = '''
    <list>
        <technology>
            <name>Groovy</name>
        </technology>
    </list>
'''

def list = new XmlSlurper().parseText(text)

assert list instanceof groovy.util.slurpersupport.GPathResult
assert list.technology.name == 'Groovy'
```

- 惰性求值
- 解析返回 GPathResult 对象
- 多用于只读，更新 xml 需要再次重建树，且不会在内存中创建完整树

#### DOMC

可使用 groovy.xml.dom.DOMCategory 解析 XML，可获取整个文档 DOM

```groovy
static def CAR_RECORDS = '''
<records>
  <car name='HSV Maloo' make='Holden' year='2006'>
    <country>Australia</country>
    <record type='speed'>Production Pickup Truck with speed of 271kph</record>
  </car>
  <car name='P50' make='Peel' year='1962'>
    <country>Isle of Man</country>
    <record type='size'>Smallest Street-Legal Car at 99cm wide and 59 kg in weight</record>
  </car>
  <car name='Royale' make='Bugatti' year='1931'>
    <country>France</country>
    <record type='price'>Most Valuable Car at $15 million</record>
  </car>
</records>
'''

def reader = new StringReader(CAR_RECORDS)
def doc = DOMBuilder.parse(reader)
def records = doc.documentElement
use(DOMCategory) {
    assert records.car.size() == 3
}
```



### GPath

在 Groovy 中查询 XML 的常见方式，类似 XPath，主要用于处理嵌套 POJO 或 XML

- a.b.c
  - xml: \<a\>\<b\>\<c\> ... \</c\>\<\b\>\<\a\>
  - POJO: a.getB().getC()
- 获取 a 的 herf 属性
  - a["@herf"]
  - a.'@herf'
  - a.@herf

#### 遍历树

```groovy
static final String books = '''
    <response version-api="2.0">
        <value>
            <books>
                <book available="20" id="1">
                    <title>Don Quixote</title>
                    <author id="1">Miguel de Cervantes</author>
                </book>
                <book available="14" id="2">
                    <title>Catcher in the Rye</title>
                   <author id="2">JD Salinger</author>
               </book>
               <book available="13" id="3">
                   <title>Alice in Wonderland</title>
                   <author id="3">Lewis Carroll</author>
               </book>
               <book available="5" id="4">
                   <title>Don Quixote</title>
                   <author id="4">Miguel de Cervantes</author>
               </book>
           </books>
       </value>
    </response>
'''

def response = new XmlSlurper().parseText(books)
def authorResult = response.value.books.book[0].author

assert authorResult.text() == 'Miguel de Cervantes'
assert response.value.books.book[0].@id == '1'
assert response.value.books.book[0].@id.toInteger() == 1
assert response.value.books.book[0].@id ==  response.value.books.book[0]['@id']
```



#### 灵活导航

- *：children

  ```groovy
  def response = new XmlSlurper().parseText(books)
  
  // .'*' could be replaced by .children()
  def catcherInTheRye = response.value.books.'*'.find { node ->
      // node.@id == 2 could be expressed as node['@id'] == 2
      node.name() == 'book' && node.@id == '2'
  }
  
  assert catcherInTheRye.title.text() == 'Catcher in the Rye'
  ```

  

- **：depthFirst

  ```groovy
  def response = new XmlSlurper().parseText(books)
  
  // .'**' could be replaced by .depthFirst()
  def bookId = response.'**'.find { book ->
      book.author.text() == 'Lewis Carroll'
  }.@id
  
  assert bookId == 3
  ```

  

### 创建

https://groovy-lang.org/processing-xml.html

#### MarkupBuilder

```groovy
def writer = new StringWriter()
def xml = new MarkupBuilder(writer)

xml.records() {
    car(name: 'HSV Maloo', make: 'Holden', year: 2006) {
        country('Australia')
        record(type: 'speed', 'Production Pickup Truck with speed of 271kph')
    }
    car(name: 'Royale', make: 'Bugatti', year: 1931) {
        country('France')
        record(type: 'price', 'Most Valuable Car at $15 million')
    }
}

def records = new XmlSlurper().parseText(writer.toString())

assert records.car.first().name.text() == 'HSV Maloo'
assert records.car.last().name.text() == 'Royale'
```

```groovy
def xmlWriter = new StringWriter()
def xmlMarkup = new MarkupBuilder(xmlWriter)

xmlMarkup.movie(id: 2) { 
    name("the godfather")
}

def movie = new XmlSlurper().parseText(xmlWriter.toString())

assert movie.@id == 2
assert movie.name.text() == 'the godfather'
```

```groovy
def xmlWriter = new StringWriter()
def xmlMarkup = new MarkupBuilder(xmlWriter)

xmlMarkup
        .'x:movies'('xmlns:x': 'http://www.groovy-lang.org') { 
    'x:movie'(id: 1, 'the godfather')
    'x:movie'(id: 2, 'ronin')
}

def movies =
        new XmlSlurper() 
                .parseText(xmlWriter.toString())
                .declareNamespace(x: 'http://www.groovy-lang.org')

assert movies.'x:movie'.last().@id == 2
assert movies.'x:movie'.last().text() == 'ronin'
```

...

#### StreamingMarkupBuilder

```groovy
def xml = new StreamingMarkupBuilder().bind { 
    records {
        car(name: 'HSV Maloo', make: 'Holden', year: 2006) { 
            country('Australia')
            record(type: 'speed', 'Production Pickup Truck with speed of 271kph')
        }
        car(name: 'P50', make: 'Peel', year: 1962) {
            country('Isle of Man')
            record(type: 'size', 'Smallest Street-Legal Car at 99cm wide and 59 kg in weight')
        }
        car(name: 'Royale', make: 'Bugatti', year: 1931) {
            country('France')
            record(type: 'price', 'Most Valuable Car at $15 million')
        }
    }
}
```



#### MarkupBuilderHelper

- commit
- 处理指令
- XML 声明
- 输出数据、转义 XML 实体

#### DOMToGroovy

```groovy
def songs = """
    <songs>
      <song>
        <title>Here I go</title>
        <band>Whitesnake</band>
      </song>
    </songs>
"""

def builder =
        javax.xml.parsers.DocumentBuilderFactory.newInstance().newDocumentBuilder()

def inputStream = new ByteArrayInputStream(songs.bytes)
def document = builder.parse(inputStream)
def output = new StringWriter()
def converter = new DomToGroovy(new PrintWriter(output)) 

converter.print(document) 

String xmlRecovered =
        new GroovyShell()
                .evaluate("""
           def writer = new StringWriter()
           def builder = new groovy.xml.MarkupBuilder(writer)
           builder.${output}

           return writer.toString()
        """) 

assert new XmlSlurper().parseText(xmlRecovered).song.title.text() == 'Here I go' 
```



### 处理

```groovy
def parser = new XmlParser()
def response = parser.parseText(xml)
def numberOfResults = parser.createNode(
        response,
        new QName("numberOfResults"),
        [:]
)

numberOfResults.value = "1"
assert response.numberOfResults.text() == "1"
```

```groovy
def parser = new XmlParser()
def response = parser.parseText(xml)

response.appendNode(
        new QName("numberOfResults"),
        [:],
        "1"
)

response.numberOfResults.text() == "1"
```



#### 添加/修改

```groovy
def response = new XmlParser().parseText(xml)

/* Use the same syntax as groovy.xml.MarkupBuilder */
response.value.books.book[0].replaceNode { 
    book(id: "3") {
        title("To Kill a Mockingbird")
        author(id: "3", "Harper Lee")
    }
}

def newNode = response.value.books.book[0]

assert newNode.name() == "book"
assert newNode.@id == "3"
assert newNode.title.text() == "To Kill a Mockingbird"
assert newNode.author.text() == "Harper Lee"
assert newNode.author.@id.first() == "3"
```

```groovy
def response = new XmlParser().parseText(xml)

/* Use the same syntax as groovy.xml.MarkupBuilder */
response.value.books.book[0].replaceNode { 
    book(id: "3") {
        title("To Kill a Mockingbird")
        author(id: "3", "Harper Lee")
    }
}

def newNode = response.value.books.book[0]

assert newNode.name() == "book"
assert newNode.@id == "3"
assert newNode.title.text() == "To Kill a Mockingbird"
assert newNode.author.text() == "Harper Lee"
assert newNode.author.@id.first() == "3"
```

```groovy
def parser = new XmlParser()
def response = parser.parseText(xml)

response.@numberOfResults = "1"

assert response.@numberOfResults == "1"

def response = new XmlSlurper().parseText(books)
response.@numberOfResults = "2"

assert response.@numberOfResults == "2"
```



#### 输出

```groovy
def response = new XmlParser().parseText(xml)
def nodeToSerialize = response.'**'.find { it.name() == 'author' }
def nodeAsText = XmlUtil.serialize(nodeToSerialize)

assert nodeAsText ==
        XmlUtil.serialize('<?xml version="1.0" encoding="UTF-8"?><author id="1">Miguel de Cervantes</author>')
```



## Ant Task

https://groovy-lang.org/scripting-ant.html

## 模板是引擎

用于生成文本

### 模板框架

继承自 TemplateEngine

### SimpleTemplateEngine

允许使用类似 JSP Scriptlet，脚本和 EL 表达式生成文本

```groovy
def text = 'Dear "$firstname $lastname",\nSo nice to meet you in <% print city %>.\nSee you in ${month},\n${signed}'
def binding = ["firstname":"Sam", "lastname":"Pullara", "city":"San Francisco", "month":"December", "signed":"Groovy-Dev"]
def template = new SimpleTemplateEngine().createTemplate(text).make(binding)
def result = 'Dear "Sam Pullara",\nSo nice to meet you in San Francisco.\nSee you in December,\nGroovy-Dev'
assert result == template.toString()
```



### StreamingTemplateEngine

类似 SimpleTemplateEngine，可写闭包，可处理大于 64K 的字符串

使用 <%%> 和 <%=%> 的 JSP 样式或 GString 样式处理表达式

```groovy
def text = '''\
Dear <% out.print firstname %> ${lastname},

We <% if (accepted) out.print 'are pleased' else out.print 'regret' %> \
to inform you that your paper entitled
'$title' was ${ accepted ? 'accepted' : 'rejected' }.

The conference committee.'''

def binding = [
        firstname : "Grace",
        lastname  : "Hopper",
        accepted  : true,
        title     : 'Groovy for COBOL programmers'
]

String response = new StreamingTemplateEngine().createTemplate(text).make(binding)

assert response == '''\
Dear Grace Hopper,

We are pleased to inform you that your paper entitled
'Groovy for COBOL programmers' was accepted.

The conference committee.'''
```

 

### GStringTemplateEngine

文件：test.template

```
Dear "$firstname $lastname",
So nice to meet you in <% out << (city == "New York" ? "\\"The Big Apple\\"" : city) %>.
See you in ${month},
${signed}
```

代码

```groovy
def f = new File('test.template')
def template = new GStringTemplateEngine().createTemplate(f).make(binding)
println template.toString()
```

输出

```
Dear "Sam Pullara",
So nice to meet you in "The Big Apple".
See you in December,
Groovy-Dev
```



### XmlTemplateEngine

输出 XML，使用 gsp 代表代码

```groovy
def binding = [firstname: 'Jochen', lastname: 'Theodorou', nickname: 'blackdrag', salutation: 'Dear']
def engine = new groovy.text.XmlTemplateEngine()
def text = '''\
    <document xmlns:gsp='http://groovy.codehaus.org/2005/gsp' xmlns:foo='baz' type='letter'>
        <gsp:scriptlet>def greeting = "${salutation}est"</gsp:scriptlet>
        <gsp:expression>greeting</gsp:expression>
        <foo:to>$firstname "$nickname" $lastname</foo:to>
        How are you today?
    </document>
'''
def template = engine.createTemplate(text).make(binding)
println template.toString()
```

```xml
<document type='letter'>
  Dearest
  <foo:to xmlns:foo='baz'>
    Jochen &quot;blackdrag&quot; Theodorou
  </foo:to>
  How are you today?
</document>
```



### MarkupTemplateEngine

依赖于 DSL 生成类 XML 格式

https://groovy-lang.org/templating.html#_the_markuptemplateengine



### 其他

FreeMaker，Velocity，StringTemplate 等

## Swing

用于 Swing UI 创建

https://groovy-lang.org/swing.html

## Servlet

https://groovy-lang.org/servlet.html

## JMX

https://groovy-lang.org/jmx.html
---
参考资料: https://zhuanlan.zhihu.com/p/562383157
---
## C++23 - 总结

**注意: 所有以** _斜体_ （副标题前面加*号） **标注的信息都是没有最终确定进入标准的信息，这部分很可能会改动。**

缺失的cppreference链接会不定期更新。写的可能不是很好，见谅。也欢迎指出错误。

知乎不让发10万字以上的文章，所以分了上下篇。这是上篇，下篇见：

[Mick235711：C++23特性总结 - 下246 赞同 · 24 评论文章![](https://pic4.zhimg.com/v2-cdf72705f8807e96d693b6a6976f0207_ipico.jpg)](https://zhuanlan.zhihu.com/p/562383556)

C++23 是一个中等规模的发行版。众所周知，C++20 是一个比 C++11 都更为庞大的大更新，以四大金刚（`Concepts`，`Modules`，`Ranges`，`Coroutines`）和其他一大堆小更新为绝对主力的大规模新特性让很多人都觉得很惊喜——然而作为大更新的代价，下一个发行版 C++23 注定会主要给 C++20 修 bug，从而会是一个比较小的发行版。另一个因素是 2020 年初开始一直到现在仍未停息的新冠疫情。由于 C++20 标准在 2020 年 2 月才最终定稿，整个 C++23 周期到目前为止的所有工作都是完全在线上进行的——往年常用的 4～6 月一次的一周集会被改成了每月甚至每周举行的 Zoom 会议，这严重影响了标准委员会 WG21 和各个工作组的工作效率，也是 C++23 最终缺少 T0 级特性的重要原因。令人比较惊喜的是，最终标准委员会（尤其是 LEWG ）克服了重重困难，在为 C++20 作出长达一年半的 bugfix 的同时，为 C++23 带来了令人惊喜的新特性集合，从而使得一个本该与 C++14 看齐的小发行版最终膨胀到了和 C++17 相近甚至部分有所超越的规模——

> C++11: 大  
> C++14: 小  
> C++17: 中等  
> C++20: 大  
> C++23: 中等偏小（语言：小，库：中等偏大）  
> _C++26: 中等/中等偏大_  
> _C++29: 大/中等偏大_

于是，这一节也就是对于 C++23 最终确定的所有特性的总结和详细说明，以此使得读者能够及时了解新特性能够干什么，如何使用。每一个特性都会附上 cppreference 和提案链接，并尽量给出一个合适的短小例子&描述来看这个特性到底带来了什么。另外要注意的是，最开始一年半（直到 2021 年中才逐渐停止）的对于 C++20 做的 bugfix（DR）这里不做介绍（毕竟没啥大东西，最大的可能也就是[Superior String Splitting](https://link.zhihu.com/?target=https%3A//wg21.link/P2210R2)和至少三篇`std::format`改进这种肯定是T3的特性）
### 日程表

这里是一个[早就决定好的](https://link.zhihu.com/?target=https%3A//wg21.link/P1000R4)C++23日程表，可以看看我们现在到哪里了

> 2020-02 (Prague): C++20标准草案（DIS）定稿，进入ISO流程  
> <C++20工作完全结束，C++23工作开始>  
> <新冠爆发>  
> 2020-11: C++23第一次plenary，第一批特性得到批准  
> 2020-12: C++20作为ISO/IEC 14882:2020印发，成为正式ISO标准  
> 2021-10: C++23第四次plenary，最后一个C++20 DR得到批准  
> 2022-02: C++23第五次plenary，Design Freeze：所有可能进入的特性均进入Wording Review；至此，C++23不会再接受新特性。  
> <C++23设计工作组工作结束>  
> 2022-07: C++23第六次plenary，Wording Freeze：所有特性的Wording完成，最后一批新特性得到批准，C++23委员会草案（CD）印发；至此，C++23所有新特性的工作完成，开始NB Comment Resolution阶段。  
> **WE ARE HERE**  
> 2022-11 (Kona): C++23第七次plenary，第一次线下集会  
> 2023-02: C++23第八次plenary，C++23标准草案（DIS）定稿，进入ISO流程。  
> <C++23工作完全结束，C++26工作开始>  
> 2023-12: C++23作为ISO/IEC 14882:2023印发，成为正式ISO标准。
### 特性评分

在 C++23 周期列举新特性的时候，最重要的原则之一就是要分开语言特性和标准库特性——这是因为工作组的日程安排问题。语言工作组 EWG 在线上基本上属于摆烂——大概 2-3 周甚至一个月才 meet 一次，CWG 有时候甚至两个月才 meet 一次，严重降低工作效率。与此相反，库工作组 LEWG 则保持了每周 meet 一次的作息，并且实施了很多积极提高工作效率的方法，比如开启 Mailing List Review 和直通机制让小提案不再占用宝贵的 Telecon 时间，以及使用周末时间连续举办5个小时的 Supertelecon 来强行推进大特性（虽然这推进最后没成功，但是可以看到这一机制将在 C++26 的线上处置中发挥很大的作用）。LWG 虽然没这么积极，但是至少每个月也会 meet 一次，当然现在他们那边提案堆积如山估计也压力很大。另外再加上改变标准库比改变语言本身要容易得多——结果就是，C++23 的标准库新特性远远超过语言特性（实际上这是比较委婉的说法，要我说可以说 C++23 在语言上没啥特性），无论是在广度还是在深度（规模）上都是远远超过。

以下会以一个统一的标准来对每个特性进行打分；我们可以看到语言特性没有 T0/T0.5，T1 也只有一个；标准库中则有 T0.5，也可以看出 C++23 两者新特性规模的差距。

- T0: TS 级特性。极大的改变了日常写代码的方式，往往彻底引入了一种新的代码形式，并对语言/库的设计有着深远的影响。这一级别的特性普遍需要 10 年以上的发展，并往往真的会有一个 TS 进行分支发展。要注意的是 TS 并不都是 T0 级特性（比如 LFTS 的三个版本并没有 T0 级特性，而是许多 T0.5/T1 级特性的集合），而 T0 级特性也并不一定需要 TS（例如未来的Executors）。这些特性的加入往往为标准文本引入了上百页的大改，大部分时候会给标准带来新的一章。例子：`STL`，`Lambda`，C++20 四大金刚。有没有 T0 级特性是中等和大发行版的重要区分标志（不绝对）—— C++14，17 和 23 都没有 T0 级特性，有趣的是后两个都差点有。
- T0.5: 准 TS 级特性。在一个领域中引入了一种新的代码写作方式，往往是用更先进的技术取代了延续多年的传统习惯；另一个标准是较大地扩展了 C++ 标准能够触及的地方，引入了新的能力。这一级别的特性一般需要数年发展，但是往往够不上一个 TS 的程度（LFTS 那种多个 T0.5 一起凑一个 TS 的除外）。这些特性的加入一般会带来 20-50 页的标准更改，但是一般不会单列一章（因为这种特性无法独当一面开创新的领域，只是在现有领域作出更改）。例子：`{unique,shared}_ptr`，`thread`，`chrono`（date&time不算），`pSTL`，`Filesystem`，三相比较，`std::format`。有没有 T0.5 级特性是小和中等发行版的重要区分标志（也不绝对）——C++14 没有 T0.5 级特性。
- T1: 大提案。极大的改进了现有的特性，或者引入了一个很重要的辅助功能；往往不会引入新的能力，只是减少代码量/让使用更加方便。这一级别的特性一般至少需要 2 年左右，5-10 个 Telecon 或者 3-4 场线下会议的发展，带来 5-10 页左右的标准更改。这种特性往往组成了一个发行版最贴近日常使用的部分，也为使用者带来了更多方便。由于周期比较短，每个发行版总会至少有一两个这种特性来撑门面（C++14，C++23 语言部分）。例子：`UDL`，`jthread`，`generic lambda (& init capture)`，`template using-alias`，`static_assert`，`fold expression`，`CTAD`（也可以算 T0.5 了），`sum types` 等等等等。
- T2: 新特性。这一级就是所有剩下的新特性提案。这些提案比较短小精悍，往往也能在一些地方给人眼前一亮的感觉，或者改进一个小的设计失误；然而终究规模比较小，往往不会对其他离得比较远的部分有什么影响。这一级别的特性一般需要 1 年左右，经过 3 个左右的 Telecon 或者 1-2 场线下会议即可设计定型，带来 5 页以下的标准更改。这种特性因为规模很小，每个发行版都会有 10 个以上的 T2 级提案来丰富这个发行版的内容。例子：`make_unique`，各种 `literal`（`binary`，`u8`），各种 `Ranges`，`[[no_unique_address]]` 等等。
- T3: bugfix。这一级就是纯粹的修 bug 提案了，有些提案可以小到只是改个名字，对标准的更改可以 1 页都不到。这一级别的特性一个 Telecon 就可以搞一个甚至好几个，每个 plenary 最主要就是这种东西。例子：太多了，比如 template template parameter 用 typename，uncaught_exceptions 之类的都是。这一部分甚至标准定稿了都可以上 DR 来追加更改（注意绝对不是说 DR 都是 T3，比如 Superior String Splitting 肯定有 T2）

以下的所有特性会直接从重要性/影响从高到低排序，这样最重要影响最大的特性就排在最前面——当然这里的“重要性”是我的个人观点，不喜勿喷。
## C++23盘点 - 图例

让我们开始吧。所有提案的统一格式是

```text
中文简单名称 [/ 提案名称]
cppreference - 提案链接 - 标准（主要段落） - 批准时间
支持：三大编译器支持最低版本
[主要头文件：`<foo>`]
特性测试：`__cpp_something_foo_bar >= 202XYYL`
```

cppreference 有可能暂时没有链接，有了会补上。（注意标准段落的永久性名称 foo.bar 只能到小节，具体的 /N 段落是有可能变化的，所有引用仅针对 C++23 CD）。我建议了解一个新特性的方式是首先看 cppreference，再不懂就去看提案。使用方式是先看编译器支持，如果需要条件支持的话就

```cpp
#if __cpp_something_foo_bar >= 202XYYL
// use new feature here
#endif
```

至于说要关注哪些特性，因为越往上的是个人认为越重要的，我建议每个小节（T1/T2/T3）都挑前几个看看。注意所有的 _斜体_ 内容（标题则为前面加`*`）都是还没进标准，没确定的。

## C++23语言部分盘点

前面说过，EWG 和 CWG 在线上见面的时候比较摆烂，再加上语言特性一般都比库特性难推进的多，所以 C++23 的语言层面实际上没有什么东西。不过，任何一个标准总是有一些小特性的，让我们看看这个新标准带来了什么

T0 和 T0.5 级特性没有。T2 和 T3 很多，只挑了最重要的几个。（知乎不支持三级标题，所以下面都用一级标题了）
## 语言 - T1

### Deducing This：显式`this`参数

显式`this`参数 / Deducing This

[cppreference](https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/language/member_functions%23Explicit_object_parameter) - [P0847R7](https://link.zhihu.com/?target=https%3A//wg21.link/P0847R7) - [[dcl.fct]/6](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/dcl.fct%236) - 2021.10

支持：GCC not yet, Clang not yet, MSVC 19.32 (partial)

测试：`__cpp_explicit_this_parameter >= 202110L`

Deducing This 算是 C++23 语言部分难得的亮点。这一提案正如标题所说的一样，能够让非静态成员函数的`this`参数成为一个显式参数——众所周知，在调用成员函数时，C++的语法是`x.fun(args)`，而`x`（在函数内就是`*this`）往往被认为是一个隐式传给函数的参数。这一参数的`const`/`volatile`限定可以在成员函数参数列表的后面指定，比如说

```cpp
struct X
{
    void fun1() const;
    void fun2(int i) volatile &&;
};
```

`fun1()`的`*this`实际上的类型是`const X&`，`fun2()`则是`volatile X&&`。像Python之类的语言则允许我们将这个隐式以`this`传递的参数写明成第一个参数：

```python
class X:
    def fun(self, arg):
        # ...
        pass
```

现在，C++也允许我们这么干了：第一参数如果放一个`this`在前面，那么默认这个第一参数就是调用对象：

```cpp
struct X
{
    void fun1(this const X& self);
    void fun2(this volatile X&& self, int i);
};
```

这个类和上面那个基本等价（当然，有少量差别，比如`fun1`的无 _ref-qualifier_ 模式和左值引用有点差别，而且这两个函数实际上是静态函数，调用 ABI 并不一样）——调用形式还是 `x.fun1()` 和 `x.fun2(5)`，但是此时 `self` 就会绑定到 `x`（这种函数内部`this`不可访问）。这样最大的好处就是既然`self`是一个参数了，那么我们就可以把各种跟参数有关的用法用上去——最重要的就是模版。

```cpp
struct T
{
          value_type& operator[](std::size_t idx)       { return arr[idx]; }
    const value_type& operator[](std::size_t idx) const { return arr[idx]; }
};
```

这是一个典型的 `operator[]` 实现——非常量函数和常量函数需要写两个重载。现在函数体只有一行还好，一旦函数体比较长这个重复就很烦了。现在我们就可以直接

```cpp
struct T
{
    template<typename Self>
    auto& operator[](this Self&& self, std::size_t idx) { return self.arr[idx]; }
};
```

一个函数解决。

这一特性看上去很小，但是它带来了多项出人意料的改进——比如说，既然这是个参数，没人要求这个参数必须是引用：

```cpp
class string_view
{
    // ...
    const char* data;
    std::size_t size;
public:
    constexpr const char* begin(this string_view self)
    {
        return self.data;
    }
    constexpr const char* end(this string_view self)
    {
        return self.data + self.size;
    }
    // ...
};
```

以前，`this`一定是个指针，所以在自己的成员函数内部`string_view`一定是以引用传递——而我们知道这种 `view type` 一般是以值传递效率最高。现在我们终于可以在成员函数也做值传递了。用来实现Python一样的 `sorted()` 函数（返回一个排好序的拷贝）也是很好的选择。

另外一个带来的进步是 `lambda` —— `lambda` 本质上就是带`operator()`的匿名类，所以我们也可以在 `lambda` 的参数列表写 `explicit this` ——这带来了一个大家一直想要的特性：递归 `lambda`。

```cpp
int main()
{
    auto fact = [](this auto self, int n) {
        if (n <= 1) return 1;
        return n * self(n - 1);
    };
    std::println("{}", fib(5)); // output 120
}
```

优雅，简洁。除此之外，它还带来了包括简化 CRTP 在内的一大堆应用（可以看看写的很好的[原提案](https://link.zhihu.com/?target=https%3A//wg21.link/P0847R7)）——这也是为什么它是个 T1 级特性。

## 语言 - T2

### 多元`operator[]`：多维数组支持

多元`operator[]` / Multidimensional subscript operator

[cppreference](https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/language/operators%23Array_subscript_operator) - [P2128R6](https://link.zhihu.com/?target=https%3A//wg21.link/P2128R6) - [[over.sub]](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/over.sub) - 2021.10

支持：GCC 12, Clang 15, MSVC not yet

测试：`__cpp_multidimensional_subscript >= 202110L`

这算是个老生常谈了——C++的函数调用操作符 `operator()` 在很长一段时间内是唯一能够接受超过两个参数的操作符重载。在过去30年中，下标操作符 `operator[]` 一直只能接受一个参数，这让所有的多维数组类（包括 C 带来的伪"多维数组"，实际上是个数组的数组的数组）都只能使用别扭的 `arr[i][j][k]` 语法（想想，`arr[i]` 是什么？能 copy 吗？是深层 copy 吗？如果这个多维数组不是连续存放的话这个切片怎么办？）或者借用函数调用（或者说 MATLAB ）的语法 `arr(i, j, k)`（这就和一维数组不统一了），以至于曾经的 `span` 还留了个 `operator()` 重载给 `mdspan`...

现在，这一切改变了。在 C++20 `deprecate` 了 `arr[i, j]` 这个下标 + 逗号表达式的语法之后，C++23 比较反常地飞速通过了这一改变语法的提案——现在下标操作符可以接受 0，1，2 或者多个参数了！语法很简单，就是把 `operator()` 的语法照搬过来：

```cpp
struct Matrix
{
    value_type& operator[](int row, int col) {/* ... */}
};
Matrix m;
m[2, 3] = 4;
```

当然，最大的受益者就是多维数组类（比如同样是 C++23 加入的 `mdspan`）。不过其他的类也可以沾光，比如模仿 Mathematica 的函数调用语法 `Plus[1, 2, 3]` 之类的。
### `size_t`字面量：补全缺憾

`size_t`字面量 / Literal Suffix for (signed) `size_t`

[cppreference](https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/language/integer_literal%23The_type_of_the_literal) - [P0330R8](https://link.zhihu.com/?target=https%3A//wg21.link/P0330R8) - [[tab:lex.icon.type]](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/tab%3Alex.icon.type) - 2020.11

支持：GCC 11, Clang 13, MSVC not yet

测试：`__cpp_size_t_suffix >= 202011L`

`std::size_t`是一个很重要的整数类型，几乎所有STL的下标操作符都要求这个作为参数——以及`size()`的返回值也是它。所以一个简单的`for (int i = 0; i < vec.size(); ++i)`可能会报warning——`i < vec.size()`是有符号数对比无符号数。`std::size_t`被指定为一个无符号整数，**通常**实现为`unsigned long long`，所以不少人直接用

```cpp
for (auto i = 0ull, i < vec.size(); ++i)
```

来做循环。然而，标准并不保证这一点，所以这个循环严格意义上还是应该报narrow warning。现在，C++23提供了新的后缀来直接生成`size_t`字面量——`0uz`或者`0zu`就是`size_t`，而`0z`是一个`size_t`的有符号版本（这些后缀都可以用大写，效果一样）。所以我们直接

```cpp
for (auto i = 0uz, i < vec.size(); ++i)
```

就保证ok了。原提案还有一个`0t`给`ptrdiff_t`用，但最后WG21觉得没人用这个类型就没加这个suffix。

### 扩展浮点字面量：支持更多的架构

扩展浮点字面量 / Extended floating-point types and standard names

cppreference - [P1467R9](https://link.zhihu.com/?target=https%3A//wg21.link/P1467R9) - [[basic.extended.fp]](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/basic.extended.fp) - 2022.07

支持：GCC not yet, Clang not yet, MSVC not yet

主要头文件：`<stdfloat>`

测试：`#ifdef __STDCPP_{FLOAT}_T__` where `FLOAT` is in `{FLOAT16, FLOAT32, FLOAT64, FLOAT128, BFLOAT16}`

在很长一段时间内，C 和 C++ 只有三个浮点类型——32 位的 `float`，64 位的 `double`，和通常是 80/128 位的 `long double`。当然，绝大多数人用 `float` 和 `double` 确实也就够了，毕竟精度和范围而言 `4e-324` 到 `1e308` 的 `double` 已经能够满足绝大多数人，而占用空间的优化上来说小于 `float` 的类型也并不是那么吃香。

然而，现在已经是 21 世纪了，在机器学习大发展的年代，16 位浮点数类型的重要性慢慢显示了出来。在现代 CV 和其他机器学习领域中，16 位浮点数常常被用作像素存储和神经网络的中间结果，因为它仍然有着浮点数的长范围优势，这些应用领域也不需要 32 位精度。毕竟，神经网络的通常结构是运算量大，但是并不需要高精度，这种情况下使用空间占用低的 16 位浮点数也是很有用的。因此，像现代的 ARM CPU，NVIDIA GPU 以及多个机器学习框架早已经原生支持了 16 位浮点数。不过，C++ 作为机器学习最常用的语言之一，之前并没有原生对于 16 位浮点数的支持，就显得有些落后了。

当然，和大整数类的情况一样，我们总是可以说这应该是一个库特性，而不是用核心语言去实现。不过，大整数类用库去模拟问题不大，16 位浮点数即使是在内部全用汇编去写，光运算符重载带来的额外负载就会让它的优势消耗殆尽——更不用说即使把所有运算符都重载一遍，和原生类型仍然会有一定差距。当然，往核心语言中加入 16 位浮点数的提案在 C++17 周期就早已出现——[P0192R4](https://link.zhihu.com/?target=https%3A//wg21.link/P0192R4)在当时提出了 `short float` 的概念，和`long double` 相对表示 16 位浮点数。然而，在讨论中，P0192 最后被拒绝的主要原因可以说是增加的类型太少——只有一个 16 位浮点数是不够的。实际上，现代的浮点计算库已经提供了三种 C/C++ 现在没有的浮点类型：（注意，在 C/C++ 遵守的 IEEE 754 标准中，32 位浮点数 FP32 的形式是 1 符号位 + 8 指数位 + 24 小数位，64 位浮点数是1+11+53）

- 16 位浮点数。这种标准的 16 位浮点数（IEEE 754 FP16/`binary16`）的形式是1+5+11，取值范围大概是 `6e-8` 到 65504。
- `bfloat16` (Brain Floating Point Format)。这是由 TensorFlow 和一些现代 TPU 所支持的新一代 16 位浮点数——实际上就是 32 位浮点数直接取前 16 位，即 1+8+7。这种变种 16 位浮点数相对于标准的 FP16 有多个优点：更大的取值范围（范围和 FP32 接近，只是精度更低，而很多时候机器学习等领域不太在乎精度），和 FP32 转换极其容易（截断和补 0 即可），以及更快的乘法（小数位少就意味着要做乘法运算的位数少）。因此，BF16 大有成为机器学习新一代基础类型的潜力。
- 高于 64 位的浮点数。在标准中，高于 `double` (FP64) 的浮点数类型只有 `long double`，但是标准并未指明 `long double` 的位数，实际实现 80/96/128 位的都有。对于现代应用来说，有 IEEE 754 规定的标准 128 位浮点数（FP128，1+15+113）也是十分重要的。

而P0192的 `short float` 并没有可扩展性。且不说这个假想类型只能在 FP16 和 BF16 二选一，`long double` 已经被占了总不能再来一个 `long long double`（笑）。最终，C23 和 C++23 集体加入了新的浮点类型，从而在 C/C++ 领域中最后一致地更新到了最新的潮流。（C 的扩展浮点数提案是一个新的浮点数 Annex，具体类型是 `_FloatN`，而且没有 BF16；C++ P1467 当然也尽力保持了一致性，不过 C++ 是不可能用宏去实现扩展浮点数的；这里就不介绍 C23 的用法了）

具体来说，P1467 为 C++23 增加了“扩展浮点类型”这一概念。和现有的 `<cstdint>` 支持的“扩展整数类型”一样，实际上标准并不能真正强制实现支持某些扩展浮点数形式，而在标准中限定“扩展浮点类型”只有像 FP16，FP128 这样的类型又会限制未来的扩展支持。因此，标准中最后采取的办法就是不作说明——实现支持的扩展浮点类型可以是任意的，可以在 IEEE 754 中也可以不在。不过，为了用户使用上的方便，标准在 `<stdfloat>` 头文件中提供了五个类型别名：`std::float16_t`, `std::float32_t`, `std::float64_t`, `std::float128_t`和`std::bfloat16_t`。这些只是别名，也就是实现如果提供了对应的浮点数类型就可以做一个alias到这些别名。因此，所有这五个别名都是可选支持的。（注意！这里的五个类型别名必须指 IEEE 754 的 binary16/32/64/128 类型以及标准 BF16，这里没有像`float`/`double`那样可以不是 IEEE 754 形式的自由度；而且这些类型实际上对应C23的`_Float16`/`_Float32`等等，**注意和`_Float16_t`, `_Float32_t`等并不等价**）

当然，有了别名还远远不够。这一次标准还加入了对应这些扩展浮点类型别名的字面量后缀：`f16` 到 `f128` 对应 `std::float16_t` 到 `std::float128_t`，然后 `bf16` 对应`std::bfloat16_t`。比如说：

```cpp
auto a = 1.0f16; // std::float16_t
auto b = 1.0bf16; // std::bfloat16_t
```

这些后缀当然也是大小写不分的（即可以写成 `F16`, `F32`, `BF16`，注意 `bf16`/`BF16` 可行但是 `Bf16`/`bF16` 是不行的）。另外，遵守了C++20以来的规矩，所有这些别名也都有特性测试宏，可以单独检测实现是否支持某个扩展浮点数别名。测试宏的名称是`__STDCPP_FLOAT16_T__`（16可以换成32/64/128）以及`__STDCPP_BFLOAT16_T__`。（另外要注意的是，这些宏并不是在 `<version>` 中定义的而是编译器自带的宏，而且它们（如果定义）的值也是 1，而不是进入标准的日期）

另一个重要的特点（也是和 `<cstdint>` 的一个重要区别）是这些扩展浮点数别名并不能是标准浮点数类型的别名，也就是 `std::float32_t` 永远和 `float` 不是同一个类型（`double`/`long double` 也一样）。这点和 `<cstdint>` 不一样（`std::uint16_t` 和 `unsigned short` 完全可以是同一个类型），但是能够允许用户做 `void f(float)` 和 `void f(std::float32_t)` 这样的重载，因此 P1467 选择了这个行为。

有了这些类型别名之后，下一步使用起来最关心的其实就是它们的转换规则了。比如说：`float32_t` 能不能隐式转换成 `double`？诸如此类的问题。

首先，一个最重要的原则就是所有这些类型以及标准浮点类型都是可以随便显式转换的：

```cpp
auto b = static_cast<float>(1.0f128); // okay
```

这也和其他算数类型的行为一致，即如果你显式说了要转换，那么即使有精度损失也会允许。因此，我们只需要关注隐式转换。

扩展浮点数的隐式转换说起来也很简单：只要是转换序数相同或者从大到小的转换就是隐式的。转换序数是一个根据表示范围而定的概念——如果一个类型 `T` 所能精确表示的数的集合是 `U` 能精确表示的数的集合的严格超集，那么 `T` 的转换序数就比 `U` 大。注意，这个概念实际上是基于纯数学上的定义的，在 C++ 的世界中有着很多有意思的推论：

1. 浮点转换序数实际上是一个偏序关系（注意整型的转换序数是全序），也就是两个类型的转换序数比较除了大，小，相等三种结果，还有可能是无序的，也就是无法比较。
2. `U` 能精确表示的值 `T` 也能表示“翻译过来就是 `T` 的指数位和小数位都比 `U` 长或者相等
3. 对于标准及扩展浮点数而言（常见情况，`float` 32位，`double` 64位，`long double` 80位），转换序数是 `{float16_t, bfloat16_t} < float32_t = float < float64_t = double < long double < float128_t`。当然 `long double` 也有可能等于`float128_t`
4. `float16_t` 和 `bfloat16_t` 之间是无序的，都无法隐式转换到对方。
5. `long double` 这个比较特殊，它被强制规定成比 `double` 的转换序数大，即使它本身只有64位也是这样；正因如此 `long double` 到 `float64_t` 的转换一定是显式的，即使没有精度损失（两个都是64位）也不能隐式转换。
6. 这也就意味着 `std::float16_t f = 1.0` 是行不通的，必须显式转换。

当然，这种新的“相等或者大于”隐式转换规则只适用于新的扩展浮点类型—— `double` 到 `float` 永远都会是隐式转换，这已经改不了了。另外，整形提升也只有 `float` 到 `double` 一种情况——同样和 `uint16_t` 不一样，新的浮点数类型不会自动提升（谢天谢地）。总的来说，这种隐式转换规则也是十分符合直觉的，所有的隐式转换也都是不损失精度的。

有了隐式转换规则，我们就可以知道扩展浮点类型之间的四则运算和比较是什么规则了：如果两边的类型有一个可以隐式转换成另一个，那么就这么转换；如果两边都不能隐式转换（i.e. 转换序数无序），那么运算就是编译错误。当然这里多了一种情况：如果两边的类型都可以隐式转换成另一个，那么优先隐式转换成五个新的浮点类型别名。举些例子：

```cpp
float f; double d; long double ld;
float16_t f16; bfloat16_t bf16; float32_t f32; float64_t f64; float128_t f128;

f16 + f; // float16_t隐式转换成float
f16 - f32; // float16_t隐式转换成float32_t
f16 + bf16; // 转换序数无序，编译错误
bf16 - f64; // bfloat16_t隐式转换成float64_t
d >= f32; // float32_t隐式转换成double
f32 * f; // float隐式转换成float32_t（序数相等，优先新类型）
d / f64; // double隐式转换成float64_t
ld < f64; // float64_t隐式转换成long double（注意long double转换序数永远大于double和float64_t）
ld == f128; // long double隐式转换成float128_t
```

最后一个要解决的问题就是重载决议。这里，首先需要显式转换的组合就被排除掉了——这就帮我们去掉了一大堆组合。除此之外要记住的主要原则就是在多个隐式转换可行的时候，优先选择不改变转换序数的选择；如果所有选择都要改变转换序数，那么就是二义性的。举一些例子：

```cpp
// 仍然使用上面那些变量
void f(float32_t); // 1
void f(float64_t); // 2
f(f); // 12均可行，优先1（float/float32_t同序数）
f(d); // 仅2可行
f(f16); // 12均可行，二义性（编译错误）

void g(float); // 1
void g(float32_t); // 2
g(f); // 1
g(f16); // 12均可行，二义性

void h(float); // 1
void h(double); // 2
h(f16); // 12均可行，二义性
h(f32); // 12均可行，优先1
```

核心语言的改变说完了，P1467 实际上还为这些扩展浮点类型提供了相应的标准库支持。具体来说，有下面这些改变：

- 既有的 type traits ，如 `numeric_limits<T>`，`is_floating_point`，`std::numbers` 常量会获得新的扩展浮点数特化
- `to_chars` 和 `from_chars` 会获得扩展浮点数重载
- IOStreams 库的 `operator<<` 和 `operator>>` 操作符会获得 **所有转换序数小于等于`long double`** 的扩展浮点数重载（这是因为实现方式是转换成 `float`/`double`/`long double` 之一然后调用对应重载）
- `<cmath>` 中的大部分重载函数（比如 `fabs`）都会获得扩展浮点数重载
- `std::complex` 和 `std::atomic` 会获得扩展浮点数重载
- `std::format` 会支持扩展浮点数（没有自己的类型格式符）

注意，标准库的以下部分没变：

- `<cfloat>` 没有扩展浮点数支持；请用 `numeric_limits`
- `printf`/`scanf` 家族没有扩展浮点数支持；请用IOStreams或者 `std::format`
- `strtod`，`stod` 和 `to_string` 这些字符串转换操作符没有扩展浮点数支持，`strtod` 和 `stod` 是因为名字里有 `d`/`f`/`ld` 没法扩展，`to_string` 是因为实现依赖 `snprintf`；请用 `to_chars`/`from_chars`
- `<random>` 没有扩展浮点数支持（因为它没有扩展整型支持）
### 假定表达式：让编译器拿到更多信息

假定表达式 / Portable assumptions

cppreference - [P1774R8](https://link.zhihu.com/?target=https%3A//wg21.link/P1774R8) - [[dcl.attr.assume]](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/dcl.attr.assume) - 2022.07

支持：GCC not yet, Clang not yet, MSVC not yet

测试：`__has_cpp_attribute(assume) >= 202207L`

这实际上是一个让Clang的 `__builtin_assume` 和MSVC的 `__assume` 转正的特性。简单的说，一个假定就是在告诉优化器，假定这个表达式是真，大胆优化——如果表达式实际上是假的，程序就是 UB。这个“告诉”的语法是 `[[assume(expr)]]`。比如说：

```cpp
void limiter(float* data, size_t size)
{
    [[assume(size > 0)]];
    [[assume(size % 32 == 0)]];
    for (size_t i = 0; i < size; ++i)
    {
        [[assume(std::isfinite(data[i]))]];
        data[i] = std::clamp(data[i], -1.0f, 1.0f);
    }
}
```

这几个假定就可以让编译器直接把循环优化成一次处理 32 个非负元素的并行指令。注意假定不会做任何检查（这也是它和 Contracts 不一样的地方）——只要不是真的就是UB。实际上，假定内部的`expr`甚至不会被执行——它只是被 ODR-used。上面的代码绝大多数情况下是不会带对 `std::isfinite` 的调用的。另外，和 `[[fallthrough]]` 一样，`[[assume(expr)]]` 只能在空语句上写（换句话说就是`]]`后面要加分号）。

### 静态`operator()`：效率至上

静态`operator()` / static `operator()`

cppreference - [P1169R4](https://link.zhihu.com/?target=https%3A//wg21.link/P1169R4) - [[over.oper]/7.1](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/over.oper%23general-7.1) - 2022.07

支持：GCC not yet, Clang not yet, MSVC not yet

测试：`__cpp_static_call_operator >= 202207L`

至今为止，C++所有的运算符重载都必须是非成员函数或者非静态的成员函数——现在这一原则改变了。`operator()`会被允许成为静态函数——主要的目的和上面的按值传递成员函数一样，就是为了提升性能。静态函数不用传递`this`，所以连值传递都能省了。语法很简单，就是在定义前面加上`static`，调用形式完全不变：

```cpp
template <typename T>
struct less {
    static constexpr bool operator()(const T& x, const T& y)
    {
        return x < y;
    };
};
less<int>{}(2, 3);
```

可惜我们已经没有更改`std::less<T>`的机会了。另外一个可惜的点是lambda，现在我们可以指定`static`：

```cpp
auto f = [](int i) static {return i * 2;}
```

对于这种lambda，`static`只有好处，所以其实lambda一开始就应该是默认`static`的——可惜我们也改不了这一点了。另外要注意的是一个`static`的lambda不能有capture。

### `if consteval`：C++20 的 bugfix

`if consteval`

[cppreference](https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/language/if%23Consteval_if) - [P1938R3](https://link.zhihu.com/?target=https%3A//wg21.link/P1938R3) - [[stmt.if]/4](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/stmt.if%234) - 2021.06

支持：GCC 12, Clang 14, MSVC not yet

测试：`__cpp_if_consteval >= 202106L`

这实际上有点像一个 bugfix——C++20 引入了 `std::is_constant_evaluated()` 和 `consteval`，但是这两个特性互相之间有点冲突。前一个特性实际上就是一个魔法函数，告诉你当前是不是在编译期执行。比如说在一个 `constexpr` 函数（这种函数实际上既可以在编译期也可以在运行期执行）中，你就可以据此采用两种算法

```cpp
constexpr int some_computation(std::span<const int> sp)
{
    if (std::is_constant_evaluated())
    {
        int res = 0;
        for (auto a : sp) {res += a * a;}
        return res;
    }
    else
    {
        __asm__("Some SIMD Things");
    }
}
```

好，现在假设我们把那个编译期算法提到另一个函数（按照定义，可以写成一个强制编译期的 `consteval` 函数中）：

```cpp
consteval int compiler_computation(std::span<const int> sp)
{
    int res = 0;
    for (auto a : sp) {res += a * a;}
    return res;
}
constexpr int some_computation(std::span<const int> sp)
{
    if (std::is_constant_evaluated())
    {
        return compiler_computation(sp);
    }
    else
    {
        __asm__("Some SIMD Things");
    }
}
```

这样不行——你知道这个 `if` 函数体只会在编译期执行，编译器可不知道，它们只能看到一个有可能在运行期执行的函数调用了一个只能在编译期执行的函数，从而报错。很多人看到这一点就会使用传统解法——`if constexpr` 来告诉编译器这一点：

```cpp
constexpr int some_computation(std::span<const int> sp)
{
    if constexpr (std::is_constant_evaluated()) // OOPS
    {
        return compiler_computation(sp);
    }
    else
    {
        __asm__("Some SIMD Things");
    }
}
```

好吧，我承认我从提案里学了个词——这种用法是 "obviously incorrect"，或者说“显然不对”（笑）。实际上因为 `if constexpr` 的条件永远会在编译期执行，这个条件永远都是`true`。为了解决这个问题，我们就可以用 `if consteval`：

```cpp
constexpr int some_computation(std::span<const int> sp)
{
    if consteval
    {
        return compiler_computation(sp);
    }
    else
    {
        __asm__("Some SIMD Things");
    }
}
```

这样就没问题了。`if consteval` 就是一个加了作用域限定（让 `consteval` 函数可调用）的 `if (std::is_constant_evaluated())`。要注意的是和 `try` 一样它的 `if` 和 `else` 的花括号不能省。另外，它还有一个反向版本 `if !consteval`。

### `auto(x)` / _decay-copy_

自动推导的 copy / `auto(x)`: _decay-copy_ in the language

[cppreference](https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/language/explicit_cast) - [P0849R8](https://link.zhihu.com/?target=https%3A//wg21.link/P0849R8) - [[expr.type.conv]/1](https://link.zhihu.com/?target=http%3A//eel.is/c%2B%2Bdraft/expr.type.conv%231) - 2021.10

支持：GCC 12, Clang 15, MSVC not yet

测试：好像没有...

这个很简单，就是 `auto x = a` 意味着一个 copy，那么我们可以让 `auto(a)` 和 `auto{a}` 也意味着 copy... 这个语法看着有点怪，但是实际上我们知道 `int(i)` 就是 copy 一个 int，`Widget(w)` 就是 copy 一个 Widget，那么让 `auto(i)` 和 `auto(w)` 表示同样的东西也很正常——前面的类型相当于是被推导出来了。这个特性主要是为了取代标准中的 _decay-copy_ 这个概念——毕竟 auto 就意味着数组什么的会被退化回指针。
## 语言 - T3
### 新的预处理指令：30年的落后

(1) `#warning`

[cppreference](https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/preprocessor/error) - [P2437R1](https://link.zhihu.com/?target=https%3A//wg21.link/P2437R1) - [[cpp.error]](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/cpp.error) - 2022.07

支持：GCC Yes (13+不再警告), Clang Yes, MSVC not yet

测试：N/A (macro)

(2) `#elifdef` & `#elifndef`

[cppreference](https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/preprocessor/conditional) - [P2334R1](https://link.zhihu.com/?target=https%3A//wg21.link/P2334R1) - [[cpp.cond]/13](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/cpp.cond%2313) - 2021.10

支持：GCC 12, Clang 13, MSVC not yet

测试：N/A (macro)

这两个一起说，都相当于是 bugfix——`#warning` 已经有悠久的历史，像 `#error` 一样，后者是在这行生成一个自定义错误信息的错误，前者则是在这一行生成一个自定义信息的警告；C23 也在最近加了它，C++ 也应该加上它。而 `#elifdef` 算是 `#ifdef` 的自然延伸——`#elifdef` 就是 `#elif defined(...)`。用法很简单：

```cpp
#warning "Here!"  // 生成警告 (和#error很像)
#if SOMEMACRO > 10
#elifdef SOMEOTHERMACRO
// 等价于#elif defined(SOMEOTHERMACRO)
#elifndef SOMEOTHERMACRO2
// 等价于to #elif !defined(SOMEOTHERMACRO2)
#endif
```
### Down with ()!：简化lambda

lambda不再需要空括号 / Down with ()!

[cppreference](https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/language/lambda) - [P1102R2](https://link.zhihu.com/?target=https%3A//wg21.link/P1102R2) - [[expr.prim.lambda]](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/expr.prim.lambda) - 2021.02

支持：GCC 11, Clang 13, MSVC not yet

测试：纯 bugfix，不需要 feature testing macro

这个也很简单——就是原来如果 lambda 没有参数的话可以省略 `()`，比如说 `[](){return 2;}` 和 `[]{return 2;}` 是一样的——但是如果我们加上限定符（比如 `mutable`），我们就只能写 `[]() mutable {return 2;}` 了。现在，这个提案之后 `[] mutable {return 2;}` 也合法了。
### `constexpr` 扩展：永远前进的征途

(1) `constexpr`函数中的`goto`与非字面类型变量 / Non-literal variables (and labels and `goto`s) in `constexpr` functions

[cppreference](https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/language/constexpr%23relaxed-constexpr) - [P2242R3](https://link.zhihu.com/?target=https%3A//wg21.link/P2242R3) - [[expr.const]/5](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/expr.const%235) - 2021.10

支持：GCC 12, Clang 15, MSVC not yet

测试：`__cpp_constexpr >= 202110L`

(2) 对`bool`的截断转换 / Narrowing contextual conversions to `bool`

[cppreference](https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/language/static_assert) - [P1401R5](https://link.zhihu.com/?target=https%3A//wg21.link/P1401R5) - [[dcl.pre]/10](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/dcl.pre%2310), [[stmt.if]/2](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/stmt.if%232) - 2021.06

支持：GCC 9, Clang 14, MSVC not yet

测试：无（bugfix）

(3) `std::size(std::array)`修复 / Using unknown pointers and references in constant expressions

cppreference - [P2280R4](https://link.zhihu.com/?target=https%3A//wg21.link/P2280R4) - [[expr.const]/7](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/expr.const%237) - 2022.07

支持：GCC not yet, Clang not yet, MSVC not yet

测试：无（可能是忘了，应该bump `__cpp_constexpr`）

(4) 消除无谓的全域非常量表达式检查 / Relaxing some `constexpr` restrictions

cppreference - [P2448R2](https://link.zhihu.com/?target=https%3A//wg21.link/P2448R2) - [[dcl.constexpr]/N4](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/dcl.constexpr%23note-4) - 2022.07

支持：GCC not yet, Clang not yet, MSVC not yet

测试：`__cpp_constexpr >= 202207L`

自从C++11引入`constexpr`关键字以来，每一代标准都对这一关键字的适用范围做了扩展，让越来越多的函数可以被`constexpr`化，从而移动到编译期进行。C++11的原始`constexpr`只能包含一条`return`语句，C++14开始允许多条语句的`constexpr`函数，C++17让所有lambda都成为了隐式`constexpr`函数，并引入了在现代TMP中至关重要的`if constexpr`语句，而C++20则允许了`try`, `constexpr`透明内存分配的出现，并且让析构函数和虚函数也可以标记成`constexpr`。C++23继续了这一趋势，除了引入十分有用的`if consteval`语句来分隔运行期与编译期算法外，这4个提案则对`constexpr`函数的适用范围进行了进一步的增强。下面从最重要的开始说：

P2280这一提案可能是4个提案中最坎坷的一个，但也是最重要的一个，因为它解决了一个自从C++11以来就遗留的问题。先看一个例子：在C中，一个典型的宏应用是自动获取数组的长度：

```c
#define array_size(a) (sizeof(a) / sizeof(a[0]))
for (int i = 0; i < array_size(a); ++i)
{
    // ... use a[i] ...
}
```

这个宏实际上利用了`sizeof`对于真正的数组会返回整个数组的大小这一特性。然而，我们知道，在C和C++中，原生数组十分容易退化成指针，函数传递，拷贝，隐式转换，一个数组和它的头指针实在太难分开了。更加可怕的是，如果传递一个指针到上面的宏中，不会出现任何错误，反而会得到一个完全没有意义的长度值。这也是为什么很多很多C API都是把数组指针和长度一起传递的。

在C++中，我们有了`std::array<T, N>`来取代原生数组，也有了`std::span<T>`来取代指针-长度API。然而，很多时候我们依然要和原生数组打交道，毕竟它还是语言自带的类型。不过，在C++的世界中，有了`constexpr`，引用和模版的帮助，仅仅在C++11中我们就可以写出一个更好的版本：

```cpp
template<typename T, std::size_t N>
constexpr std::size_t array_size(T (&arr) [N])
{ return N; }
```

这里利用的特性是使用引用传递数组时，是少数几种数组不会退化成指针的场景，从而会保留长度让我们可以用NTTP参数获取出来。这个写法比起宏要好得多，毕竟像指针，`std::vector<T>`这类那个宏会毫无异义接受的类型（然后吐出一个无用长度）就不能传递进来。实际上，这个惯用法是如此常用，以至于C++17把它放进了标准，成为`std::size`全局函数（当然，这个全局函数同时能处理任何带`size()`成员函数的类）。

不幸的是，这个新的数组长度函数并没有宏那么通用：

```cpp
void fun(const int (&arr) [3])
{
    int local[] = {1, 2, 3};
    constexpr auto l1 = std::size(local); // okay, 3
    constexpr auto l2 = std::size(arr); // error (surprise!)
}
```

嗯？为啥本地数组可以用，参数就不行了？

背后的原因实际上有一些复杂。简单的说，C++11 `constexpr`函数的最大优势之一就是在编译期完全杜绝UB——也就是说，一个`constexpr`函数在编译期执行时内部不会出现未定义行为。比如说：

```cpp
constexpr int fun()
{
    int i = 2147483647;
    return i + 1;
}

int main()
{
    constexpr auto i = fun();
}
```

就会直接报错，而不是带着有符号整型溢出的UB执行下去。

这跟数组长度有什么关系呢？首先还是要明确一点，在编译器眼里，引用只不过是指针的语法糖，底层实现还是指针，帮你自动解引用而已。换成指针看看：

```cpp
template<typename T, std::size_t N>
constexpr std::size_t array_size(T (*arr) [N])
{ return N; }
void fun(const int (*arr) [3])
{
    constexpr auto l = array_size(arr); // error (surprise!)
}
```

这下问题应该是明显了——`arr`作为参数，编译期并不知道这个指针合不合法（完全可以传个`nullptr`进来），然后实际上`array_size`的调用自然要拷贝指针，而要拷贝指针就要读取它的值；然而`arr`的值在编译期并不知道（是参数），所以说就不行了。至于`local`，编译器能够确认它一定合法，所以就没事。

因此，这个提案就对这条规则做了一定的放宽：这里的放宽实际上仅限一类特殊的函数。看上面`array_size`实际上完全没有使用参数，我们在乎的仅仅是它的类型。因此，只有当我们确实没有使用引用的内容的时候，这条规则才能放开。这包括上面提到的只使用参数类型的情况，也包括只使用静态`constexpr`函数或者变量的情况，比如说：

```cpp
auto rando(std::uniform_random_bit_generator auto& g)
{
    if constexpr (std::has_single_bit(g.max() - g.min()))
        // ...
    else
        // ...
}
```

`max()`和`min()`都是静态，`constexpr`函数，如果换成`decltype(g)::max()`就是合法的，现在这么直接调用也是合法的了。

另外，这条规则的放松还带来了一个比较尴尬的情况——随着Deducing This加入标准，非静态成员函数访问静态成员函数/变量也有可能被这个未知引用规则干掉。比如说：

```cpp
template <bool V>
struct Widget {
   struct Config {
      static constexpr bool value = V;
   } config;

   void f() {
       if constexpr (config.value) {
          // ...
       }
   }
};
```

如果我们写的是`void f(this Widget& self)`然后用`self.config.value`访问的话，根据上面的规则这种情况会被放开，但是现在用`this.config.value`访问就不行，因为`this`并不能在编译期获取。因此，这个提案顺便放宽了`this`的相关规则，让上面的例子也是合法的了。

接下来是两个比较相似的提案，都可以概括成“消除无谓的检查”。C++20中允许了`constexpr`函数中**出现**`try`语句，但是并不允许编译期抛出异常，所以它的应用只不过是允许在（我们知道，但是编译器不知道）编译期不会执行到的地方使用这个语句：

```cpp
template<typename T>
constexpr void fun()
{
    if constexpr (sizeof(T) >= 8)
    {
        try {throw 1;} catch(int) {/* ... */}
    }
    // do whatever
}
```

在C++20以前，仅仅出现`try`语句就是一个直接报错的地方。现在不会做这样的检查，所以`fun<char>()`是完全没问题的，但是`fun<std::string>()`还是会报错的。这一特性主要还是为了支持对编译期和运行期采用不同的算法，比如说：

```cpp
constexpr void fun()
{
    if consteval
    {
        // naive循环
    }
    else
    {
        std::memset(/* ... */);
        goto somewhere;
        // etc
    }
}
```

C++23的P2242将这个趋势更进了一步：现在允许`constexpr`函数中出现`goto`语句，标签，非字面类型变量（即没有`constexpr`/`consteval`构造函数的类型），以及`static`/`thread_local`变量。还是一样的道理，这些构造允许出现，但是不允许在编译期执行，因此上面现在可以在`if !consteval`环境下用`goto`，`static int i = 2`之类的了。不过如果这些放到编译期下还是会报错的。

在此基础上，P2448实际上更进了一步。原来`constexpr`函数有一条有意思的规定，或者说全域检查，也就是说每一个`constexpr`函数必须存在一种输入，使得它实际上可以在编译期执行。或者说，如果编译器能够看出一个`constexpr`函数，无论输入什么，都只能在运行期执行，那么就应该报错。不过，标准也知道这一检查十分难以进行，毕竟能编译期执行的语句是越来越多了...因此，违反这一条（比如下面的例子）是一个IFNDR，不要求报错。

```cpp
void non_const(int& i) {i = 0;}
constexpr void use(int& i) {non_const(i);}
```

这里`non_const()`不是`constexpr`函数，因此不会在编译期执行。因此，任何对`use()`的输入都只能在运行期执行，所以这一段程序是IFNDR。自然，我们能看出这一条规则的初衷是好的：就是避免写出无法实现的`constexpr`声明，毕竟把一个只能在运行期执行的函数声明成`constexpr`没有意义。

然而，现实总是没这么完美的。事实上，一个看上去只能在运行期执行的函数声明成`constexpr`并不是一定没有意义。简单的例子就是随着标准变更带来的`constexpr`变化——仅仅在C++23中，`bitset`，`from_chars`，`unique_ptr`之类的类型和函数都变为了`constexpr`可用的。这样一来，一个用了`std::unique_ptr<T>`的函数在C++20中就完全不可能在编译期执行，所以应该报错；但是换成新标准就可以了，这显然不太好。（至于特性测试宏——理论上确实可以，但是第三方库应该没有粒度这么细致的宏）。这也正是很多编译期选择不实现这个IFNDR的全域检查的原因。更加怪异的是，标准的这条规则还有个例外：如果这个函数是`= default`的特殊成员，那么这个全域检查是强制进行的（不止是IFNDR，就是ill-formed）。比如说：

```cpp
template<typename T>
struct Widget
{
    T value;
    constexpr friend bool operator==(const Widget&, const Widget&) = default;
};

struct X {friend bool operator==(const X&, const X&) {/* ... */}};

Widget<X> widget_of_x; // error!
```

这里只是定义了一个`Widget<X>`类型的对象，完全没用到`operator==`，但是`Widget<X>`的实例化就已经报错了。究其本质就是默认生成的比较函数无条件调用了`X::operator==`这个非`constexpr`函数，从而报错。这篇提案因此改变了全域检查这条规则，从而以后标记`constexpr`也不会再检测是不是至少有一个参数输入能在编译期执行了。

最后是P1401。这个提案更像是一个C++11/17 DR。简单的说，`static_assert`和`if constexpr`语句的布尔条件一直跟它们的运行期对应，`assert`和`if`语句的条件有一些细微差异——它们的条件转换成`bool`时不允许截断。比如说：

```cpp
template<std::size_t N>
void fun()
{
    static_assert(N, "Nope");
}
```

是不行的，必须写`N != 0`。

诚然，这种限制的确增强了安全性，必须写明整个条件表达式才能编译通过。然而，一方面，通过`if constexpr(N)`或者`if constexpr (flags & FLAG_SOME_MASK)`检查非空容器和掩码仍然十分常用，另一方面让`static_assert`和`assert`拥有不同的行为十分烦人，毕竟这两个语句看上去就很像。因此，这个提案最后做出了退让，让`if constexpr`和`static_assert`的条件允许任意隐式条件转换成`bool`的表达式出现。当然，C++17 [CWG Issue 2039](https://link.zhihu.com/?target=https%3A//wg21.link/cwg2039)带来的底线仍然保持——`noexcept(bool)`和`explicit(bool)`语句的条件仍然是不允许截断转换的，毕竟这两个表达式一般还是用在type traits上面，后者结果一般都是`bool`或者至少是不算截断的0/1。

### Unicode转义字符增强：`\N`与`\u{}`

(1) `\N{UNICODE NAME}` / Named universal character escapes cppreference - [P2071R2](https://link.zhihu.com/?target=https%3A//wg21.link/P2071R2) - [[tab:lex.charset.ucn]](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/tab%3Alex.charset.ucn) - 2022.07

支持：GCC 13, Clang 15, MSVC not yet

测试：`__cpp_named_character_escapes >= 202207L`

(2) 分界版`\u{XXXX}` / Delimited escape sequences

cppreference - [P2290R3](https://link.zhihu.com/?target=https%3A//wg21.link/P2290R3) - [[lex.charset]/3](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/lex.charset%233) - 2022.07

支持：GCC 13, Clang 15, MSVC not yet

测试：无（使用旧版UCS escape即可）

Unicode已经成为了支持世界上的其他语言字符，表情字符等等扩展字符集的事实标准。遗憾的是，C++在Unicode支持上总是显得有些怪异和落后，使得很多现代C++程序仍然只能和ASCII字符串打交道。好在C++近些年逐渐开始补全了Unicode支持所需的各块拼图，从单一的宽字符类型`wchar_t`发展到了对于UTF-8/16/32的完整字符支持，同时也加入了`u8""`, `u8string`等配套语言和库设施。在C++23中继续了C++20开启的这一趋势，除了通过提案P2295强制所有编译器支持UTF-8源代码文件以外，在转义字符上也有新的进展。这方面，C++11引入了通用字符转义`\uXXXX`与`\UXXXXXXXX`来直接在字符串中插入Unicode代码点。然而，虽然代码点编码十分简洁，但是它们始终有着难以维护与阅读的缺点：`\u200B`肯定没有`\N{ZERO WIDTH SPACE}`来的清晰。P2071就是这样一篇提案，加入了新的`\N{name}`转义字符，让我们可以直接使用代码点的官方名称来代表这个代码点：

```cpp
"\N{LATIN CAPITAL LETTER A WITH MACRON}\N{COMBINING GRAVE ACCENT}"
== "\u0100\u0300"
```

不过，看着这一堆大写字符的官方名称总是显得有些烦人...Unicode官方推荐的名称比对方法实际上是UAX44-LM2，也就是忽略大小写，忽略部分空格和横杠，以及把下划线看成空格。也就是`\N{zeRo_width SPA-CE}`也是合法的名称。然而，这个“推荐”并没有什么用——目前所有支持相似的使用名称代表代码点的语言绝大多数都没有采用LM2这么松的算法。绝大多数语言都是直接要求完全匹配（D，Perl）或者最多用忽略大小写但是不忽略其他东西（空格等）进行匹配（Python）。P2071也没有例外——原来还想遵循推荐，让C++用上UAX44-LM2算法，然而EWGI 0-7-14反对，SG16 4-6落败于完全匹配，EWG 13-5-5弱倾向完全匹配（不算反对），三个工作组全部反对已经说明了这个算法的过于宽松实在不太合适。至于到底要不要忽略大小写，工作组总的意见还是要求完全匹配（大小写匹配），毕竟现在严格一点以后还可以放宽，要留有后路。这方面EWGI 12-4-5弱倾向（不算支持）严格匹配，SG16 6-6平手，EWG 11-6-6无倾向，所以仍然是一个有争议的话题，不过最后留有后路这一思想还是让P2071选择了最严格的方法，也就是D和Perl的包括大小写在内的完全匹配。不过不管如何，`\N`的引入已经是一个不错的进步。

P2290本身则更像是一个bugfix，或者说对于C++11设计错误的改正。一方面，Unicode字符集最高就到`0x10FFFF`，而且目前几乎所有代码点都只需要五位16进制数来表示。然而，只要超过4位，在C++11中表示这个代码点就必须用`\UXXXXXXXX`这一形式，比如`\U0001F1F8`，由于必须是8位前面几乎所有时候都要补上3个0。

另外一个错误的地方就是老生常谈的八进制数。在整形字面量中，前导0表示八进制数已经导致了不少疑惑(`01000 != 1000`? what? 其实`0o`前缀肯定更好)，但是在字符串中我们也有一个转义字符：`\ooo`，斜杠加1-3位八进制数表示对应的代码点，比如`\17`表示U+000F。然而，`\18`却表示U+0001后跟`'8'`，显得十分迷惑。更加混乱的是，另外还有16进制对应的`\xXXX`转义符。这个转义符跟`\u`很像，唯一的区别是不限制位数。然而，这个转义形式并没有明确的终止界限，而是碰到第一个不是16进制数字符的字符就终止。比如`"I have a \xabcar"`其实是`"I have a \x{abca}r"`的意思。

P2290则引入了新的带界限Unicode转义符来解决这些问题。现在，新的`\u{XXXX}`, `\x{XXXX}`, `\o{XXXX}`转义符分别代表了16，16，8进制的任意长度Unicode字符编码，并且有了明确的界限，比如`"I have a \x{ab}car"`。这些的使用场景和原来的`\uXXXX`, `\xXXX`, `\ooo`完全一样，当然后两者必须编码单一代码点的限制仍然在。

另外，这两个提案都包含花括号语法，所以要注意：字符串拼接是在代码点替换之后发生的，所以`"\u{1F1" "F8}"`是不行的。

### Implicit Move的世界：`return x`背后的努力

`return x`的最终fix / Simpler Implicit Move

cppreference - [P2266R3](https://link.zhihu.com/?target=https%3A//wg21.link/P2266R3) - [[expr.prim.id.unqual]/3](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/expr.prim.id.unqual%233) - 2022.07

支持：GCC not yet, Clang 13, MSVC not yet

测试：`__cpp_implicit_move >= 202207L`

Copy Elision并不是一个简单的话题。由于简单的`return x`语句可能是C++函数中最常出现的语句之一，自从C++98以来，每一代标准都在这个话题上下了十足的功夫，为了将这一返回语句的性能压缩到极致。举个最简单的例子：

```cpp
struct X { X(const X&); X(X&&) noexcept; };
X produce();
X fun() { X x = produce(); return x; }
void use()
{
    X y = fun();
}
```

在事实上拥有non-trivial的拷贝/移动构造函数的情况下（注意这里完全不涉及赋值），以上这个片段会产生几次拷贝和移动？单从字面上来看，`x`的构造是一次移动构造，返回`x`需要一次拷贝，然后`y`的构造又是一次移动构造。然而，事实上这个“拷贝”是从`x`到`fun()`的返回值存储地址（在`use()`的栈帧中），所以`use()`可以控制这个地址，从而可以直接将`x`拷贝到`y`中而省略一次移动。要注意的是，即使是C++98中也直接允许了这样省略一个有副作用的拷贝构造函数的行为。事实上，即使是25年前的C++98标准也允许编译期更进一步——连第二步的拷贝构造函数调用也可以省略掉，直接把`produce()`的结果移动进`y`中即可（当然当时没有移动这个概念）。这个优化被称作NRVO，即命名的返回值优化。

C++11在这基础上更进了一步，提出了implicit move的概念。NRVO本身的限制性很强，一方面要求直接返回一个变量名，不能有任何修饰（比如`return std::move(x)`之所以是不建议的用法就是因为这么写NRVO就没戏了），另一方面要求函数返回值就是`X`，不能是其他类（比如父类），而且`X`的拷贝构造函数必须可用（虽然不会调用，但是毕竟`return x`明面上是要拷贝的）。Implicit move规则放松了后一条要求：现在会先将`x`看作右值，进行第一轮重载决议，如果成功的话就照常NRVO，否则回到C++98规则（第二轮重载决议看拷贝构造函数）。这样形如

```cpp
std::unique_ptr<T> fun()
{
    std::unique_ptr<T> up = /* ... */;
    return up;
}
```

就可以NRVO了。以前这样的move-only类型是不能直接返回的。

C++14定稿期间，[CWG issue 1579](https://link.zhihu.com/?target=https%3A//wg21.link/CWG1579)又一次放松了第二条规则的另一个部分：返回值不必完全和变量类型相等了。现在，下面的例子也是合法的：

```cpp
struct Base {/* ... */};
struct Derived : public Base {/* ... */};
std::unique_ptr<Base> fun()
{
    std::unique_ptr<Derived> up = /* ... */;
    return up;
}
```

注意在类型不同的情况下copy elision从来不会发生，但是implicit move规则在C++14中会照常起作用，从而这里会调用`unique_ptr`的转换版移动构造函数，将`up`看作右值返回。

C++20则在这一基础上继续扩张了implicit move的范围（C++17 guaranteed copy elision也是个很重要的改变，但是跟implicit move这个话题关系不是太大，毕竟仅仅是语义上的改变，没有改变实际调用结果）。[P1155 More Implicit Move](https://link.zhihu.com/?target=https%3A//wg21.link/P1155)的接受使得现在implicit move不再限定于纯粹的移动构造函数了，比如：

```cpp
struct Source {/* ... */};
struct Sink { Sink(Source); };
Sink process() { Source s; return s; }
```

这里`Sink`是用纯粹的传值参数来接受的`Source`。然而，C++17的时候这里会先拷贝`s`，然后调用`Sink`的构造函数，因为C++11 implicit move的一个重要条件是目标构造函数必须严格接受右值，也就是`Sink(Source&&)`这样的签名才可以。P1155解除了这个限制，从而以上例子也会先调用`Source`的移动构造函数，再调用`Sink`的构造函数。

简单的总结一下的话，implicit move的基础思想就是`return x`本质上可以确保是`x`的最后一个使用地点，这样我们就可以放弃`x`的内容，从而使用移动而不是拷贝来构造返回值，表现也就是`x`在返回语句中被看作右值。

在C++23中，P2266更像是一个随之而来的“最终解决方案”，或者说还是P1155的bugfix。一方面，CWG 1579留下了一个有些奇怪的现象：`Sink(Source&&)`可以作为返回值，然而单纯的`Source&&`竟然不行！

```cpp
struct Source {/* ... */};
struct Sink { Sink(Source&&); };
Sink process() { Source s; return s; } // okay
Source&& process() { Source s; return s; } // error!
```

当然，这个“不行”虽然不符合常理（多一步转换反而可以返回了？），但是却是有益的，毕竟返回`Source&&`就成悬挂引用了。然而，P0527进入C++20之后，一个稍有变化的情景可就没那么简单了：

```cpp
struct Source {/* ... */};
struct Sink { Sink(Source&&); };
Sink process(Source&& s) { return s; } // okay
Source&& process(Source&& s) { return s; } // error!
```

是的，接受`Source&&`类型的参数再返回同样类型的结果在C++11一直到C++20都是不行的——毕竟`s`本身是一个左值表达式，我们必须`return std::move(s);`。然而，前面说过这种写法普遍上是损害效率的，而虽然这里没有NRVO的事情，但是统一使用简单的`return s;`显然是一个不错的诱惑。

一个更大的遗留问题就是C++11开始的两轮重载决议。一旦遇到这种“两轮”的问题，我们就必须面对它们的区分问题——标准中写的是第一轮（将返回值看作右值）失败之后进行第二轮，但怎么才算失败呢？选到`= delete`的函数算不算失败？或者更加迷惑的，选到多个ambiguous的重载，无法选出最优解是算失败（从而进行第二轮）还是直接报错？这些问题在C++20的各家实现中实际上引发了分歧。因此，P2266决定彻底解决这两个问题。

解决方案实际上很简单：直接去掉第二次重载决议，也就是去掉C++11为了兼容性保留的那个fallback——现在只要能move的`return x`语句，就会直接把`x`当作右值。这样，C++11一直到20的implicit move扩展成果并没有被放弃，而是通过引入少量不兼容性的方法最终去掉了最后一个copy的可能。这样，形如`X&& fun(X&& x) {return x;}`的函数就是合法了的，因为这里`x`会被直接看成右值。当然，这样的bugfix总会带来一些不兼容性，比如说

```cpp
int& fun() {int x = 0; return x;}
```

这样的函数自从C++98以来就是悬挂引用的完美示范，现在这样的函数终于ill-formed了，毕竟这里`x`会被看成右值。（可惜的是，如果把返回值换成`int&&`，那就还是一个合法的返回悬挂引用的地方。）

P1155和P2266的作者在CppNow 2021上有一个很不错的演讲，将这两篇提案的来龙去脉讲清楚了，想要了解NRVO和implicit move的完整历史与底层实现的推荐过去看一看：

[The Complete Guide to `return x;` - Arthur O'Dwyer - [CppNow 2021]​www.youtube.com/watch?v=OGKAJD7bmr8](https://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3DOGKAJD7bmr8)

### 确定性的定义顺序：灵活性太高也是一件坏事

清除非标准内存存放顺序 / Make declaration order layout mandated

[cppreference](https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/language/data_members%23Layout) - [P1847R4](https://link.zhihu.com/?target=https%3A//wg21.link/P1847R4) - [[class.mem]/20](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/class.mem%23general-20) - 2021.06

支持：GCC Yes, Clang Yes, MSVC Yes

测试：无（bugfix）

众所周知，C++11对标准术语方面带来了一次变革——从C++98开始使用的POD（Plain Old Data）这一概念正式寿终正寝，相关的type traits（例如`std::is_pod`）也在C++20中正式被deprecate。究其原因，主要还是POD这一概念过于严格，而在C++11周期中，委员们最终发现这一概念实际上是两个概念的组合体：平凡（trivial）类型和标准布局（standard layout）类型，而标准中许多关于POD的段落实际上也可以扩展到适用于所有平凡类型或者所有标准布局类型，因此，[N2342](https://link.zhihu.com/?target=https%3A//wg21.link/N2342)完成了对这个概念的拆分。

平凡类型实际上很容易理解：可以直接认为就是那些“由编译器来写特殊成员”的类型，即6个特殊成员（包括默认构造函数）均是由编译器生成的类（当然，之后的几个标准也对平凡这一概念做了些许修改，这里只是一个简略的描述）。标准布局就没那么容易理解了。

简单的来说，由[[class.prop]/3](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/class.prop%233)描述的标准布局类就像那种“一眼望到头”的类，或者说最像原始C struct的类：没有虚函数，没有多继承，所有成员变量都使用同一个访问控制。比如说：

```cpp
struct A {int a; int b;};
struct B {int c; int d;};
```

上面的`A`和`B`都是标准布局的类。

标准布局也带来了一个衍生的概念——当两个标准布局的类的成员变量有相同的类型和相同的顺序的时候（当然，这个定义也不准确），这两个类（比如上面的`A`和`B`）就拥有相兼容的布局。这也就意味着标准实际上保证了`offsetof(A, b) == offsetof(B, d)`...即两个“相同”的类也拥有相同的成员偏移量。

然而，标准布局实际上是一个限制性很强的概念——毕竟大多数类都是混合使用`public`和`private`的。如果标准在这里直接不做规定的话，那么对于非标准布局的类做编程（比如后定义的变量反而可以先在布局中出现）就太难了。因此，C++对非标准布局对类也做出了一个基础规定：对于两个没有被访问控制符号（即`public:`类似的）分隔的变量，它们的布局顺序一定和定义顺序相等。也就是说，对一个非标准布局的类`C`：

```cpp
struct C
{
    int a; int b;
private:
    int c;
public:
    int d; int e;
}c;
```

标准在这种情况下保证了`&c.a < &c.b && &c.d < &c.e`。注意，这条规则在C++98中限制性很强——同一访问级别不够，必须是同一个“访问块”，即上面`c.a`和`c.d`的布局先后顺序并没有规定。这是为了给编译器自由度，使得在布局时可以随意交换这样的“访问块”来提高性能，比如把`[c]`排在`[a b]`前面之类的。

然而，并没有哪个编译器真正做了这样的交换...毕竟这一行为实在是很反直觉，先定义的后出现在类布局中？也只有EDG前端加了个编译选项，让所有类都先排列`public`变量，然后`protected`，最后`private`（即`C`按照`[a b d e c]`排列），然而并没有任何人真的启用这个选项。

终于，在C++11中，随着POD概念的拆分，新的标准布局Wording中对这个自由度做出了初步的限制：从“访问块”终于变成了正常的同一访问级别的变量均强制按照定义类型来布局。也就是说，这下上面的`C`类中，`&c.a < &c.b < &c.d < &c.e`就是必须成立的了。然而，标准仍然没有对**不同**访问级别的变量之间的布局顺序做出任何规定——也就是说`&c.c`可以出现在`a`前面，可以出现在`d`和`e`之间，任何地方都可以。这样那个编译选项的效果就仍然被标准所允许。

最终，10年又过去了，这一剩下来的自由度仍然被证明是不必要的——所有仍在流行的编译器都会严格按照定义顺序来布局成员变量。最终，在C++23中，P1847终结了这方面的所有自由度，这样对上面的`C`类来说，`&c.a < &c.b < &c.c < &c.d < &c.e`就是一个一定成立的表达式了。要注意的是——这里只是说成员变量没有自由度了，没有说父类的事情，也就是说如果是

```cpp
struct A {int a;};
struct B : A {int b;} b;
```

那么`&b.a`和`&b.b`哪个靠前仍然是没有规定的。

### CTAD增强：继承构造函数的缺憾

继承构造函数的CTAD / Wording for class template argument deduction from inherited constructors

cppreference - [P2582R1](https://link.zhihu.com/?target=https%3A//wg21.link/P2582R1) - [[over.match.class.deduct]/2](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/over.match.class.deduct%232) - 2022.07

支持：GCC not yet, Clang not yet, MSVC not yet

测试：无（bugfix）

在C++中，如果要完美继承父类的构造函数，很多人的第一反应都是写一个完美转发：

```cpp
struct A { /* 很多A(...) */ };
struct B : A
{
    template<typename... Ts>
    B(Ts&&... args) : A(std::forward<Ts>(args)...) {}
};
```

这样，所有传给B构造函数的参数都会被原封不动地传递给`A::A`，从而实现了子类和父类构造方法上的完全一致。

然而，这种方法有他自己的缺点：一方面，是模版构造函数必然带来的大量二进制重复；另一方面，完美转发有着自己的失效场景，比如`B({1, 2, 3})`必然失效，而`A`则有可能能够从`std::vector<int>`之类的构造。可能你会说：再添加四个模版重载，`B(const std::initializer_list<T>&)`（和另外三个不同修饰符的版本）不就行了？然而，当`A`有一个从`std::pair<int, double>`构造的构造函数时，我们可以直接用`A({1, 2.0})`进行构造，然而对`B`来说这么构造是永远不可能的——毕竟真正的list-initialization初始化器是无法完美转发的。

好在，这里标准提供了自己的解决方式——直接使用`using`声明将父类的构造函数引入子类：

```cpp
struct A { /* 很多A(...) */ };
struct B : A
{
    using A::A;
};
```

这样就是真正的完美转发了——`B({1, 2.0})`也没问题，而且也少了模版的额外开销。

然而，在C++23以前，这个“完美”的继承方式其实并不完美——继承而来的构造函数忽略了CTAD的作用！比如说：

```cpp
template<typename T>
struct A
{
    T func;
    A(T&& t) :func(t) {}
    void operator()() const { func(); }
};
template<typename T>
struct B : A<T>
{
    using A<T>::A;
};
```

这里，由于自动CTAD的作用，`A a([]{});`是一个合法的构造。然而，`B b([]{});`不是，因为CTAD不会对这种“继承”的构造函数起作用。更尴尬的是，由于参数是个lambda，提供模版参数需要费很大的功夫（拿个`auto`存一下然后`decltype`可能是最简单的做法）。同理，如果A有显式的模版推导指示，也会被子类忽略。P2582补上了这一缺陷，从而让上述例子中`B b([]{});`也是合法的了。

需要注意的是，这当然不意味着`using`声明带来的构造函数就是完美的重复API方法——因为父类完全可以没有构造函数而构造对象。最典型的例子就是当A是一个aggregate的时候，虽然C++20让aggregate也可以通过括号构造，这里并没有生成任何构造函数，从而也不会被子类“继承”。从而对于

```cpp
struct A {int a, b, c;};
struct B : A {using A::A;};
```

来说，`A a(1, 2, 3);`合法，但是`B b(1, 2, 3);`仍然会因为没有构造函数而失效。

### 重要的CWG Issue

CWG2355: Deducing _noexcept-specifier_s

CWG2507: Default arguments for `operator[]`

CWG2586: Explicit object parameter for assignment and comparison

均通过[P2622R0](https://link.zhihu.com/?target=https%3A//wg21.link/P2622R0)在2022-07接受

CWG/LWG Issue（几年之前还有EWG/LEWG Issue）是比正式提案更低一级的形式，主要目的就是为了一个很小的bugfix，不值得完整的走一遍提案流程，就可以直接提个Issue扔给CWG和LWG判断；每次Plenary都会接受一大批这样的Issue。相比之下，因为库特性的设计争议相对较多，而且LWG也比CWG更加容易通过，很多原本应该是Issue的库设计失误都成为了提案，所以CWG Issue的含金量比LWG Issue更高，毕竟很多改正的CWG Issue就相当于新的语言特性了。

首先说CWG2355，这个其实是个老问题了，2017年中就提出来，但是直到最近CWG才有人想起了这个issue，讨论了一下然后接受了。这个issue说的是函数模版推导时`noexcept`标识符的推导问题：

```cpp
template<typename R, typename... Args>
void fun(R (*f)(Args...));
```

像这样的函数模版可以接受任意函数指针，但是有`noexcept`修饰的除外——毕竟在C++17中，`noexcept`成为了函数类型的一部分，也就是`int (*)()`和`int (*)() noexcept`是不同的两个类型，后者自然也就没法传递给`fun`。在C++23以前，这个问题的解决方案就是加一个重载：

```cpp
template<typename R, typename... Args>
void fun(R (*f)(Args...) noexcept);
```

但是问题是，一方面这是同一个函数的重复，另一方面自从C++11开始，`noexcept`就可以带一个参数——表示条件性`noexcept`。于是，很多人自然会想到下面这个解决方案：

```cpp
template<typename R, typename... Args, bool E>
void fun(R (*f)(Args...) noexcept(E));
```

也就是用一个`bool` NTTP来直接推导出`noexcept(true)`或者`noexcept(false)`，这样就不用写两遍了。

遗憾的是，标准并未指明这种写法的合法性，也就是说那张可以推导出来的参数大表（[[temp.deduct.type]/8](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/temp.deduct.type%238)）中并没有`noexcept(E)`这一项，从而导致了各大编译器厂商也对这种情况合不合法做出了不同的选择（MSVC认为这里不能推导出`E`，GCC/Clang认为能）。最终，CWG2355在C++23的解决明确了这种写法的合法性，也就不再会有编译器差异了。

CWG2507则属于标准wording的缺陷——在C++23接受多元`operator[]`那个提案的时候，里面的wording忘了允许默认参数（也就是禁止掉[[over.oper.general]/10](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/over.oper.general%2310)这一段，`operator()`就是显式允许了默认参数），导致目前实装多元`operator[]`的编译器都不允许默认参数。自然，这是一个无理的限制，也就由这个Issue放松了。

CWG2586其实同样也是wording的疏忽，但是比上一个复杂一点。Deducing This这个特性理论上是可以用于任何成员函数的——包括成员操作符和特殊成员函数。但问题是标准中这一段的wording有一些自相矛盾，导致看起来形如

```cpp
struct A
{
    A& operator=(this A&, const A&);
};
```

这样的定义并不会被看成特殊成员函数，从而会与自动生成的版本产生冲突（MSVC行为）；这个Issue解决了这个矛盾，从而上面的版本也是合法的拷贝赋值操作符了；另外还有`bool operator==(this const A&, const A&);`也是合法的比较操作符签名。这两个形式后面都可以加`= default`。

## C++23标准库部分盘点

标准库这边就是另一个场景了——LEWG和LWG的工作效率还可以，库特性也更容易加，所以这边的特性非常多，基本能和C++17的标准库部分打平甚至有所超越。

T0没有（差点有，Executors没进来）。同样，T2和T3很多，只挑了最重要的几个。

## 标准库 - T0.5

### `import std`：新时代的`#include <bits/stdc++.h>`

`import std` / Standard Library Modules `std` and `std.compat`

cppreference - [P2465R3](https://link.zhihu.com/?target=https%3A//wg21.link/P2465R3) - [[std.modules]](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/std.modules) - 2022.07

支持：GCC not yet, Clang not yet, MSVC not yet

测试：`__cpp_lib_modules >= 202207L`

尽管我把这个提案列作C++23唯一的T0.5级特性，其实它的标准文本特别简单——可能连5页都没有，但是`import std`的重要性怎么拔高也不为过。可以说这个提案的简单是因为它站在巨人（C++20 Modules）的肩膀上。

简单的说，这个提案彻底终结了标准库中`#include`的使用——不用再搞什么`#include <iostream>`了，一行`import std;`统统搞定。这一行实际上很像GCC那个好多人在竞赛里用的`#include <bits/stdc++.h>`——只不过`import std;`要快得多，以至于`import std;`这个一下子把整个标准库全部import进来的语句比`#include <iostream>`还快——没错，import几十个文件比`#include`一个文件还快。可以看[P2412R0](https://link.zhihu.com/?target=https%3A//wg21.link/P2412R0)里面的性能测试。因此，以后很有可能所有程序从开头的

```cpp
#include <iostream>
#include <string>
// etc etc
```

直接变成开头一句`import std;`完事了。这实际上跟Python差不太多，那边也是任何库都直接`import requests`，`import torch`之类的就行了，也不管这个库有多大。

这之所以是个T0.5级特性，是因为编译器实现这个特性需要费很大力气——每一个标准库函数都需要加上`export`。不过那就不关我们用户的事情了。要注意的是，这个实现难度很有可能意味着这个特性至少得到2023年底或者更久才能实现，就像Modules现在的状态一样。

另外，从名字中也可以看到这个提案还引入了一个`std.compat`模块。这是为了和C兼容——以前，实际上你`#include <cmath>`的时候，你是可以直接调用全局空间的`sqrt()`。不过，在`import std`这个时代，这个问题被修补了——`import std`带来的所有名称（除了两个例外，`::operator new/delete`）都在`std`命名空间里面，也就是说我们必须`std::sqrt()`才行。这可能会break很多C代码——这时候我们就可以`import std.compat;`，这样所有的`<cfoo>`头文件都会把名字引入全局空间。

当然，这里是C++，没有什么事情是完美的——最大的问题（或许是改进？）是所有命名Modules不能引入宏。也就是说，`import std;`也不会引入任何宏，比如说`errno`，`assert`和`va_start`。我们还是得手动`#include`或者`import` `<cerrno>`，`<cassert>`和`<cstdarg>`这三个头文件（还好，这些宏都有自己的独立头文件）。要注意的是，几乎所有`<cmath>`函数（和一些其他C函数，比如`strtod`什么的）都会设置`errno`，这也就意味着如果我们要检查错误的话必须写两行——

```cpp
#include <cerrno> // OR import <cerrno>;
import std;
```

好在这也不算太繁琐。

在将来，`std`大概率会被继续细分成更小的模块，比如`std.io`，`std.fundamental`之类的，这也像Python一样——`import std`自动`import`了这些小模块，你也可以只import这些小模块来限制名称可见性。不过那就是C++26以后的事情了。

## 标准库 - T1

### `std::print`：新时代的输出手段

`std::print` / Formatted output

[cppreference](https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/io/print) - [P2093R14](https://link.zhihu.com/?target=https%3A//wg21.link/P2093R14) - [[print.fun]](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/print.fun) - 2022.07

支持：GCC not yet, Clang not yet, MSVC not yet

主要头文件：`<print>`

测试：`__cpp_lib_print >= 202207L`

我把最重要的T1级特性这个头衔给了`std::print`——因为它同时是一个C++追求了30年的特性，也是一个能够大幅度改变初学者学习C++路径的特性。和`import std`一样，实际上这个提案也像是站在巨人（C++20 `std::format`和`{fmt}`库）的肩上——这个提案本身的标准文本也挺短的。这个提案实际上就是`fmt::print`转正。

终于：C++要有一个能看的`print`了！

回顾一下历史：C++实际上有两套主要的输出方式——一套是继承自C的`<cstdio>`，里面有我们熟悉的`scanf`和`printf`。这两个函数使用的都是格式字符串——

```cpp
int val; std::scanf("%d", &val);
std::printf("%d\n", val);
```

自然，作为一个C函数，它有种种缺点——不能为自定义类型定义输出方式，不能检查类型是否正确，也不能适应现代的C++类型（C varargs并不能可靠地传递C++类型），而且还得手动指定d/f之类的类型标识。不过，它的最大优点就是语法简洁——`%5d`就是补齐位宽到5，`%.2f`就是两位小数。另外一个优点就是效率极高。

C++自己自然也发明了一套输入输出系统——这就是引起巨大争议的IOStreams库。这个库充分利用了C++特性——包括使用继承让`istream`/`ostream`成为一个可以统一输入输出流，字符串和文件的抽象接口，以及使用运算符重载来输出。

```cpp
int val; std::cin >> val;
std::cout << val << std::endl;
```

这一方式基本解决了`printf`的所有问题——可以自动推导类型，可以自定义（自己重载`operator<<`即可），可以方便地传递各种引用/move-only类型等等。然而最大的问题就是一旦输出长了可读性就直线下降，比如输出一个三维点坐标

```cpp
float a, b, c;
// ...
std::printf("(%f, %f, %f)\n", a, b, c);
std::cout << '(' << a << ", " << b << ", " << c << ")\n";
```

而且如果你想指定位宽和精度，就得和`<iomanip>`打交道——比如说繁琐的`std::cout << setprecision(10)`之类的。所以对长输出来说`cin`/`cout`是不太友好的。另外一个缺陷是因为所有东西都要用`<<`串起来，上面那一句实际上调用了7个函数（每个操作符重载一个，先不管inline的话）而不是一个，所以效率会低一些。

在C++20中，标准库引入了`std::format`，汇集了两者的优点——实际上这是收编了已经被广泛使用的`{fmt}`库的一小部分。简单的说，`std::format`和Python的`str.format`方法几乎完全一样，使用了一个比起`printf`更加先进的格式串格式——这样，在保留了`printf`的简洁性和性能的基础上，加入了`cout`拥有的自定义能力和推导类型，而且还加入了自己的更强功能（指定格式化顺序）。比如上面的点输出用`format`来写就是

```cpp
std::cout << std::format("({}, {}, {})\n", a, b, c);
```

跟`printf`一样简洁，而且不用写出类型是什么；而且我们可以指定顺序：

```cpp
std::cout << std::format("({1}, {0}, {2})\n", a, b, c); // output (b, a, c)
```

在格式化方面，从Python借鉴（笑）过来的格式串也在简洁和表达能力方面找到了一个不错的平衡（冒号前面是顺序指定，后面是格式串）：

```cpp
// alignment
char c = 120;
auto s0 = std::format("{:6}", 42);    // value of s0 is "    42"
auto s1 = std::format("{:6}", 'x');   // value of s1 is "x     "
auto s2 = std::format("{:*<6}", 'x'); // value of s2 is "x*****"
auto s3 = std::format("{:*>6}", 'x'); // value of s3 is "*****x"
auto s4 = std::format("{:*^6}", 'x'); // value of s4 is "**x***"
auto s5 = std::format("{:6d}", c);    // value of s5 is "   120"
auto s6 = std::format("{:6}", true);  // value of s6 is "true  "

// fill 0
char c = 120;
auto s1 = std::format("{:+06d}", c);   // value of s1 is "+00120"
auto s2 = std::format("{:#06x}", 0xa); // value of s2 is "0x000a"
auto s3 = std::format("{:<06}", -42);  // value of s3 is "-42   "
                                       // (0 is ignored because of < alignment)

// width & precision: static & dynamic
float pi = 3.14f;
auto s1 = std::format("{:10f}", pi);           // s1 = "  3.140000" (width = 10)
auto s2 = std::format("{:{}f}", pi, 10);       // s2 = "  3.140000" (width = 10 - dynamic from parameter)
auto s3 = std::format("{:.5f}", pi);           // s3 = "3.14000" (precision = 5)
auto s4 = std::format("{:.{}f}", pi, 5);       // s4 = "3.14000" (precision = 5 - dynamic from parameter)
auto s5 = std::format("{:10.5f}", pi);         // s5 = "   3.14000"
                                               // (width = 10, precision = 5)
auto s6 = std::format("{:{}.{}f}", pi, 10, 5); // s6 = "   3.14000"
                                               // (width = 10, precision = 5 - both dynamic from parameter)
```

自定义方面也有不错的支持，自己的类型可以通过特化`std::formatter`并提供`format`和`parse`方法来进行自定义格式化。比如说，标准库的chrono部分就做了一个不错的格式串支持（当然，也是从Python_借鉴_的）

```cpp
std::cout << std::format("Today is {:%Y.%m.%d}\n", std::chrono::system_clock::now());
// Today is YYYY.MM.DD
```

不过严格意义上来说，`format`是直接替代`sprintf`的成果——只能输出字符串，不能直接输出到文件或者流。`std::print`，顾名思义，就是补上了这个缺陷。它的语法很简单，和`format`完全一样——你可以理解成`print(format-string, args)`就是`cout << format(format-string, args)`（有区别！只是便于理解）。比如说上面的几个例子就是

```cpp
std::println("({}, {}, {})", a, b, c);
std::print("Today is {:%Y.%m.%d}\n", std::chrono::system_clock::now());
```

主要要注意的几点是：

- 因为`cout`的效率问题（WG21自己都嫌弃，笑），默认的输出渠道是`stdout`，也就是默认和`printf`一样。这不太可能在现实中造成很大问题——不过如果你把`cout`和`stdout`的同步关掉了的话就要注意这一点。如果你想手动指定输出渠道（比如输出到`stderr`或者文件），可以指定第一参数：

```cpp
std::println(std::cout, "({}, {}, {})", a, b, c);
std::println(stderr, "({}, {}, {})", a, b, c);
std::ofstream file_out("my.txt");
std::print(file_out, "Today is {:%Y.%m.%d}\n", std::chrono::system_clock::now());
```

- 这个第一参数支持`FILE*`和`std::ostream&`进行输出渠道指定。
- 正如上面展示的，还加入了一个`std::println`自动在末尾补换行符。
- 要注意的是，C++23周期中对C++20做的bugfix之一就是让`std::format`在遇到格式串错误（比如`std::format("{:d}", "222")`）的时候直接产生编译错误（原来是抛异常）。这自然就要求格式串一定得是一个字面量（跟Rust `format!`一样），不能是变量合成的格式串（本来绝大多数人用`printf`也是字面量吧——而且动态产生格式串本来就容易出安全问题）。也就是说`std::format(s + "222", 1, 2)`是不行的——`std::print`也是这样。如果你_真的_需要动态格式串，可以包一层：

```cpp
auto s2 = std::vformat(s + "222", std::make_format_args(1, 2));
```

- `vprint`是没有的，你只能自己拿`cout`输出。原因是`print`比起`format`额外对Unicode做了一些处理——在Windows命令行下UTF-8输出是有问题的（还记得CP936吗？），`print`做了一点额外处理来把这种情况修复。因此，它的`v`版本实际上是两个——`vprint_unicode`和`vprint_nonunicode`。
- 这个`print`是`fmt::print`转正，和Python那个`print` 不一样！最大的区别就是只输出一个元素的时候，你不能直接往外面一套`print(...)`完事，注意看差别

```cpp
print(some_complex_object)
std::print("{}", some_complex_object) // <==
print(a, b, c)
std::print("{} {} {}", a, b, c)
```

这也算比较无奈——C++没有字符串字面量加方法（`"1".toString()`之类的）的传统，也没有keyword argument，实现不了Python那种效果。不过无论如何，再加上前面的`import std`，我们终于可以声称C++23的Hello World可以变得前所未有的简单——

```cpp
import std;
int main()
{
    std::println("Hello World!");
}
```

另外要注意的是，默认的`print`，`println`和第一参数是`FILE*`的版本在自己的头文件`<print>`里面，第一参数是`ostream&`的重载在`<ostream>`里面（或者包含它的`<iostream>`也行）。而且目前只有输出——输入是与这个完全不同的另一个更难的话题，可以先用[scnlib](https://link.zhihu.com/?target=https%3A//github.com/eliaskosunen/scnlib)顶一顶。

### Ranges格式化输出：`cout`的缺憾

(1) Ranges的格式化输出支持 / Formatting Ranges

cppreference - [P2286R8](https://link.zhihu.com/?target=https%3A//wg21.link/P2286R8) - [[format.range]](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/format.range) - 2022.07

支持：GCC not yet, Clang not yet, MSVC not yet

测试：`__cpp_lib_format >= 202207L`

(2) 自定义容器的格式化支持 / Improve default container formatting

cppreference - [P2585R1](https://link.zhihu.com/?target=https%3A//wg21.link/P2585R1) - [[format.range.fmtkind]](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/format.range.fmtkind) - 2022.07

支持：GCC not yet, Clang not yet, MSVC not yet

测试：无（和P2286同期）

`printf`最大的功能缺陷是什么？注意我说的是_功能_缺陷，不是效率或者用法上的缺陷。我相信大部分人的回答都会是不支持第三方类型的格式化打印——不仅是自己写的类型不行，即使是标准中的各种`struct`也是没法打印的。这也是1994年的IOStreams库想要解决的最大问题之一——支持自定义类型的格式化输出。尽管`std::cout`有着这样那样的效率和用法（格式化）问题，但是不得不承认，`operator<<`的重载作为自定义类型的输出方式是一个十分方便的自定义手段。在ADL的帮助下，一个简单的`std::ostream& operator<<(std::ostream&, const A&)`就是自定义输出所需要的所有函数（我个人认为这种方式其实比`std::formatter<A>`的两个成员方法特化更方便）。

那么，`std::cout`的最大的功能缺陷是什么？格式化和自定义其实都不是答案，因为`<iomanip>`和`operator<<`的存在比较完善地实现了这两块功能（好不好用是另一回事，至少能用）。我认为，对大多数人来说（尤其是初学者），`cout`最大的功能缺失就是缺乏对于Ranges输出的默认支持。最简单的例子就是`std::vector<T>`——作为最常用的STL容器（没有之一），居然没法直接用`cout`输出，必须用一个循环来搞。（`std::string[_view]`的情况比较特殊，严格意义上来说它们是`char`的Range，但是它们从一开始就有输出支持）。`set`/`map`这样的关联容器更加难受，不光没有直接`cout <<`输出支持，而且即使用循环要实现在Python之类的语言司空见惯的`{1, 2, 3}`, `{1: 2, 3: 4}`这样的输出模式也是要费一点功夫的。至于任意Range（比如Ranges视图产生的那些），那就更别想了——在C++23初期修正之后，`views::split`是一个还算凑合的字符串分割函数；但是想要输出它们就很难受了——不过是一个`char`的Range，但是就是没法用`cout`直接输出。

C++20周期中，`std::format`取代了原来的IOStream库。不幸的是，由于WG21一向的最小化提案趋势，加入的`std::format`只有最基础的输出功能——甚至不如`cout`的功能（比如`std::complex<T>`是支持`cout`直接输出的，但是不支持`format`）。因此，现在的`std::format`仍然是不支持Ranges格式化的，比如`vector`之类的。不过，由于这个功能本来就是从成熟的{fmt}库中分离出来的，而后者早已提前支持Ranges的格式化，所以C++20的时候大家不是很着急——毕竟早晚会加进来。终于，在C++23将Ranges格式化放进最高优先级的几项Ranges功能之中之后，这一自从1994年以来已经等待了接近30年的特性终于成为了标准的一部分。当然，跟Old STL的情况一样，IOStreams的输出部分作为已经基本被弃用的库，也并没有得到这个更新——新的Ranges输出功能不会来到`std::cout`（所以不要用啦！），只会来到`std::format`，以及和它绑定的新`std::print[ln]`。

设计这种新功能，首先决定的其实应该是到底我们要支持什么样的类型，然后在标准库中提供它们的`std::formatter`特化。自然，所有现有的STL容器都应该被支持（现在支持的只有`basic_string[_view]`）。其实只要前进一步就几乎够了——我们希望支持所有的输入Range，这样因为所有的顺序和关联容器都拥有`begin()`和`end()`成员/全局函数支持，所以它们都是Range。但是，这一层抽象立刻带来了三个问题：

1. 虽然它们都是Range（而且至少都是前向Range，除了`forward_list`都是双向Range），但是顺序容器和关联容器还是有很大的一个区别——关联容器（比如`vector`）都是很简单的Range，比如`vector<T>`的元素类型就是`T&`（除了`T = bool`...这个一会再说）。但是，关联容器的元素类型对`set`系列来说还是`T&`，但是对于`map`系列都是`pair<const Key, Value>&`之类的东西。可是，关联容器并不应该用正常的Range打印方法来打印——要不然`map<int, int>`就会被简单地打印成`[(1, 2), (3, 4)]`这样，而我们实际上想要`{1: 2, 3: 4}`这样。`set<int>`也是一样，我们想要的是`{1, 2, 3}`而不是`[1, 2, 3]`。因此，关联容器实际上都需要自己的`std::formatter`特化来特殊输出这些东西。
2. 在扩展到任意输入Range的时候，一个重要问题就是什么样的Range我们应该支持？具体来说，如果Range的元素类型不能打印，那么自然整个Range也就不支持打印。那么`vector<bool>`的元素类型是`vector<bool>::reference`，这个类型不能打印的话，那`vector<bool>`本身也就不能打印了，所以提案中也为这个类型加上了打印功能。另外，对于一些特殊的元素类型（`char`和`string`），我们有可能有特殊要求——比如一个`char`的序列是不是应该提供一种方法，把这种序列按照`string`打印出来？以及以这两种类型作为元素的Range是不是需要转义？比如`vector<string>{"abc", "def", "\n2\n"}`就应该打印成`["abc", "def", "\n2\n"]`而不是真把换行符打印出来（也就是序列应该实现类似于Python `repr()`的效果而不是`str()`）。最后，SG16在review中也提出了一个问题：`filesystem::path`这个类型是一个病态的Range，它的元素类型是它自己；所以如果允许它格式化有可能产生循环依赖。这怎么办？
3. 另一个问题就是STL容器库中除了关联和顺序容器，还有容器适配器这一个类别——也就是`queue`, `stack`和`priority_queue`。这三个类型**并不是**Range——它们都没有`begin()`和`end()`函数。但是它们都有底层Range，也就是它们适配的底层容器。从可用性的角度来看，直接能够打印出一个队列或者栈中的元素是很诱人的功能，之前其实很难直接看到队列或者栈中有什么东西的。

因此，综合以上的讨论，最后P2286为标准库增加的格式化功能有这些：首先是通用的针对任意输入Range的格式化支持，要求是：

- 输入Range
- 元素类型可以格式化（即支持`std::formatter`）
- 元素类型（去掉cvref）不是Range类型自己

这也就包含了所有的顺序容器以及视图结果。除此之外，标准库加入了下述类型的`std::formatter`特化来支持特殊功能：

- `std::vector<bool>::reference`，为了让`vector<bool>`本身可以使用通用方法直接格式化
- `std::pair`和`std::tuple`，为了让`map`之类的容器可以格式化
- 所有的关联容器（`set`/`map`以及无序系列，包括新的平坦容器）和相似类型。这里的相似类型是直接探测容器内部是不是有`key_type`和`mapped_type`类型定义，再加上元素类型是`pair`或者大小为2的`tuple`；如果两个都满足就会按`map`进行格式化，只有`key_type`就会按照`set`
- 三个容器适配器

而在**默认情况下**（即`std::format("{}", some_container)`这样不提供任何格式符的用法），这些东西的格式化结果是：（其实基本和Python一样）

- 通用情况下，任意输入Range会被格式化成`[item1, item2, ...]`，使用方括号。例子：`vector{2, 3, 4}`的格式化结果就是`[2, 3, 4]`
- `vector<bool>::reference`的格式符支持和结果和`bool`完全一致
- `std::pair`和`std::tuple`的格式化结果是`(item1, item2, ...)`，使用圆括号。例子：`tuple{2, 2.0}`的格式化结果就是`(2, 2.0)`
- `set`系列（有序/无序/平坦，包括`multiset`）的格式化结果是`{item1, item2, ...}`，使用花括号。例子：`set{2, 3, 4}`的格式化结果就是`{2, 3, 4}`
- `map`系列（有序/无序/平坦，包括`multimap`）的格式化结果是`{key1: value1, key2: value2, ...}`，使用花括号和冒号分隔键值。例子：`map{pair{1, 2}, pair{3, 4}}`的格式化结果就是`{1: 2, 3: 4}`
- 三个容器适配器的格式符支持和结果与底层容器完全一致（**注意！**`priority_queue`的格式化结果并不保证有序）
- 对于上面所有的Range情况（通用Range，`pair`/`tuple`, 关联容器，容器适配器），当Range元素类型（或者键/值类型）是`char`/`string`的时候，元素会按带引号的转义形式展示出来。比如说，`vector{'H', 'i', '\n'}`的格式化结果就是`['H', 'i', '\n']`, 不是`[H, i, <CR>]`，而`map<int, string>{{1, "Hello!"}, {2, "Yes\tMadam"}}`的格式化结果也就是`{1: "Hello", 2: "Yes\tMadam"}`（转义的更多信息在下面）
- 对于自定义容器，用户也可以特化`ranges::format_kind<R>`为`ranges::range_format::{disabled, map, set, sequence, string, debug_string}`之一，来按照对应的类型自动格式化自己的容器。

而所有这些例子其实都支持各种各样的格式符来更改输出。首先，最重要的一点是所有支持的情况都和其他标准类型有着一样的行宽/对齐/填充格式符支持，因此我们可以直接用（比如说）`int`的格式符来用：

```cpp
std::println("=={:<15}==", std::vector{1, 2, 3}); // 行宽15左对齐
// ==[1, 2, 3]      ==
std::println("=={:*^15}==", std::vector{1, 2, 3}); // 行宽15居中，用*填充
// ==***[1, 2, 3]***==
```

主要的区别在于类型格式符（就是`{:d}`作为整形，`{:e}`浮点科学型那个字母格式符）以及Ranges独有的元素格式符。

其中，`vector<bool>::reference`和`bool`的格式符支持完全一样，容器适配器和底层容器支持一样，而关联容器和通用情况的格式符支持完全一样（它们只是更改了输出的外包围符号/分隔符）。因此，实际上只有两种情况需要介绍：通用Range格式符和`pair`/`tuple`元组格式符。

`pair`/`tuple`的情况比较简单，它们不是Range，所以没有元素格式符这一部分，支持的类型格式符也比较少，只有这些：（注意所有类型格式符都是互斥的）

- `?`, 调试格式符，在这种情况下是无效的（也就是输出不会变）
- `n`, 这个格式符会去掉外包装（也就是那一对括号），这样你就可以自己想输出什么包装就输出什么包装
- `m`, 字典格式符，仅对于`pair`和大小为2的`tuple`有效；会按照`k: v`而不是正常的`(k, v)`打印。

```cpp
std::println("{}", std::pair{1, 2}); // (1, 2)
std::println("{:?}", std::pair{1, 2}); // (1, 2)
std::println("{:n}", std::pair{1, 2}); // 1, 2
std::println("[{:n}]", std::pair{1, 2}); // [1, 2]
// 这样就可以输出任意包装
std::println("{:m}", std::pair{1, 2}); // 1: 2

using namespace std::literals;
std::println("{}", std::tuple{1, 2, "Hi"s}); // (1, 2, "Hi")
std::println("{:?}", std::tuple{1, 2, "Hi"s}); // (1, 2, "Hi")
std::println("{:n}", std::tuple{1, 2, "Hi"s}); // 1, 2, "Hi"
std::println("[{:n}]", std::tuple{1, 2, "Hi"s}); // [1, 2, "Hi"]
// 这样就可以输出任意包装
std::println("{:m}", std::tuple{1, 2, "Hi"s}); // 编译错误
```

对于现有的`char`和`string[_view]`格式符，也会新增一个`?`调试格式符，从而让这两个类型按照转义之后的样子打印出来：

```cpp
std::println("{}", 'A'); // A
std::println("{:?}", 'A'); // 'A'
std::println("{}", "ABC"); // ABC
std::println("{:?}", "ABC"); // "ABC"
```

转义规则本身比较复杂，知道双引号在`string`中被转义，单引号在`char`中被转义，`\t\n\r\\`这四个字符按照这里写的样子转义，所有剩下的Unicode `Separator`/`Other`/非打印字符都会按照`\u{XX}`（见上面的P2290介绍）转义就行了。非法Unicode字符会按照`\x{XX}`转义。

而对于一个通用情况的输入Range（包括关联容器）来说，类型操作符有下面这些：

- `s`，仅适用于`char`的Range，会将Range看成`string`输出（相当于转换成`string_view`）
- `?s`，仅适用于`char`的Range，会将Range看成`string`+调试（转义）输出
- `m`，仅适用于元素类型是`pair`或者大小为2的`tuple`，按照`{k1: v1, k2: v2}`（用花括号包围，每个元素应用`m`格式符）输出
- `n`，同样，去掉外包装来让你可以用任何格式输出
- `nm` （不能反过来），`n`和`m`的合体，按照`k1: v1, k2: v2`无花括号输出。

```cpp
std::println("{}", std::vector{1, 2, 3}); // [1, 2]
std::println("{:s}", std::vector{1, 2, 3}); // 编译错误
std::println("{:?s}", std::vector{1, 2, 3}); // 编译错误
std::println("{:n}", std::vector{1, 2, 3}); // 1, 2
std::println("({:n})", std::vector{1, 2, 3}); // (1, 2)
// 这样就可以输出任意包装
std::println("{:m}", std::vector{1, 2, 3}); // 编译错误

std::println("{}", std::vector{'H', 'i', '!', '\n'}); // ['H', 'i', '!', '\n']
std::println("{:s}", std::vector{'H', 'i', '!', '\n'}); // Hi!
// 上一条后面会有一个空行，因为输出的是Hi!加一个换行符
std::println("{:?s}", std::vector{'H', 'i', '!', '\n'}); // "Hi!\n"
std::println("{:n}", std::vector{'H', 'i', '!', '\n'}); // 'H', 'i', '!', '\n'
std::println("({:n})", std::vector{'H', 'i', '!', '\n'}); // ('H', 'i', '!', '\n')
// 这样就可以输出任意包装
std::println("{:m}", std::vector{'H', 'i', '!', '\n'}); // 编译错误

std::println("{}", std::vector<std::tuple<int, std::string>>{{1, "One"}, {2, "Two"}}); // [(1, "One"), (2, "Two")]
std::println("{:s}", std::vector<std::tuple<int, std::string>>{{1, "One"}, {2, "Two"}}); // 编译错误
std::println("{:?s}", std::vector<std::tuple<int, std::string>>{{1, "One"}, {2, "Two"}}); // 编译错误
std::println("{:n}", std::vector<std::tuple<int, std::string>>{{1, "One"}, {2, "Two"}}); // (1, "One"), (2, "Two")
std::println("({:n})", std::vector<std::tuple<int, std::string>>{{1, "One"}, {2, "Two"}}); // ((1, "One"), (2, "Two"))
// 这样就可以输出任意包装
std::println("{:m}", std::vector<std::tuple<int, std::string>>{{1, "One"}, {2, "Two"}}); // {1: "One", 2: "Two"}
std::println("{:nm}", std::vector<std::tuple<int, std::string>>{{1, "One"}, {2, "Two"}}); // 1: "One", 2: "Two"
std::println("[{:nm}]", std::vector<std::tuple<int, std::string>>{{1, "One"}, {2, "Two"}}); // [1: "One", 2: "Two"]
```

除此之外，Ranges的格式化支持还有自己的元素格式符，也就是对每一个元素提供的格式符。它们的指定方式是在写完Range本身的格式符之后加一个冒号，然后写元素格式符。比如说：（注意在类型格式符是`s`或者`?s`的时候不能提供元素格式符）

```cpp
std::println("{::<10}", std::vector<std::string>{"Hello", "World"});     // [Hello     , World     ]
// 本身的格式符为空，元素格式符是<10
std::println("+{:n:<10?}+", std::vector<std::string>{"Hello", "World"}); // +"Hello"   , "World"   +
// 本身的格式符为n，元素格式符是<10?
std::println("{::#x}", std::vector{42, 10}); // [0x2a, 0xa]
```

甚至，因为元素格式符本身就是直接传递给每个元素的`std::formatter`的，我们可以嵌套Range格式符：

```cpp
std::println("{:::d}", vector{vector{'a'}, vector{'b', 'c'}}); // [[97], [98, 99]]
std::println("{:*^22:n:#x}", vector{vector{'a'}, vector{'b', 'c'}}); // **[0x61, 0x62, 0x63]**
```

那么，这些都是在说标准库自带的Ranges格式化API。如果想要自定义类型也支持这样的Ranges格式化符应该怎么做呢？首先，P2286提供了一个Concept `std::formattable<T>`，用来探测类型是否可以格式化（用在`pair`之类的地方），然后重头戏是`std::range_formatter<V>`这个API。这是一个Range格式化类的通用父类，`V`是Range的元素类型。这个类会用`formatter<V>`进行元素的格式化，然后在其上自动处理上面提到的所有Range格式化符。与此同时，除了`format()`和`parse()`以外，`range_formatter`还提供了`set_separator`（分隔符），`set_brackets`（前后包装符）和`underlying`三个成员函数，让自定义类型可以很轻松地支持新的格式化符。

当然，P2286本身也并不是完整的。有三大方面可以继续加强：

1. 更多的类型支持。在支持了`pair`和`tuple`之后，一个正常的外推是支持sum types，也就是`optional`/`variant`/`any`/`expected`这些的输出。目前这方面的主要障碍是谁也不知道空`optional`应该输出什么
2. 指定分隔符。`set_separator`的存在让自定义类可以很容易地指定分隔符，但是问题是上面那一堆Range格式化符中并没有哪个能够指定分隔符（只能指定元素怎么格式化），也就是说没有任何specifier可以让`std::format(specifier, std::vector{1, 2, 3})`得到`[1-2-3]`这种东西——这个问题有两个解决方式，一种是用一个辅助函数，即`fmt::join`来指定分隔符，另一种方案是指定一个新的Range格式化符来直接在specifier中指定分隔符。后一种可能性的存在也是为什么`fmt::join`没能跟着P2286一起标准化——虽然写出`fmt::join`的实现极其简单（用`range_formatter`做底层，30行左右就够了）
3. `pair`和`tuple`的元素格式符。这两个类型因为元素类型有可能不一样，无法使用普通Range的元素格式符，连带着`std::map`之类的Range也没法指定具体每个元素的格式化方式。这方面的格式符语法就要在以后制定了。

### `std::expected`：新时代的异常处理方式

`std::expected`

[cppreference](https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/utility/expected) - [P0323R12](https://link.zhihu.com/?target=https%3A//wg21.link/P0323R12) - [[expected]](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/expected) - 2022.02

支持：GCC 12, Clang not yet, MSVC 19.33

主要头文件：`<expected>`

测试：`__cpp_lib_expected >= 202202L`

这个提案历经8年，15个Revision，终于成为现实，即使在T1中也算比较长时间的了。而且可以说是经典的Boost库进入标准的例子，最后基本上按照Boost.Outcome的设计来了。

Sum types是一个C++长久以来的热门话题。简单的说，sum type是两种（或者多种）类型中的选择——在同一时刻最多有多种可能类型中的一个。C/C++中最经典的sum type就是union：

```cpp
union U
{
    int a;
    double d;
};
```

一个`U`类型的变量在同一时刻一定是一个`int`或者一个`double`，不可能都不是也不可能都是。这种sum type在实际运用中也很常见——比如比较典型的，函数返回值有可能是多种类型之一，或者一个参数位有可能是多种不同的类型。

在以前，C++标准中一直只有内置的union一种sum type，而union是类型不安全的——没有针对访问非活动类型的保护或者检查。在C++17中，标准库一口气加了三种不同的类型安全sum type——

- `std::optional<T>`——其他语言的`Optional`或者`Maybe`或者`Nullable`，有可能是空的，有可能包含一个类型`T`的对象（即一个可空的`T`）。在可空（有默认值）的参数，或者函数计算一个可能有也可能没有的值十分常用，比如应用在空Range上的`fold`。访问一个空的`optional`会抛异常。
- `std::variant<T1, T2, ...>`——即一个类型安全版本的`union`。有可能是空的（`valueless_by_exception()`）或者包含一个`T1`或者`T2`或者...的对象（多个类型之一）。试图以`T2`形式访问一个包含`T1`的`variant`会抛异常。
- `std::any`——即一个类型安全版本的`void*`。这是一个有可能包含任意类型的东西（可以理解成尖括号里有所有可能类型的`variant`），试图以非原始类型访问一个`any`会抛异常。

在C++23中，我们迎来了第四个sum type——`std::expected<T, E>`。这个东西有点像`optional<T>`和`variant<T, unexpected<E>>`的结合体。可以理解成这个类型扩展了`optional<T>`——`optional<T>`是有可能存放一个`T`，或者有可能是空的（即存放一个`std::nullopt_t`）。`expected<T, E>`是有可能存放一个正常值`T`，或者有可能存放一个异常值`E`。这里的`E`是一个预料之外的值，常常是一个错误码或者异常指针之类的，当然也可以是一个带错误信息的字符串之类的。自然，最常用的地方就是返回值——有一大堆函数（C函数和不少C++都是）都是有可能出现异常值的，现在C++有三种主要处理异常的方法：

- 从C继承而来的错误码，即最原始的`errno`全局变量，和C++11引入的`std::error_code`之类的。主要优点是效率极高，直接用来做返回值即可。缺点是会占用返回值通道（很多时候必须做输出参数，比如`from_chars`）并且容易被忽略（多少人不检查`open`之类的返回值和`<cmath>`的`errno`...），而且要把返回值不处理传递给上层函数比较麻烦。
- C++的异常，有语言支持（`throw`和`try/catch`），因此主要优点是不会占用返回值通道，无法被忽略，也很容易传递给上层函数。最大的缺点就是效率比较低，而且容易生成很多额外的异常控制流代码量。而且如果没有深入贯彻RAII，异常导致的资源泄漏也是问题。
- 现在新来的第三种：`std::expected<T, E>`。算是结合了两者的优点，不会占用返回值通道（同时可以返回正常值和异常值），无法被忽略（要用返回值就必须检查，要不然抛异常），而且如果有Monadic Interface的话也很容易传递回上层函数。最大的缺点是会引入分支导致效率没有错误码高，以及更多模版使用可能带来代码膨胀。

`expected<T, E>`内部和`variant`基本一样，使用了一个`union`来包裹两个类型节省空间，并加上了类型安全的外壳。但是它的外部和`optional`很像，要取用正常值可以直接用`value()`或者更加直接的`operator*`和`operator->`。它相当于是在`optional`基础上增加了对异常值的访问——可以使用`error()`来访问异常值。构造方面，因为大部分时候我们想返回正常值，因此`expected`和`optional`一样选择了允许从`T`的隐式构造，而从异常值的构造使用了一个辅助类型`std::unexpected`。看下面的简单例子：

```cpp
std::expected<int, std::errc> svtoi(std::string_view sv)
{
    int value{0};
    auto [ptr, ec] = std::from_chars(sv.begin(), sv.end(), value);
    if (ec == std::errc{})
    {
        return value;
    }
    return std::unexpected(ec);
}
```

这是一个简单的`string_view`转`int`的函数。我们知道`from_chars`是有可能出错误的，因此返回值实际上是一个指针+错误码的结构体，而实际上的最终输出值也就只能通过输出参数来做了。要注意的是`value`作为正常值可以直接返回，但是异常值就需要用`std::unexpected`来包一层。在使用方面，我们可以这么干：

```cpp
auto ret = svtoi("1234");
if (ret) // OR ret.has_value()
{
    // ret has a normal value
    auto value = *ret; // -> also works for class type
    // OR
    auto value2 = ret.value(); // not recommended, see below
}
else
{
    auto error = ret.error();
}
```

可以直接通过判断`bool`或者`has_value()`来判断是正常值还是异常值，正常值如果使用`value()`来获取会在内部再进行一次检查（如果当前是异常值会抛一个`bad_expected_access<E>`类型的异常），`operator*`就不会，所以建议使用后者；`error()`没有这个问题。

要注意的几点是：

- 正如刚才所说，`value()`会检查是不是正常值，如果不是会抛一个异常。`error()`则不会，如果不是异常值（有正常值）就是UB。这么设计的原因是和`optional`统一，而且`operator*`也能提供快速的获取正常值的方法。
- 注意`T`和`E`是可以一样的——有`unexpected`包裹一层之后不会有冲突。
- 和`optional`一样，有`value_or()`函数来提供一个额外的功能：有正常值取正常值，否则取一个默认值。
- `expected`为了作为返回值，`T`是可以是`void`的，来表示“没有正常值但是有可能有异常值”的情况。这时候`value()`成员返回`void`。
- 更多的辅助功能可以看下面要介绍的Monadic Interface。

### `std::generator`：Coroutines ❤️ Ranges

`std::generator`: Synchronous Coroutine Generator for Ranges

cppreference - [P2502R2](https://link.zhihu.com/?target=https%3A//wg21.link/P2502R2) - [[coro.generator]](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/coro.generator) - 2022.07

支持：GCC not yet, Clang not yet, MSVC not yet

主要头文件：`<generator>`

测试：`__cpp_lib_generator >= 202207L`

（看着Revision很少？那是因为这是D2168R4的接续提案，实际上R2就是R7）

到这里，我们到了[C++23计划](https://link.zhihu.com/?target=https%3A//wg21.link/P0592R4)中的两个最终实现了的目标。一个是`import std`，一个就是`generator`。`generator`可以说是C++20四大特性之二，Coroutines和Ranges的结合体，也是90%人使用Coroutines最常用的类型。它本身实现比较简单，但是众所周知C++20对Coroutines的库支持基本等于没有，这也算是补全了缺失的很大一部分库支持。（PS：不出意外的话，这也是整个C++23周期唯一的Coroutines相关特性——`std::lazy`没能进来）

这个提案就是经典的同步生成器/generator——将你用`co_yield`传递给Coroutines的所有东西收集起来，成为一个输入Range。看一下例子：

```cpp
std::generator<int> fib()
{
    auto a = 0, b = 1;
    while (true)
    {
        co_yield std::exchange(a, std::exchange(b, a + b));
    }
}
```

简单的说就是所有`co_yield`的东西收集起来成为一个容器返回，让你可以遍历。使用上也很简单，因为这是一个无穷Range我们不能直接上Range for-loop，可以用Ranges库的工具处理一下：

```cpp
for (auto a : fib() | views::take(5))
{
    std::println("{}", a);
}
```

要注意的是，WG21在2022年初针对generator吵了一些架，最终决定：像这样最基础的`generator<T>`会默认返回右值，也就是上面的`fib()`的返回值实际上是一个`int&&`的Range。这么做最大的优点就是支持move-only type做为返回值——比如说`co_yield`一个`unique_ptr`。下面会谈这么做的一些问题。

这个`generator`作为标准库版本，支持了递归的`generator`——即可以递归地将内层函数返回的`generator`返回给外层。语法上为了避免歧义，加上了一个包装类型：

```cpp
std::generator<int> my_wrap()
{
    co_yield ranges::elements_of(fib());
}
```

当然，这个`elements_of`也不只支持`generator`，可以放任意Range——`elements_of(some_vector)`也是可以的，就不用写个循环挨个`co_yield`了。对称传递和HALO优化的实现让这样的递归`generator`也能有很高的效率。

要注意几点——

- 如果`T`不是引用，`generator<T>`默认的引用类型就是`T&&`，也就是说像`auto val = *fib().begin()`这样的调用会把那个`int`移动进`val`里面（即那个内部Range也就不再拥有这个`int`了，不过反正是输入Range不太可能有什么问题）。这有可能带来一些问题，这时候你可以自己指定`generator<const T&>`，`generator<T&>`，或者指定第二参数：`generator<T, U>`，第二参数会成为值类型，第一参数会是引用类型。另外，想要指定自己的分配器的可以放第三参数，`generator<T, void, Alloc>`即可（`void`表示让引用类型保持默认）。当然三个参数都提供也是可以的。
- 要注意的是，`generator`是一个输入+右值Range，还是个move-only类型——可以说是C++中最难搞的类型之一。输入Range很容易理解——和`ranges::istream_view`一样，Coroutine本质上只是暂停了函数的执行，遍历到Range的下一个元素就是让函数继续执行，所以不可能让你返回上一个元素或者重新遍历一遍。这边要注意的是有些算法和适配器可能不能用在输入Range或者会产生意外结果（比如`views::cartesian_product`的非首位Range之类的）。用的时候也要注意只能单遍遍历。
- 右值Range算是个新概念——C++23周期做的bugfix之一就是让很多Ranges设施支持右值，这样大部分东西都是just works。不过仍然有很多要注意的地方。比如说

```cpp
auto res = fib();
auto it = res.begin();
auto val = *it;
```

这里`val = *it`就是一个移动——尽管看不出来（没有`std::move`调用），Range内部的值已经没了，再来`auto val2 = *it`就会得到无效值。另外有些Ranges适配器（比如`views::filter`）对右值引用的支持也不太好——`filter`会对每个元素调用函数，所以你的函数得是接受`T&&`作为参数才不会出问题——看这个例子

```cpp
std::generator<std::string> some_func();
for (auto str : some_func() | views::filter([](auto a) {return a.size() > 5;})) // OOPS
{
    // str is empty (moved-from) here
}
```

如果函数是值类型参数的，那么内部的右值`string`就会直接被移动到函数参数里面去——Range内部的值就没了，所以循环体内部`str`会是一个空的（不一定）`string`。要解决这个问题，要么用`string&&`或者`auto&&`做参数（我推荐所有filter函数用`auto&&`），要么改用`std::generator<const std::string&>`。

- 要注意的是，`std::generator`还是move-only的——和`std::cin/cout`之类的一样（原因也一样，Coroutine Handle没法拷贝）。所以把它传递给函数得用引用。
- 另外，虽然值类型是右值，你还是可以`co_yield`左值——会自动做一个拷贝，这样Range内部的右值引用就会引用到拷贝上。
- 在某些平台上面，递归`generator`可能有一定性能损失（这也是为什么不能直接`co_yield`一个generator，要用`ranges::elements_of`包一层）——不过如果HALO不够好Coroutine本身就有性能损失。

### `ranges::to` & 容器Ranges支持：补全C++20 Ranges的最大缺憾

(1) `ranges::to`与容器Ranges支持

[cppreference](https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/ranges/to) - [P1206R7](https://link.zhihu.com/?target=https%3A//wg21.link/P1206R7) - [[range.utility.conv.to]](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/range.utility.conv.to) - 2022.02

支持：GCC not yet, Clang not yet, MSVC not yet

主要头文件：`<ranges>`与各个容器头文件

测试：`__cpp_lib_ranges_to_container >= 202202L` (`ranges::to`)，`__cpp_lib_containers_ranges >= 202202L` (容器Ranges支持)

(2) `std::stack`与`std::queue`的迭代器对构造函数 / Iterators pair constructors for stack and queue

[cppreference](https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/container/stack/stack) - [P1425R4](https://link.zhihu.com/?target=https%3A//wg21.link/P1425R4) - [[queue.cons]/3](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/queue.cons%233), [[stack.cons]/3](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/stack.cons%233) - 2021.06

支持：GCC 12, Clang 14, MSVC 19.31

主要头文件：`<stack>`, `<queue>`

测试：`__cpp_lib_adaptor_iterator_pair_constructor >= 202106L`

在上大菜之前，先说一下P1425R4这个小bugfix——这是P1206这个大提案的写作过程中发现的小问题。我们知道，STL的容器构造算是千奇百怪，`vector`有接受初始大小，`map`之类的有`pair`的初始化列表构造等等。不过各种STL容器有一个共同点：除了默认构造函数以外，所有STL容器都有一个从迭代器对（即Old STL的Range表示形式）构造的函数，让我们可以从任意（输入）Range来构造：

```cpp
std::list<int> l{1, 2, 3, 4};
std::vector<int> v(l.begin(), l.end());
```

不过——可能很少有人知道，STL中有两个容器是没有迭代器对构造函数的。这两个容器是`stack`和`queue`，而主要原因就是它们（和`priority_queue`）是一类特殊的STL容器——容器适配器。这三个容器本身并不存储元素，而是将别的容器（默认来说，`stack`和`queue`是`deque`双向队列，`priority_queue`是包装`vector`）进行包装，从而提供特殊的数据结构（栈，队列和优先队列）。正因如此，`priority_queue`由于底层不进行连续存储（保持排序），从而保留了迭代器对构造函数；但是`stack`和`queue`由于底层的连续结构，没有提供这个迭代器对的构造函数。不过，在`ranges::to`的设计过程中，发现依赖这个几乎所有STL容器都统一有的构造函数来传递Range会更好，所以C++23干脆改正了这个25年前的疏忽——现在`stack`和`queue`有迭代器构造函数了。所以我们也可以

```cpp
std::stack<int> s(l.begin(), l.end());
```

现在来说甜点，也就是`ranges::to`（哈！这可不是主菜，P1206R7作为86页的庞大提案，80%以上的内容都在主菜容器的Ranges支持上面，不过`ranges::to`实在是C++20 Ranges库的一个很大缺陷，所以先说这个）。

在C++20中，Ranges引入了不少适配器（也就是Ranges Views/视图），能够对一个Range进行各种lazy的操作，而不会有任何负担——

```cpp
std::vector<int> vec = /* ... */;
auto res = vec | views::filter([](auto a) {return a > 5;})
               | views::transform([](auto a) {return a * 2;})
               | views::take(3);
// 到这为止，这些操作都还没有执行
for (auto a : res) // 到这里才真正执行三个操作
{/* ... */}
```

这里我们只`take`了前三个值，所以只需要找到前三个满足filter条件的元素，也只需要执行三次transform，不用把整个vector都遍历一遍。不过，对于结果的视图来说，我们自然能够用range-for遍历，也可以用`begin()`/`end()`之类的传统迭代器方法来访问，不过我们并没有一个很好的把结果存放进容器的方法——看了上面的介绍，一个自然的选择是

```cpp
std::vector<int> result(ranges::begin(res), ranges::end(res));
```

抛开这需要两句话，而且调用`begin()`显得有点繁琐不说，这并不一定能编译——迭代器对构造函数是一个Old STL产物，它要求的是迭代器对模型，而不是C++20的新迭代器-哨兵模型，所以对于很多迭代器（`begin()`）和哨兵（`end()`）类型不一样的情况（按Ranges术语就是，非common）就会失效。这种情况最简单的解决方案就是在`res`右边的最后加上一个`| views::common`——能够包装一下把非common Range变成common Range的适配器。即使这样仍然不一定能成功构造，因为`views::common`并不支持纯C++20的输入Range——举个例子

```cpp
std::generator<std::pair<const int, std::string>> fun();
auto v = fun();
std::map<int, std::string> m(ranges::begin(v), ranges::end(v));
```

这里不能`fun() | views::common`，因为`generator`不可拷贝——在这种情况下，我们就只能

```cpp
std::map<int, std::string> m;
ranges::copy(v, std::back_inserter(m));
```

更繁琐了。现在，C++23从range-v3中拿来了这种情况下的完美解决方案——`ranges::to`来将视图实体化成容器：

```cpp
auto res = vec | views::filter([](auto a) {return a > 5;})
               | views::transform([](auto a) {return a * 2;})
               | views::take(3);
auto vec2 = res | ranges::to<std::vector>();
// or ranges::to<std::vector>(res)
std::generator<std::pair<const int, std::string>> fun();
auto m = fun() | ranges::to<std::map>(); // 支持右值
// OR
auto m = fun() | ranges::to<std::map<int, std::string>>(); // 可以指定元素类型来做转换（上面都是自动推导的）
```

实际上，`ranges::to`的能力更加强大——它是从任意Range到任意容器的通用算法。因此，我们可以用它来拷贝容器

```cpp
std::list<int> l;
auto v = l | ranges::to<std::vector>();
// 还支持递归变化
std::list<std::map<int, std::string>> lm;
auto v = l | ranges::to<std::vector<std::vector<std::pair<const int, std::string>>>>();
```

这里要注意的一点是省略元素类型只能在最上层使用——不能写`to<vector<vector>>`什么的。另外和range-v3不一样的一点是这里必须使用`to<vector>()`，不能省略空括号，而range-v3可以；不过WG21正在讨论要不要改进这个略显繁琐的细节。`to`的内部实现会在下面讨论。

下面终于到了主菜——容器的Ranges支持，这也是P1206R7中最主要的篇幅所在。众所周知，狭义上的STL主要有三个部分——算法，迭代器和容器。C++20 Ranges（STL2）的引入完全更新了算法和迭代器部分，不过并没能更新容器部分——主要是Ranges是对迭代器的上层抽象，对容器并没有特别的关系，只是通过`begin`/`end`这层把所有容器抽象成了Range的特殊情况，并没有特意更新容器的成员函数。现在，这一部分缺失终于补上了。

简单的说，对于每一个接受迭代器对的函数（包括构造函数），都增加了一个Range版本——也就是只接受一个参数作为Range。另外，对于我们很熟悉的`push_back`和`push_front`两个函数，也增加了它们的Ranges版本，解决了长久以来难以直接在尾部append一个Range的问题。具体来说：（注意`std::array`在这个语境下并不算STL容器）

- 对于有迭代器对构造函数的（P1425R4之后是所有）STL容器，增加一个Range的构造函数——因为有歧义是要带tag调用，也就是`Container(from_range, r)`。
- 对于有`insert(pos, beg, end)`方法（`forward_list`是`insert_after`）的所有容器，即除了三个STL容器适配器（`stack`/`queue`/`priority_queue`）之外的所有STL容器，添加一个`insert_range(pos, r)`（`forward_list`是`insert_after_range`）方法。
- 对于有`push_back(elem)`方法的`vector`, `deque`, `list`和`basic_string`，各自添加一个`append_range(r)`方法。
- 对于有`push_front(elem)`方法的`deque`, `foward_list`和`list`，各自添加一个`prepend_range(r)`方法。
- 对于有`assign(beg, end)`方法的`vector`, `deque`, `forward_list`, `list`和`basic_string`，各自添加一个`assign_range(r)`方法。
- 对于有`replace(beg1, end1, beg2, end2)`方法的`basic_string`，添加一个`replace_with_range(beg1, beg2, r)`方法。

其实就是把所有方法的迭代器对化成Range。看一些例子：

```cpp
std::vector<int> vec{2, 3, 4};
std::list<int> l{std::from_range, vec}; // Range构造函数
std::set<int> s{std::from_range, vec | views::take(2)};
l.append_range(s);
std::vector<int> vec2{3, 3, 3};
vec2.insert_range(vec2.begin() + 1, l);
std::list<int> l2{std::from_range, vec2};
l2.prepend_range(s);
s.assign_range(vec2);
std::vector<char> lc{'a', 'b', 'c'};
std::string str = "22222";
str.replace_with_range(str.begin() + 1, str.begin() + 3, lc);
```

当然分配器和比较函数作为默认参数也是支持的。`ranges::to`的实现就是依赖于这些Ranges支持。它会先尝试`from_range_t`-tagged Range构造函数，然后尝试迭代器对函数，然后尝试一个个插入到末尾来最大化效率。

要注意的点是：

- Range构造函数需要一个tag， `std::from_range`（类型是`std::from_range_t`）。
- 注意这些方法都有对完整Range的访问，所以往往可以实现更高效率的算法（比如事先reserve足够空间避免多次分配）。因此，在能用Ranges方法的时候就应该用，`ranges::to`也会优先尝试Ranges方法（正如能用STL2工具就不要用Old STL）。
- 注意这些方法和Ranges算法不太一样，只有Range重载，没有迭代器-哨兵重载，所以如果你有迭代器-哨兵对的话可以用`ranges::subrange`包一层。
- 指向容器内部的迭代器对是没有Ranges重载的，因为它们被限定了迭代器类型。也就是说没有`erase_range`，`replace_with_range`也只有第二个迭代器对被换了。
- `prepend_range`**不会**反转传入Range的顺序（也就是说不是一个个`push_front`，是整体`prepend`）

### `mdspan`：多维数组视图

`mdspan`

cppreference - [P0009R18](https://link.zhihu.com/?target=https%3A//wg21.link/P0009R18) - [[mdspan.mdspan]](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/mdspan.mdspan) - 2022.07

支持：GCC not yet, Clang not yet, MSVC not yet

主要头文件：`<mdspan>`

测试：`__cpp_lib_mdspan >= 202207L`

在C++20中我们迎来了`std::span`，一个一维数组的视图。引入`span`的主要目的还是取代传统C函数的“指针+长度”习惯：

```cpp
// from
void fun(int* arr, std::size_t len);
// to
void fun(std::span<int> arr);
```

这样既能确保不会丢失长度信息，减少一个参数，还能确保传入的长度大多数时候都是对的（毕竟大部分容器和Range直接传就行了，不用调用`data()`）。因此，`span`和`string_view`一样，大部分时候都是一个“参数类型”。

虽然是`span`的自然多维扩展，`mdspan`却是为了解决完全不同的另一个问题。这一区别的重要原因就是C（以及C++）中并没有原生的“多维数组”——有的只是一个看起来像多维数组的玩意`int a[N][M][K]`，但实际上完全不是一回事：

- 除了第一维以外都不能动态指定（VLA？别提那个东西...）
- 只支持连续存放（row major）格式，不能自己选择存放格式
- 没有边界检查
- 语法不太好：`a[i][j][k]`，而且不支持切片

C里还有一个看起来像那么回事的`int***`，但是这个三级指针并不能指向上面的“三维数组”，而且跟`span`一样会丢失长度信息，不支持编译期长度，而且需要多次内存分配+存放不连续导致效率低下。

在C++中我们还有一个看起来都不太像样的解决办法：`vector<vector<vector<int>>>`（编译期长度可以把其中一维换成`array<..., N>`）。撇开这个长类型名不说，这种解决办法仍然需要多次内存分配+存放不连续，而且多层嵌套模版的使用也让访问元素的inline化很难进行。

好了，C/C++目前并没有能用的多维数组类。那么`mdspan`一定解决了这个问题吧...？很遗憾，并没有，一个多维数组类要等到[mdarray](https://link.zhihu.com/?target=https%3A//wg21.link/P1684)提案进入C++26才能可用。在那之前，`mdspan`提供了一个假象——作为视图，它可以把一个一维数组模拟成多维数组，也就提供了一个还算可用的多维数组**接口**。（注意！内部实现（通常）还是个一维数组）

其实这种模式在现在也很多人用，也就是维度压缩。

```cpp
auto arr = std::make_unique<int[]>(N * M);
arr[M * row + col] // -> arr[row][col]
```

这样，我们就可以用`arr[M * row + col]`访问第`(row, col)`个元素。这样的维度压缩可以轻易推广到多维——而且因为底层是连续的一维数组，往往比专门的多维数组类效率更高。`mdspan`算是大幅度改进了这个已有的习惯用法——看：

```cpp
auto arr = std::make_unique<int[]>(N * M);
auto mds = std::mdspan(arr.get(), N, M);
mds[row, col];
```

现在就可以直接用`mds[row, col]`这样的便捷语法来访问了——如果是更多维的数组也可以`mds[i, j, k, l]`，不用自己算最后的索引了。

具体来说，为了实现最大的可定制性，`mdspan`提供了很多的策略类——主要是三个，Extent，Layout和Accessor。下面一个一个来说。

Extent就是索引类。这里的索引是`std::extents`的实例化，同时支持动态（运行期）索引和静态（编译期）索引的——使用的是和`std::span`一样的策略，用`dynamic_extent`这个特殊值来表示动态索引。举几个例子：

```cpp
std::extents<std::size_t, N, M> ext; // [N][M]
std::extents<std::size_t, N, std::dynamic_extent, 2> ext2(M); // [N][][2], 第二维动态索引 = M
std::extents<std::size_t, std::dynamic_extent, std::dynamic_extent> ext3(N, M); // [][], 动态索引 = N, M
```

（第一个参数是`mdspan::index_type`的值，即最终算出的索引类型，只是为了提高性能让你能够定制；大部分人`size_t`就行）。其实很简单，直接把所有编译期索引按顺序写成模版参数即可——如果某一维是运行期决定的，那么就放`std::dynamic_extent`作为占位符，而构造函数就可以传递进所有的运行期索引。注意多个`dynamic_extent`可能会名字很长，所以标准库提供了一个针对所有维度都是运行期决定的Extent类的别名：

```cpp
std::dextents<std::size_t, 2> == std::extents<std::dynamic_extent, std::dynamic_extent>
std::dextents<std::size_t, 3> == std::extents<std::dynamic_extent, std::dynamic_extent, std::dynamic_extent>
// 所以上面ext3可以写成
std::dextents<std::size_t, 2> ext3(N, M); // [][], 动态索引 = N, M
```

下面看Layout。这个策略类决定了数组元素的存放方式——可以是C/C++的row major，Fortran/MATLAB的column major，也可以是不连续的layout。本质上说，Layout就是一个`(i1, i2, i3, ...) -> index`从多个索引到一个实际索引的函数——比如说对于上面的压缩维度的二维数组，这个函数就是`(row, col) -> M * row + col`。`mdspan`自己提供了三种默认Layout：row major的`layout_right`（最右侧索引是连续存放的），column major的`layout_left`（最左侧索引是连续存放的），以及一个比较通用的`layout_stride`。不过要注意的是，`mdspan`实际上允许任意函数作为Layout，也就是说甚至可以让两个不同的多维索引指向同一个底层元素——不过标准库没有提供这种东西。在实际应用中，row-major和column-major两者应该已经覆盖了95%以上的用法，所以这里就不介绍自己写Layout定制策略的东西了。有兴趣的可以看看C++26的线性代数库提案。

Accessor是另一个策略类，它实际上是把一个指针+偏移量转换成对于实际元素的引用。因此，最简单的Accessor就是直接返回`p[i]`，这也是标准库的默认Accessor，`std::default_accessor<T>`的做法。提供这个定制点的主要原因是让你可以控制元素的访问，比如检查边界，或者加锁实现原子化访问，或者如果底层不是简单的一维数组的话可以在这里实现自己的访问算法。不过这个策略就比Layout用的还少——99%的人用默认的就够了。

有了这三个策略类的知识，`mdspan`的用法就很简单了：

```cpp
std::mdspan<T, Extent, Layout, Accessor>
```

第一参数是元素类型，后面三个依次是三个策略类。`Layout`默认是C++的原生数组，`layout_right`；`Accessor`默认就是`default_accessor<T>`，因此大部分人是不需要更改最后两个策略的（正如Allocator一样）。因此一般的用法就前两个参数就够了：

```cpp
std::mdspan<int, std::dextents<std::size_t, 2>> mds; // int[][]
std::mdspan<float, std::extents<std::size_t, 3, std::dynamic_extent, 4>> mds2; // float[3][][4]
```

构造函数的第一个参数就是指针（通常是个一维数组的指针）。如果你的Extent有动态索引，那么就在构造函数里面传进去就行：

```cpp
int* data = new int[/* ... */];
float* fdata = /* ... */;
std::mdspan<int, std::dextents<std::size_t, 2>> mds(data, 3, 3);
std::mdspan<float, std::extents<std::size_t, 3, std::dynamic_extent, 4>> mds2(fdata, 4); // float[3][4][4]
std::mdspan<int, std::extents<std::size_t, 3, 3>, std::layout_left> mds3(data); // no dynamic extent, row major
```

当然，CTAD往往是更方便的构造方法：`mdspan(data, 3, 3)`会推导出一个全是动态索引的`mdspan`，传入`extent`对象之后`mdspan(data, extent)`就会推导出对应的`mdspan`。至于访问，`mdspan`提供了`extent()`成员函数，你可以通过`mds.extent(0)`拿到第一维长度，`extent(1)`是第二维，以此类推；如上所见，实际元素可以通过`mds[1, 2]`的C++23的多维`operator[]`语法来访问。另外，如果你有一个`std::array`，也可以直接用`mds[arr]`访问。因此，一般就可以用多层循环访问：

```cpp
for (auto i = 0uz; i < mds.extent(0); ++i)
{
    for (auto j = 0uz; j < mds.extent(1); ++j)
    {
         // mds[i, j]
    }
}
```

或者酷一点，用Ranges视图访问：

```cpp
for (auto [i, j] : views::cartesian_product(
    views::iota(0, mds.extent(0)),
    views::iota(0, mds.extent(1))
))
{
    // mds[i, j]
}
```

至于具体有几维可以用`rank()`查询，有几维是动态的可以用`rank_dynamic()`（都是`constexpr`函数）。

`mdspan`很强大，也很能定制，甚至有些时候一个一维的`mdspan`比`span`更适合某些工作——不过还是要注意几点：

- `mdspan`是一个视图，它并不拥有元素本身，所以要保证使用时那个传入的指针是有效的
- `mdspan`没有Ranges支持，所以没有`begin()`/`end()`之类的，也不能直接在后面加Ranges视图。好在`data_handle()`倒是有，大不了操作底层一维数组

### 堆栈信息库：Finally

堆栈信息库 / A Proposal to add stacktrace library

[cppreference](https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/utility/basic_stacktrace) - [P0881R7](https://link.zhihu.com/?target=https%3A//wg21.link/P0881R7) - [[stacktrace]](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/stacktrace) - 2020.11

支持：GCC 12 (partial), Clang not yet, MSVC 19.34

主要头文件：`<stacktrace>`

测试：`__cpp_lib_stacktrace >= 202011L`

又是一个典型的Boost作为标准库前置的例子——Boost.Stacktrace库通过这个提案进入了标准。长久以来，Python的异常都会带堆栈信息，让查找具体的函数位置和调用层数非常方便；Java的异常也有`printStackTrace()`方法来打印具体的堆栈（函数调用链）。然而，C++的异常或者断言（C `assert()`）一直都只有一条错误信息，没有具体的函数调用链和行数。新的stacktrace库补上了这个缺陷，让以后的断言信息可以十分详细：（Boost.Stacktrace效果）

```cpp
Expression 'i < N' is false in function 'T& boost::array<T, N>::operator[](boost::array<T, N>::size_type)': out of range.
Backtrace:
 0# boost::assertion_failed_msg(char const*, char const*, char const*, char const*, long) at ../example/assert_handler.cpp:39
 1# boost::array<int, 5ul>::operator[](unsigned long) at ../../../boost/array.hpp:124
 2# bar(int) at ../example/assert_handler.cpp:17
 3# foo(int) at ../example/assert_handler.cpp:25
 4# bar(int) at ../example/assert_handler.cpp:17
 5# foo(int) at ../example/assert_handler.cpp:25
 6# main at ../example/assert_handler.cpp:54
 7# 0x00007F991FD69F45 in /lib/x86_64-linux-gnu/libc.so.6
 8# 0x0000000000401139
```

具体使用方面，目前stacktrace库和C++20的`source_location`一样，比较偏向于手动调用：你可以通过

```cpp
auto st = std::stacktrace::current();
```

拿到一个当前行的stacktrace。本质上，这样一个`stacktrace`对象内部是一个`vector`，每一个元素都是一个`stacktrace_entry`类型的条目，记载了上面一行中的内容：描述（`description()`），源码文件（`source_file()`）和行数（`source_line()`）。自然，既然内部是`vector()`，可以遍历：

```cpp
for (const auto& entry : st)
{
    std::println("{}: Line {}", entry.source_file(), entry.source_line());
}
```

而且整个stacktrace和stacktrace_entry都可以用ostream输出，或者用`to_string(st)`转成string，也都可以hash（`std::format`暂时不支持）。使用这个库要注意几点：

- `stacktrace_entry`默认构造是一个空的entry
- `to_string(st)`并不一定就是每行一个entry，没保证这点
- `stacktrace`实质上是`basic_stacktrace<allocator<stacktrace_entry>>`的别名，这里可以用自己的Allocator分配器
- 目前没有直接办法从抛出的异常拿到堆栈——要么等C++26的[Stacktrace from exception](https://link.zhihu.com/?target=https%3A//wg21.link/P2370)要么自己写一个内部存放stacktrace的异常类抛出吧
- 记录堆栈信息在一些平台上可能有可观的性能损失，尤其是在大项目中——很有可能大部分编译器都会有一个`-fno-stacktrace`之类的选项完全关闭堆栈记录，这时`current()`会返回一个空的stacktrace

### 平坦容器`flat_{map,set}`：10年后的新容器

(1) `flat_set` & `flat_multiset`

cppreference - [P1222R4](https://link.zhihu.com/?target=https%3A//wg21.link/P1222R4) - [[flat.set]](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/flat.set) - 2022.07

支持：GCC not yet, Clang not yet, MSVC not yet

主要头文件：`<flat_set>`

测试：`__cpp_lib_flat_set >= 202207L`

(2) `flat_map` & `flat_multimap`

cppreference - [P0429R9](https://link.zhihu.com/?target=https%3A//wg21.link/P0429R9) - [[flat.map]](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/flat.map) - 2022.07

支持：GCC not yet, Clang not yet, MSVC not yet

主要头文件：`<flat_map>`

测试：`__cpp_lib_flat_map >= 202207L`

STL作为C++标准库中最核心的组件（没有之一），主要包含三大板块：迭代器工具，算法和容器。在C++20中，随着Ranges库的加入，迭代器（种类，特征值）和算法都迎来了翻天覆地的变化，以至于沿用了22年的旧版STL迭代器/算法已经几乎被废止了。然而，容器在这一浪潮中并没有受到任何改动，无论是API还是容器种类都没有——在C++20中并没有新增Ranges相关的容器API，直到C++23中上面提到的容器Ranges支持才补上这一部分。而种类方面，C++11新增了`forward_list`和`unordered_`系列容器之后，已经有10年没有新容器进入STL了（C++17 `string_view`和C++20/23 `[md]span`都是容器视图，并不是真正的容器）。终于，在C++23中，我们迎来了C++11之后对于容器种类的第一个重要改动：四个新的平坦容器，`flat_{set, multiset, map, multimap}`。（顺便提一句，C++26中几乎一定会至少引入`mdarray`, `hive`和`static_vector`三个新容器，所以现在真是STL容器的第三春）

要理解平坦容器的意义和用法，首先我们要回顾一下大家肯定都很熟悉的STL关联式容器。在C++98的初版STL中，容器被明确地分为三大板块：顺序容器，关联容器和容器适配器。其中，关联容器指的是`set`, `map`, `multiset`和`multimap`这四个容器（C++11新增了四个`unordered_`版本，所以现在是8个，标准其实把这些哈希容器单独分了一类，不过API相似性让我还是觉得这八个都算关联容器比较好）。标准[[associative.reqmts.general]/1](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/associative.reqmts.general%231)精准地描述了关联容器的特点：

> Associative containers provide fast retrieval of data based on keys.

嗯，就是一些能够提供快速查找键值的数据结构。简单的说，就是字典——说是四个，实际上这四个容器都是字典的变种。一个字典内部存储的都是键-值对，而只要有键我们就可以迅速查找到对应的值。这也是一类应用极其广泛的数据结构，在各个编程语言中都是最先提供的基础类型之一（比如Python的`dict`）。因此，这八个关联式容器也和`vector`一样，成为了最常用的STL容器之一。

但是，我们看这个描述，其实有很多模糊的地方——“快速”查找键值到底有多快？以及额外功能（比如数据是否可以快速有序遍历）也完全没提。这方面，STL容器的特殊性显现了出来——与STL算法，甚至任何其他部分的标准不同，STL容器的API和时间复杂度基本上是被完全指定下来的，因此，虽然其他部分的标准通常并不制定具体的实现策略，STL容器的实现策略基本上是完全确定下来的。具体到关联容器上来说，它们的限制是：

- 普通的（有序）关联容器拥有Node-based API和对数级别的查找和插入要求。因此，它们的实现基本上必定是一棵自平衡的二叉搜索树——而几乎所有实现使用的都是红黑树。
- 无序（哈希）关联容器拥有Bucket-based API和均摊常数级别的查找和插入要求。因此，它们的实现基本上必定是**封闭/链表式**的哈希表。

其实这些选择在当时看来并没有什么问题——BST本来就是有序字典的最好实现方式之一（即使现在也是这样），而在C++11周期（即2007年左右），封闭式的哈希表也是当时的主流实现（因为当时开放寻址式的哈希表基本上被认为是一种不成熟的实现）。然而，十几年之后，关于最有效率的字典数据结构的结论发生了一些变化：红黑树的缺点慢慢被揭示出来，而开放寻址式的哈希表慢慢成为了主流实现，而尴尬的是我们显然无法更改旧容器的API，也就无法更改它们的底层实现方式。因此，新的在（接近）相同时间复杂度条件下提供更有效率操作的容器已经迫在眉睫（不少第三方库，比如Boost和Abseil，早已提供了这些非标准容器）。开放寻址式的哈希表目前是Boost正在探索的`unordered_flat_map`系列，而红黑树的替代品则抢先一步，成为了C++23的新容器：平坦容器家族。

首先来说一下红黑树（或者任何BST）的缺点：它们的主要参数是对数级别的插入/查找/删除键值操作，以及`O(n)`的有序遍历。不过，为了提供这些时间复杂度，树状的基础结构就意味着每个节点一般情况下至少要多存储2-3个指针，因此空间占用会大一些，而且红黑树复杂的插入/删除操作也使得`O(log n)`前面的常数项十分大。另外，树状结构也意味着它们的迭代器只能是双向迭代器。

这些效率上的缺点让很多人转向了另一种，更简单地实现对数级别查找的数据结构：有序数组。毕竟，绝大多数人查找的次数远大于插入/删除操作，而在有序数组中的二分查找十分简单而成熟，常数项远小于BST中的查找。而且单单一个数组显然不需要任何额外空间，在空间占用上也会少很多，而且迭代器可以是随机访问迭代器。因此，平坦容器（就是用维护有序数组实现的关联容器）**并不是**一个全方面优越于`std::map`的容器。相反，它做出了一定的交换，用插入/删除的低效率（线性）交换了查找的高效率与低空间占用。具体来说，平坦容器相对于原来的`std::map`的特点（注意不全是优势）有：

- 更快的查找（仍然是`O(log n)`但是低常数）
- 更慢的插入/删除（`O(n)`而不是`O(log n)`）
- 更快的遍历速度（迭代器`operator++`从`O(log n)`优化到`O(1)`），而且遍历仍然有序
- 更小的空间占用
- 缓存性能提高（连续存储）
- 随机访问迭代器（而不是双向）（`flat_set`确实可以是连续存储迭代器，但是没必要）
- 迭代器不稳定（插入/删除有可能让迭代器变非法，和`vector`一样）
- 无法存储无法移动的对象
- 更差的异常保证（和`vector`一样，拷贝构造函数抛异常的时候就无法保证后面的元素成功复制）

因此，并不是所有人都适合用`flat_map`代替`map`。不过，因为查找比插入/删除要常见的多，所以这个容器也有很广泛的应用场景。

历史上来说，这些平坦容器像很多其他标准组件一样，首先进入了Boost，成为了Boost.Container的一部分；后来在C++20/23周期慢慢成熟进入了标准。这些容器设计上模仿了它们的普通伙伴，也就是说`flat_map`和`map`的API基本完全一样，以此类推；所以这四个平坦容器基本可以作为无缝替代品。比如：

```cpp
std::flat_map<int, int> fm;
fm[1] = 2;
fm[2] = 3;
std::println("{}\n", fm); // {1: 2, 2: 3}
```

用法跟原来的`map`/`set`完全一样。如果只是想要基础用法的话，知道这点就够了...然而，这些平坦容器有着自己的复杂度。

首先，这些平坦容器不仅仅是关联容器家族的一份子，它们还同时是容器适配器——先回忆一下，STL中现有的三个容器适配器，`queue`/`stack`/`priority_queue`，都是通过**包装**现有的容器（前两者默认包装`deque`，优先队列默认包装`vector`）来实现特定功能。比如说`queue`就是简单的内部存储一个`deque`，然后把`push_front`/`push_back`包装成`push`/`pop`。平坦容器也是这样——虽然内部是用有序数组实现的，但是这个“数组”的容器也可以让你指定。当然，默认选择肯定是所有人的最爱——`std::vector<T>`。如果你真有自己的要求，可以在比较器后面指定容器：

```cpp
std::flat_set<int> fs1; // std::vector<int>
std::flat_set<int, std::less<int>, std::deque<int>> fs2;
std::flat_map<int, std::string, std::less<int>, std::deque<int>, std::vector<std::string>> fm;
```

注意这里要求一个能够随机访问的顺序容器（来维持对数查找），所以STL中能用的只有`vector`和`deque`，主要还是给STL之外的容器用的。注意`flat_map`可以分别指定键的容器和值的容器（见下）。这两个容器的`multi`版本的模版参数完全和非`multi`版本一样，就不重复了。

然而，这里“有序数组”的实现让`flat_map`和`flat_set`之间出现了巨大的差别——`set`实际上和`map`结构一样，只是树节点额外储存一些数据；然而`flat_map`和`flat_set`的实现有着十分巨大的差别。要注意的是，因为性能上的因素，提案中的`flat_map`实际上和现在Boost.Container中的`boost::flat_map`完全不一样，而`flat_set`基本上是一样的。前者不一样在哪里呢？重点就是要多存储一个值。在Boost和Abseil中，多存储一个值的实现就是直接用`std::vector<pair<const Key, Value>>`进行存储，也就是一个键值对绑定在一起存储在数组中；然而，标准化的`flat_map`则采用了**键值分开存储**的方案，也就是对象内部两个数组：`vector<Key>`和`vector<Value>`。这也是为什么有两个可以自定义的底层容器（Boost只有一个）。这样的优点是只访问Key或者只访问Value的时候就是访问连续的内存，然而缺点是整个`flat_map`的迭代器设计变得及其繁琐与复杂——实际上这个迭代器是一个类似于`vector<bool>::reference`的代理迭代器，`operator*`返回的引用类型可以看成是`pair<const Key&, Value&>`的变种，即一个代理引用（注意这里是引用的`pair`），所以不能直接`auto a = *it`，最好直接取出`first`和`second`。

总之，用有序数组实现字典的思想早在20年前的初版Loki库中就有实现了（`AssocVector`），现在终于有了一个标准的版本，对于希望快速访问的人还是很有吸引力的。至于`flat_map`那个没有任何实现经验的分离存储选择——唉，希望没啥问题吧。

## 标准库 - T2 - Ranges适配器

Ranges适配器（或者说Ranges视图）是Ranges库比起Old STL最大的进步之处，lazy views的支持让许多运算可以推后到循环处，甚至不再执行，同时管道操作符的支持让C++ Ranges达到了类似C# LINQ的直观效果。不过，正因如此，所有的Ranges视图本质上都是另起炉灶——标准库中没有现成的算法让你参考，所以在有限的设计时间内C++20仅仅从range-v3的上百个视图中选择了16个加入。好在C++23几乎翻倍了这个数字，加入了15个新的Ranges视图。不过这离完整接纳range-v3还差得远——还得让C++26接着努力。下面是对每一个Ranges适配器，从（个人认为）最重要的到最不重要的的介绍。

这15个视图是[C++23 Ranges计划](https://link.zhihu.com/?target=https%3A//wg21.link/P2214R1)中除了`views::enumerate`以外的所有Tier 1内容，再加上`views::as_rvalue`和`views::repeat`。

### `zip`家族

`zip` (`views::zip` & `views::adjacent`)

[cppreference](https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/ranges/zip_view) - [P2321R2](https://link.zhihu.com/?target=https%3A//wg21.link/P2321R2) - [[range.zip]](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/range.zip) - 2021.10

支持：GCC 13 (partial), Clang not yet, MSVC not yet (代理迭代器部分三家都已实现)

测试：`__cpp_lib_ranges_zip >= 202110L`

这个提案看上去是`zip`，实际上是6个Ranges视图组成的家族——`zip`, `adjacent`, `pairwise`和它们的`_transform`版本。不过实际上只需要实现两个Ranges视图——`_transform`版本都可以在非变换版本的基础上实现，`pairwise`就是`adjacent<2>`的别名，所以只需要实现`zip`和`adjacent`就够了。

其实使用过Python的应该对`zip`这个视图非常熟悉——它在Python中会依次从所有列表中取元素：

```python
>>> zip([1, 2, 3], ['a', 'b', 'c'])
[(1, 'a'), (2, 'b'), (3, 'c')]
```

在C++中，一个自然的选择也是让`zip`成为一个`tuple`的Range——不过这里的元组当然也就是`std::tuple`了。具体来说：

```cpp
std::vector<int> vi{1, 2, 3};
std::vector<std::string> vs{"a", "b", "c"};
auto z = views::zip(vi, vs);
// range of tuple<int&, string&>
```

`zip_transform`大概是`zip` + `transform(apply)`也就是

```python
>>> zip_transform(f, [1, 2, 3], ['a', 'b', 'c'])
[f(1, 'a'), f(2, 'b'), f(3, 'c')]
```

至于`adjacent`，是把一个Range的连续N个元素放到一起成为一个tuple：

```python
>>> adjacent<3>([1, 2, 3, 4, 5])
[(1, 2, 3), (2, 3, 4), (3, 4, 5)]
>>> adjacent_transform<3>(f, [1, 2, 3, 4, 5])
[f(1, 2, 3), f(2, 3, 4), f(3, 4, 5)]
```

注意这个`adjacent`和后面要说的`views::slide`很像；区别是这里每个子Range的元素个数是编译期给定的，所以最终元素类型是tuple。由于相邻元素的情况比较常见，`adjacent<2>`提供了一个别名`pairwise`（以及`pairwise_transform`）。

要注意这个时候，`z`的元素类型（也就是引用类型）是`std::tuple<int&, std::string&>`，而值类型是`std::tuple<int, std::string>`——这就出了问题了。要注意，Ranges库的要求是引用类型和值类型的左值引用要有common reference——具体来说，Concept链是`input_iterator<I>`要求`indirectly_readable<I>`，后者要求`indirectly-readable-impl<remove_cvref_t<I>>`，从而最终要求`common_reference_with<iter_reference_t<I>&&, iter_value_t<I>&>`。那么看common reference就看能不能互相转化：

- 这里`std::tuple<int&, std::string&>`可以转化成`std::tuple<int, std::string>`
- 但是反过来`std::tuple<int, std::string>&`（注意左值）不能转化成`std::tuple<int&, std::string&>`，因为`int const&`不能转化成`int&`

其实这里就比较明显了——`tuple`的构造函数不够多，没有办法完整地传递cv修饰符。因此，这一提案为`tuple`已有的18个构造函数上又增加了8个，让构造函数数量达到了惊人的26个。另外在赋值上，同样为了体现`tuple`只不过是一个代理（即使是一个`const tuple`也是可以更改内部值的），将6个赋值函数翻倍成了12个。不过无论如何，这都是内部实现——在这些更改之后，我们就可以支持下面的用法了

```cpp
std::vector<std::unique_ptr<int>> vu{/* ... */};
std::vector<std::string> vs{"a", "b", "c"};
auto z = views::zip(vu, vs); // 支持move-only元素

std::vector<int> vi{1, 2, 3};
std::vector<std::string> vs{"a", "b", "c"};
ranges::sort(views::zip(vi, vs)); // 通过视图更改原容器
```

总之，`zip`的元素类型就是`tuple<int&, string&>`，但是要注意只有`zip`的值类型是真正的值`tuple<int, string>`——`zip_transform`的值类型仍然是`tuple<int&, string&>`。另外要注意的点是：（以下均对普通版和transform版都适用）

- `zip()`，即zip零个元素会产生一个类型为`std::tuple<>`的空Range。
- `adjacent`的元素类型是`std::tuple<T&, T&, ...>`，不是`std::array`，因为数组不能存放引用。
- `adjacent`不支持输入Range
- `adjacent`永远是common range
- `zip_transform`在range-v3中被叫做`zip_with`。实际上这个视图内部用了`ranges::zip_view`作为底层实现。

### `as_const`：Range版`std::as_const`

`views::as_const` / `cbegin` should always return a constant iterator

[cppreference](https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/ranges/as_const_view) - [P2278R4](https://link.zhihu.com/?target=https%3A//wg21.link/P2278R4) - [[range.as.const]](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/range.as.const) - 2022.07

支持：GCC not yet, Clang not yet, MSVC not yet

测试：`__cpp_lib_ranges_as_const >= 202207L`

`views::as_const`可能是“水最深”的Ranges适配器之一。它的背后暗示着已经摇摇欲坠的常量迭代器这一概念的变革与发展，以至于这个适配器可能连P2278的10%篇幅都没有（只是个附加产物）。另外，这个视图的命名也是跌宕起伏，到现在都没有一个准确的说法，下面还是用as_const这个名字。

`views::as_const`本身倒是一个很简单的视图。简单的说，`views::as_const(R)`就等价于`views::transform(R, std::as_const)`（当然后者现在并不合法），或者说就是Range版本的`std::as_const`。正因如此，它和后者也有着一样的用法：用常量性保护元素。比如说：

```cpp
for (auto&& elem : views::as_const(r)) {/* elem只读 */}
func(r | views::as_const); // func内部不能修改r的元素
```

要注意的点是`views::as_const`有可能什么都不做（如果参数已经是常量Range）或者直接调用`std::as_const`（比如传入`std::vector<T>`，返回`const std::vector<T>`即可）。只有在参数本身和`std::as_const`都不能产生常量Range（大多数视图和`std::span<T>`属于这一类）的时候这个视图才会加以包装。

### `as_rvalue`：Range版`std::move`

`views::as_rvalue`

[cppreference](https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/ranges/as_rvalue_view) - [P2446R2](https://link.zhihu.com/?target=https%3A//wg21.link/P2446R2) - [[range.as.rvalue]](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/range.as.rvalue) - 2022.07

支持：GCC not yet, Clang not yet, MSVC 19.34

测试：`__cpp_lib_ranges_as_rvalue >= 202207L`

`views::as_rvalue`跟`views::as_const`非常像——后者是Range版本的`std::as_const`，前者是Range版本的`std::move`。这两个视图都不会对元素本身做任何操作，只是做了一个转型（转成右值Range或者转成常量Range）。简单的说，这个视图就是把所有元素都转换成右值，这样就可以从结果中移动出来这些元素了。而且，`views::as_rvalue`背后没有那么深刻和庞大的关系网，毕竟`std::move_iterator<T>`早在十年前就存在了，`iter_move`这个CPO也早已经准备好。

不过，这个视图背后的故事仍然不那么单纯。在命名上，P2446是真的字面意义上的三易其稿——原来的命名是`views::move`（也是range-v3的命名），后来有人提出这个名字容易跟`std::move`混淆（一个施加于整个Range，一个施加于元素），所以被改成了`views::all_move`（`views::as_const`也被改成了`views::all_const`）。结果，大家都很反感这个新名字——毕竟STL里面还没有`all_`开头的先例（`all_of`那个算法不算），`views::transform`前面也没有all，没见谁把它和`std::transform`搞混，all move也不是通顺的英语。然而，没有人能够给出一个让所有人满意的命名——有些人想改回`views::move`，但是在ADL语境下不小心调用了`views::move`而不是`std::move`的危险性始终存在（as_const可以改回去，因为即使调用错了结果也是一样的，view会调用std版本）。最后，作者自己选择了`views::as_rvalue`来表示用意，但是这个名字和大家用了十年的`std::move`有差异，所以也有人不同意。这个命名问题一直搁置到现在，4轮投票都没个准确说法，不知道最后如何解决。

抛开命名不说，`views::as_rvalue`本身还是极为简洁的——让所有元素变成右值，通常情况下也就让移动成为可能。比如说

```cpp
views::as_rvalue(rng) | ranges::to<std::vector>()
```

就把所有元素move到了一个新vector里面去。

### `cartesian_product`：笛卡尔积

`views::cartesian_product`

cppreference - [P2374R4](https://link.zhihu.com/?target=https%3A//wg21.link/P2374R4) - [[range.cartesian]](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/range.cartesian) - 2022.07

支持：GCC not yet, Clang not yet, MSVC not yet

测试：`__cpp_lib_ranges_cartesian_product >= 202207L`

笛卡尔积并不是一个新事物了，实际上每一个多重嵌套循环本质上就是一个笛卡尔积。然而，STL中一直没有对生成笛卡尔积有着太好的支持——现在终于有了。

```python
>>> cartesian_product([1, 2, 3], ['a', 'b', 'c'])
[(1, 'a'), (1, 'b'), (1, 'c'),
 (2, 'a'), (2, 'b'), (2, 'c'),
 (3, 'a'), (3, 'b'), (3, 'c')]
```

从结果上来看就能知道，这个视图和`views::zip`非常像，只不过一个是内积一个是外积而已。用途上来说，第一个能想到的其实就是多层循环，比如说上面提到过的多维数组视图访问：

```cpp
for (auto [i, j] : views::cartesian_product(
    views::iota(mds.extent(0)),
    views::iota(mds.extent(1))
))
{
    // mds[i, j]
}

std::vector<int> a, b, c;
for (auto [i, j, k] : views::cartesian_product(a, b, c))
{
    // i, j, k
}
```

要注意几点：

- 和zip一样，这个视图是一个视图工厂，也就是说只能开启一个管道，不能在前面接管道，因为`a | cartesian_product(b, c)`和`cartesian_product(b, c)`自身是区分不开的（得等|>进入标准才能区分开）。
- 这个视图的Range特征值变化规则十分复杂，简单的说第一个参数是区别对待的，它可以是输入Range，剩下的都至少得是前向Range。另外，结果是不是common也只和第一个Range相关——后者是common或者同时是sized和随机访问就可以。（别问结果Range的迭代类型，别问，复杂得很）
- `views::cartesian_product()`（即0个参数）会产生一个唯一元素是一个`std::tuple<>{}`的Range。（这个和range-v3不一样——后者是一个同样类型的空Range）

### `join_with`：带分隔符的`join`/`flatten`

`views::join_with`

[cppreference](https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/ranges/join_with_view) - [P2441R2](https://link.zhihu.com/?target=https%3A//wg21.link/P2441R2) - [[range.join.with]](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/range.join.with) - 2022.02

支持：GCC not yet, Clang not yet, MSVC 19.34

测试：`__cpp_lib_ranges_join_with >= 202202L`

C++20的Ranges库中有一个`views::join`，提供了将传入的Ranges-of-Ranges（嵌套Range）合并成一个Range的方法：

```python
>>> join([[2, 3, 4], [5, 6], [7]])
[2, 3, 4, 5, 6, 7]
```

（当然，在很多语言中这个操作叫做flatten）

`views::join_with`在这个基础上做了少许修改：允许传入一个第二参数作为分隔符，也就是说`join_with`恰好是`split`的逆操作：

```python
>>> join_with([[2, 3, 4], [5, 6], [7]], 2)
[2, 3, 4, 2, 5, 6, 2, 7]
```

当然，最常用的版本肯定还是把一个字符串数组join成一个长串，分隔符一般是空格之类的（类似Python的str.join）。当然，结果是一个Range-of-`char`，但是用`string`的Range构造函数（或者`ranges::to`）就可以重新成为字符串。

命名上来说，本来这个视图完全可以也叫join（range-v3就是这么做的），通过参数个数来区分；然而，没有|>的恶果进一步显现出来——`r | views::join(P)`和`views::join(P)`并不能区分开来。因此，为了避免歧义，只得加上了_with后缀。

结果方面，`join_with`比起`join`相对来说复杂一些，不过总体上还是很直观的：结果类型基本上是外层Range，内层Range以及分隔符三者的迭代类型中最差的那一种（当然，上限是双向Range，而且有特殊要求，比如如果外层Range是纯右值&不是一个视图，那么无论三者迭代类型如何结果都只是个输入Range）。另外，像值/引用类型之类的Range特征值是内层Range和分隔符的相应类型的common type（这也保证了分隔符不必完全和内层Range的元素类型一致）。

### `chunk_by`：分块

`views::chunk_by`

cppreference - [P2443R1](https://link.zhihu.com/?target=https%3A//wg21.link/P2443R1) - [[range.chunk.by]](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/range.chunk.by) - 2022.02

支持：GCC not yet, Clang not yet, MSVC 19.33

测试：`__cpp_lib_ranges_chunk_by >= 202202L`

接下来的四个视图都是分块操作的各种变种。其中，`views::chunk_by`实现的是GroupBy。GroupBy这一操作也算是各家语言算法库中的最基础之一了。某种意义上，这一操作可以说是`join`/`flatten`的逆操作，将一个完整的Range分割成多个Range，分割依据一般是一个谓词或者投影函数。具体来说，GroupBy有两种不同的解释：

第一种是所谓的ChunkBy，第二参数是一个二元谓词，这个谓词会连续调用相邻元素，返回false时就会开启一个新的分割窗口。比如说：

```python
>>> chunk_by([2, 3, 4, 2, 1, 4, 5, 10, 2, 3], lambda x, y: x < y)
[[2, 3, 4], [2], [1, 4, 5, 10], [2, 3]]
```

传入\<这个操作就意味着每一次出现前一元素>后一元素，就会在这里分隔Range。

第二种一般称为ChunkOn，第二参数是一个投影函数（一元），而分割依据也就是第二参数返回的值一样的就会被分到一起（当然，既然还是分块，只有连续的相同值才会被分到一起）。比如：

```python
>>> chunk_on([2, 3, 6, 2, 1, 4, 10, 3], lambda x: x % 3)
[(2, [2]), (0, [3, 6]), (2, [2]), (1, [1, 4, 10]), (0, [3])]
```

每个元组第一元素是投影的结果，第二元素是所有得到这个结果的相邻元素列表。

可以很明显的看出，第一种比第二种结构更加常用一点——一方面是第二种结构的结果实际上是一个multimap，是一个不怎么常用的数据结构；另一方面是只需要传入`lambda x, y: x % 3 == y % 3`就可以把第一种当第二种用，所以C++23只加入了实现第一种结构的`views::chunk_by`，而`views::chunk_on`就留待以后处理了。

Range特征值本身来说，`views::chunk_by`的结果只有可能是双向或者前向Range——取决于第一参数Range的迭代类型（不支持输入Range作为第一参数）。另外，十分重要的一点是`views::chunk_by`和`views::split`一样，是不能做常量遍历的——主要原因是这个视图的`begin()`要返回第一个底层Range，所以自然必须知道这第一个Range的终点在哪里，而为了满足`begin()`是`O(1)`的硬性要求就只能内部提前计算出第一个Range的终点并且储存起来。自然，`begin()`也就不能在常量对象上调用了。

### `chunk`与`slide`：滑动窗格

Windowing range adaptors: `views::chunk` and `views::slide`

cppreference - [P2442R1](https://link.zhihu.com/?target=https%3A//wg21.link/P2443R1) - [[range.chunk]](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/range.chunk), [[range.slide]](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/range.slide) - 2022.02

支持：GCC not yet, Clang not yet, MSVC 19.33

测试：`__cpp_lib_ranges_chunk >= 202202L`, `__cpp_lib_ranges_slide >= 202202L`

接下来的两个视图仍然是分块操作，不过这一次变成了直接指定分块的大小，而不是使用谓词函数。这两个视图很相似：`chunk(N)`和`slide(N)`都是形成长度为`N`的分块，但是chunk不会重叠，而slide会。比如说：

```python
>>> chunk([1, 2, 3, 4, 5, 6, 7], 3)
[[1, 2, 3], [4, 5, 6], [7]]
>>> slide([1, 2, 3, 4, 5, 6, 7], 3)
[[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6], [5, 6, 7]]
```

注意chunk的最后一个Range有可能低于指定长度。slide的行为实际上跟zip家族中的`views::adjacent`完全一样；区别只不过是分块大小从编译期变成了运行期参数，而元素类型也从`std::tuple`变成了Range（具体来说，`ranges::subrange`）。不过，尽管两者很相似，但在Range特征值上它们还是有不少区别的：

- `chunk`支持输入Range，而`slide`不支持。不过这个“支持”是有代价的，输入Range使用了不同的算法，而且因为内部提前计算+存储的原因输入Range版本的`ranges::chunk_view`并不支持常量遍历。
- `chunk`的输入Range版本值类型是一个内嵌的类，其他Range版本的值类型是`ranges::take_view`；`slide`的值类型则是`ranges::subrange`（实际上是`views::counted`的结果）
- `views::slide`在range-v3中被叫做`sliding`。

### `stride`：定宽滑动窗格

`views::stride` / `stride_view`

cppreference - [P1899R3](https://link.zhihu.com/?target=https%3A//wg21.link/P1899R3) - [[range.stride]](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/range.stride) - 2022.07

支持：GCC not yet, Clang not yet, MSVC 19.34

测试：`__cpp_lib_ranges_stride >= 202207L`

`views::stride`是第四个分块相关的Ranges视图，或许也是最重要的一个；它补上了STL中最重要的缺失之一——带步长的子集选择：

```cpp
for (auto i = 0uz; i < vec.size(); i += 2)
{
    // ... do something on vec[i] ...
}
```

在目前的STL中，并没有太好的办法来做这种隔几个选一个的事情——`transform`（无论是Ranges算法还是视图）不行，`filter`不行，我们现在又没有`enumerate`能让`filter`使用。连最常用的Ranges视图`views::iota`都没有步长参数——这一切都要`views::stride`来拯救。

`views::stride`的用法本身很简单：`r | views::stride(N)`就是每`N`个元素选择一个`r`中的元素形成的子集：

```python
>>> stride([1, 2, 3, 4, 5, 6, 7], 2)
[1, 3, 5, 7]
```

因此，上面的`for`循环就可以直接写成

```cpp
for (const auto& elem : vec | views::stride(2))
{
    // ...
}
```

而带步长的`iota`也可以直接`iota(N, M) | stride(k)`解决。

这个适配器本身的实现十分简单，唯一要注意的可能是`stride`的步长参数必须是正整数（0和负数没有意义；想要无限0步长重复的视图的看下面的`views::repeat`）。大部分Ranges特征值也是直接继承底层Range的——除了common需要在底层Range也是common的基础上加上一个条件：要么同时是sized，要么是输入或者前向Range（即non-sized 双向Range并不支持common结果）。

### `repeat`：重复单一元素的生成器

`views::repeat`

[cppreference](https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/ranges/repeat_view) - [P2474R2](https://link.zhihu.com/?target=https%3A//wg21.link/P2474R2) - [[range.repeat]](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/range.repeat) - 2022.07

支持：GCC not yet, Clang not yet, MSVC not yet

测试：`__cpp_lib_ranges_repeat >= 202207L`

Ranges视图并不仅仅能把一个已有Range经过处理形成一个新的Range；它们还能是Range工厂，即从一个元素/临界值/...形成一个全新的Range。这类工厂视图是不能在左边加`r |`的；它们就是管道的起点。这方面最常用的例子莫过于`views::iota`，从一个或者两个临界值生成完整的Range。

如果输入是元素的话，我们可以说视图把元素“提升”成了Range。例如`views::single`，把传入的对象提升成一个长度为1的Range；`views::empty<T>`，把传入的类型提升成长度为0的空Range；C++26的`views::maybe`，把传入的可空类型提升成长度为0/1的Range；还有这个提案的`views::repeat`，把传入的对象复制然后提升成长度为N/无穷的重复Range：

```python
>>> repeat(2)
[2, 2, 2, 2, 2, ...]
>>> repeat("My", 3)
["My", "My", "My"]
```

`views::repeat`本身就是把第一参数重复几次，然后组合成一个新Range；新Range的长度是第二参数，或者如果没有第二参数就是一个无穷Range（这点和`views::iota`一样，`iota(N)`是个无穷Range）。既然是Range了，那么就可以和其他视图凑出很多有趣的用法，比如：

```cpp
std::vector vec{1, 2, 3, 4, 5};
auto m = views::zip(vec, views::repeat(1)) | ranges::to<std::map>();
std::println("{}", m); // {1: 1, 2: 1, 3: 1, 4: 1, 5: 1}
```

或者用来在`views::concat` (C++26)的几个连续Range中插入一堆连续填充符之类的。这个视图最大的危险性可能还是在无穷Range上——一个`for (auto a : views::repeat(1))`就直接是死循环，至少要`take`一下。另外，range-v3中无穷版本和两参数版本实际上是分开的（后者叫`views::repeat_n`），但是加入标准的时候合并起来的，用参数个数区分两者。

## 标准库 - T2 - Ranges算法

和视图方面相比，C++20 Ranges库的算法部分要充实许多——自然，主要原因就是绝大多数算法都有现成的Old STL参考，只需要确定concept限定就可以了。C++20 Ranges算法比起Old STL算法主要的进步是三点：使用Range/迭代器-哨兵参数而不是迭代器对参数，以及使用Concept来对大部分参数进行了限定（现在`ranges::sort(some_std_list)`之流会直接在Concept层面就拒绝掉了），以及成为Niebloids来阻止ADL。现在的`<algorithm>`随着99个C++20 Ranges算法的加入已经基本完全Range化了，留下的只有`shift_left/right`这一对有点争议的算法。然而，很容易被遗忘的标准库算法头文件`<numeric>`（`std::accumulate`在这里面哦！没想到吧）中还有11个算法尚未Range化。

C++23部分解决了这一问题。14个新的Range算法加入了标准，使得`<algorithm>`的剩余那一对算法完成了这方面的工作，而`<numeric>`中也有两个算法（`iota`和`accumulate`）完成了Range化。至于剩下那9个，以`transform_`开头的4个（`inner_product`实际上应该叫`transform_accumulate`）实际上并不需要Range化（`transform_xxx(rng, args)`就是`xxx(rng | views::transform(F), args)`），在Ranges视图`views::transform`存在的情况下使用它们已经没有意义；剩下的5个情况更加复杂，例如`std::reduce`要求二元运算符满足交换律和结合律，这方面的要求使用现有的Concept设施（只能限制语法，不能限制语义）比较难以表达，所以这5个就留待以后处理了。加入C++23剩下的5个算法（`accumulate`膨胀成6个算法了，`find_last`是三个）则是Old STL中没有的，这五个都是简单的wrapper用来提供方便用的。

### `fold`家族

`ranges::fold` (`_left`, `_right`, `_left_first`, `_right_last`, `_left_with_iter`, `_left_first_with_iter`)

cppreference - [P2322R6](https://link.zhihu.com/?target=https%3A//wg21.link/P2322R6) - [[alg.fold]](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/alg.fold) - 2022.07

支持：GCC not yet, Clang not yet, MSVC not yet

测试：`__cpp_lib_ranges_fold >= 202207L`

`fold`可能是各家算法库中最重要的算法，没有之一。有无数的其他算法（`count`，`max`/`min`，`all_of`，`inner_product`等等）在实质上都可以基于`fold`实现，甚至C++17中加入了语言层面的fold支持。然而，在Old STL中，只有两个与`fold`有关的算法：`std::accumulate`和`std::reduce`。这两个算法最大的问题就是名字不对（一般人不会想到`accumulate`作为一个极度暗示加法操作的名字可以做任何fold，而`reduce`作为一个比较通用的名字居然反而对它的操作限制性很强），以及它们只能提供左fold。因此，为了解决这一问题，`std::accumulate`的Range版本，`fold`家族，进入了标准。（`reduce`更为复杂，需要更多设计）

这一次就不是只有左fold了——经过冗长的讨论，`fold`的全貌应该兼顾以下四个方面（暂时不考虑短路fold，后面再说）：

- Range参数/迭代器-哨兵对（这个不影响名字）
- 左/右fold
- 接受一个额外初始值/使用第一个元素作为初始值
- 只返回结果或者同时返回末尾迭代器和结果（这里确实可以只提供第二种，但是考虑到易用性还是提供了只返回结果的版本）

由于这些都是正交的选择，如果全部提供就是8个名字下的16个重载算法。最后，提案中还是稍微缩减了这个数字——右fold+同时返回迭代器这个组合的2个名字（4个重载）被删掉了，因为你可以使用`views::reverse`来把左fold变成右fold。因此，最后提供的是6个名字下的12个重载：

- `fold_left` + `fold_left_first`
- `fold_right` + `fold_right_last`
- `fold_left_with_iter` + `fold_left_first_with_iter`

（最后那个25个字符的名字看起来太长？`__cpp_lib_has_unique_object_representations`了解一下。啥？宏不算？`atomic_compare_exchange_strong_explicit`了解一下，算上`ranges::`都不够打的）

以上的统一命名规则是`left`/`right`代表左/右fold，不带`first`/`last`就是额外接受初始值作为参数，带就是用第一个/最后一个元素做初始值；不带`with_iter`就只会返回结果，带就会同时返回末尾迭代器。可以看出越常用的名字越短（曾经有提议把左fold就叫`ranges::fold`，但是没有得到一致认同）。因此，简单的使用实际上不用理会那些长名字，知道`fold_{left,right}`就行了：

```cpp
std::vector vec{1, 2, 3, 4, 5};
ranges::fold_left(vec, 0, std::plus{}); // 15
// or simply
ranges::fold_left_first(vec, std::plus{}); // 15

// fold_left(vec, init, f):
// f(...f(f(init, vec[1]), vec[2]), ...vec[n])
// fold_left_first(vec, f):
// f(...f(f(vec[1], vec[2]), vec[3]), ...vec[n])
// fold_right(vec, init, f):
// f(vec[1], f(vec[2], ...f(vec[n], init)))
// fold_right_last(vec, f):
// f(vec[1], f(vec[2], ...f(vec[n - 1], vec[n])))
```

要注意几点：

- 正如前面所说的，`fold_right[_last]_with_iter`是没有的
- `fold`家族现在在`<algorithm>`中而不是`<numeric>`中了
- `fold`家族实际上解决了`std::accumulate`的一个隐藏缺点：原来结果类型就是传入的初始值的类型，导致像对一个`vector<double>`用`std::accumulate(vec.begin(), vec.end(), 1)`只会返回截断的`int`；现在返回值会是`f(init, vec[1])`（或者对于其他变种，`f(vec[1], vec[2])`，`f(vec[n], init)`，`f(vec[n - 1], vec[n])`）的类型（decay之后），从而解决了这个问题。不过当然严格意义上`f(init, vec[1])`和`f(f(init, vec[1]), vec[2])`的类型有可能不一样，所以这个解决方案并不完美；不过这样的`f`应该很少见了。
- `fold`家族的`first`/`last`变种会返回`std::optional<T>`（其中`T`是上面提到的第一次调用的结果类型），这点比较特别，在传入空Range的时候会返回空`optional`。这和其他STL算法不一样（其他的一般就是直接UB，比如`max`），也是标准库第一次有意义地使用`std::optional`。
- `with_iter`变种会返回`ranges::in_value_result<I, T>`，其实就是一个迭代器和一个值的`struct`；直接用structural binding `auto [iter, result]`接受就可以。当然看这个名字就知道实际上访问末尾迭代器是`.in`，访问结果是`.value`（别忘了如果用`fold_left_first_with_iter`，`.value`实际上是个`std::optional`）
- `fold`家族另外一个与众不同的地方是它们不像其他的Ranges算法，是没有投影参数的；主要原因是`ranges::fold_left_first`需要计算初始**值**，所以需要投影能够传入Range的值类型的**右值**（即第一个元素的投影结果）；然而其他算法的投影只要求能够传入Range的引用类型和值类型的**左值**（而将右值转换成左值需要拷贝一次，自然这种效率损失是不行的）。为了统一，本来可以有投影的`ranges::fold_left`也没有了。
- 短路`fold`（比如`all_of`）暂时是没有的，主要是传入第二个短路标识符会显得太过复杂。
- 实际上把右fold转换成左fold不只需要`views::reverse`，还需要把二元操作的两个参数颠倒一下位置，即（没考虑forward）

```cpp
ranges::fold_right(r, init, f) == ranges::fold_left(
    r | views::reverse, init,
    [](auto&& a, auto&& b) {return f(b, a);}
)
```

### `contains`：25年的补偿

`ranges::contains` & `ranges::contains_subrange`

[cppreference](https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/algorithm/ranges/contains) - [P2302R4](https://link.zhihu.com/?target=https%3A//wg21.link/P2302R4) - [[alg.contains]](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/alg.contains) - 2022.07

支持：GCC not yet, Clang not yet, MSVC 19.34

测试：`__cpp_lib_ranges_contains >= 202207L`

`contains`在C++标准库中（无论是Old STL还是Ranges）一直是一个被遗忘的角落。在非常长的一段时间里，查询被表述为`find() != end()`，导致了很多困惑，毕竟把简单的“是否在里面”换成“找到的位置是不是在末尾（即没找着）”并不是一个十分直观的转变。长期以来，因为`contains()`“只不过”是一个简单的wrapper，WG21并不想加入这样的算法。

好在这一情况终于开始改变。从C++20开始，WG21逐渐意识到了提供这类方便函数对初学者的好处。首先是`std::set`等关联容器拿到了`contains(key)`方法，然后是C++23中`std::string`终于拿到了查找字串的成员函数`contains(substring)`（下面会讲到）。现在，P2302将这两个已有的例子进行了通用化，提出了查找任意Range的元素或者子序列的通用算法`ranges::contains`。不过，上面两个`contains`实际上有细微的差别：`contains(key)`是查找单个元素，而`contains(substring)`则是查找子序列。为了避免混淆，P2302以不同的名字添加了两者，更常用一点的查找单个元素就是`ranges::contains`，而查找子序列则被命名为`ranges::contains_subrange`。比如说：

```cpp
std::vector vec{1, 2, 3, 4, 5};
if (ranges::contains(vec, 3)) // true
if (ranges::contains(vec.begin(), vec.end(), 6)) // false
std::vector pattern{1, 2, 3};
if (ranges::contains_subrange(vec, pattern)) // true
// 等价于
if (ranges::contains_subrange(vec.begin(), vec.end(), pattern.begin(), pattern.end())) // true
```

要注意的是，这两个算法和它们的成员函数版本一样，并不是新算法——`ranges::contains`直接调用`ranges::find`，而`ranges::contains_subrange`直接调用`ranges::search`。它们只不过是为了方便而产生的包装函数。另外，像其他Ranges算法一样，这两个算法也接受投影函数作为最后一个参数：

```cpp
auto vec = views::iota(1, 11) | ranges::to<std::vector>();
ranges::contains(vec | views::take(2), 6); // false
ranges::contains(vec | views::take(2), 6,
                 [](auto a) { return a % 4; }); // true
```

### `{starts,ends}_with`：通用化的String操作

`ranges::starts_with` & `ranges::ends_with`

[cppreference](https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/algorithm/ranges/starts_with) - [P1659R3](https://link.zhihu.com/?target=https%3A//wg21.link/P1659R3) - [[alg.starts.with]](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/alg.starts.with), [[alg.ends.with]](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/alg.ends.with) - 2021.06

支持：GCC not yet, Clang not yet, MSVC 19.31

测试：`__cpp_lib_ranges_starts_ends_with >= 202106L`

和`contains`一样，`starts_with`和`ends_with`也长期从标准库中缺失。这一次可能更加影响恶劣——知道使用`find()`来模拟`contains()`的人并不少，但是知道如何使用STL算法来模拟`starts_with`的人是真的少（实际上应该使用`std::mismatch`——知道这个算法的都不多吧？），导致这个常用的操作在很多时候只能用for循环实现。好在C++20终于开始扭转这一问题，首先加上了最常用的`string`和`string_view`的`starts_with`/`ends_with`成员算法，而轮到C++23就有P1659来加入这两个算法的通用版本：查询一个Range是否以另外一个Range为起始/终止。比如说：

```cpp
ranges::starts_with(views::iota(0, 50), views::iota(0, 30)); // true
ranges::ends_with(views::iota(0, 50), views::iota(30, 50)); // true
std::vector vec{1, 2, 3, 4, 5};
ranges::starts_with(vec, vec | views::take(2)); // true
```

注意和`contains_subrange`一样，长序列在前，开头/结尾查询序列在后，而且同样可以传入4个迭代器-哨兵参数来指定两个序列。同样的，最后三个可选参数分别可以指定比较谓词和两个序列的投影函数，比如说：

```cpp
std::vector vec{3, 5, 6, 7, 8};
std::vector pattern{0, 2};
ranges::starts_with(vec, pattern, ranges::equal_to{}, [](auto a) {return a % 3;}); // true
```

### `iota`/`shift_{left,right}`：最后的算法补全

`ranges::iota`, `ranges::shift_left` & `ranges::shift_right`

[cppreference](https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/algorithm/ranges/iota) - [P2440R1](https://link.zhihu.com/?target=https%3A//wg21.link/P2440R1) - [[numeric.iota]](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/numeric.iota), [[alg.shift]](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/alg.shift) - 2022.02

支持：GCC not yet, Clang not yet, MSVC 19.34

测试：`__cpp_lib_ranges_iota >= 202202L`, `__cpp_lib_shift >= 202202L`

`std::iota`是最不为人知的STL算法之一，作为`<numeric>`中最简单的算法，它在这个提案中终于获得了Ranges版本。更好的是，由于`views::iota`已经存在，`ranges::iota`的实现可以大范围照抄。这个算法很简单：`ranges::iota(rng, val)`就是将`val`开始的连续序列放入`rng`中，即一连串`rng[0] = val; rng[1] = val + 1; ...`这样以此类推。比如说：

```cpp
std::vector vec(5);
ranges::iota(vec, 1);
std::println("{}", vec); // [1, 2, 3, 4, 5]
```

这个算法的返回值是得到的末尾迭代器和最终值，比如上面就会返回`{vec.end(), 6}`。注意，十分明显的，这个算法由于是向Range输出值，没有投影函数参数。

`std::shift_left`, `std::shift_right`则是STL的新成员——直到C++20它们才加入标准，也因此成为了`<algorithm>`中最后一对没有Range化的算法。这两个算法和名字所说的操作一样：把序列向左或者向右平移一段距离。比如说：

```cpp
std::vector vec{1, 2, 3, 4, 5, 6, 7};
ranges::shift_left(vec, 3);
// vec = [4, 5, 6, 7, 5, 6, 7]
ranges::shift_right(vec, 2);
// vec = [4, 5, 4, 5, 6, 7, 5]
```

要注意的是这个算法只不过是平移元素，比如把`[4, 5, 6, 7]`向左平移三个位置，而不会改变原位置的值。这两个算法同样没有投影函数参数，而且第二个参数如果小于0是UB（可不会反向移动哦），等于0或者大于等于序列长度就啥也不干。Range版本的优势是可以返回新的Range，这样上面`ranges::shift_left(vec, 3)`返回的就是`[4, 5, 6, 7]`这一部分，而去除了原来序列没被更改的部分。

### `find_last`：无人预料的缺失

`find_last`家族

[cppreference](https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/algorithm/ranges/find_last) - [P1223R5](https://link.zhihu.com/?target=https%3A//wg21.link/P1223R5) - [[alg.find.last]](https://link.zhihu.com/?target=https%3A//eel.is/c%2B%2Bdraft/alg.find.last) - 2022.07

支持：GCC not yet, Clang not yet, MSVC not yet

测试：`__cpp_lib_find_last >= 202207L`

`find_last`并不是一个新算法。

`std::find`（和`_if`/`_if_not`变种）可以说是STL算法这部分中最老牌的成员之一，毕竟在一个序列中寻找符合要求的元素在无论哪个算法库都是最基础的操作之一。这个算法不仅作为Old STL的独立算法（`std::find`）存在，也有一个Ranges版本（`std::ranges::find`），还作为`string`和`string_view`的成员函数存在。有趣的是，前两者都只有`find`/`find_if`/`find_if_not`三个变种，而作为成员函数的`find`有多得多的变种：`find`/`rfind`/`find_first_of`/`find_last_of`/`find_first_not_of`/`find_last_not_of`。P1223这个提案就是为Ranges算法库中添加了三个新的`find`变种，对应于`string[_view]::rfind`的反向版本。（为什么不叫`rfind`？我也不知道，大概LEWG现在喜欢完整单词了。原来是叫`find_backward`，最终定名为了`find_last`）

为什么在C++98加入`find`的时候没有想过反向版本呢？其实原因很简单：`std::reverse_iterator<I>`当时已经存在了。想要在序列中找到最后一个给定的值的位置，只需要：

```cpp
// 序列[beg, end]找最后一个value
auto it = std::find(
    std::make_reverse_iterator(beg),
    std::make_reverse_iterator(end), value);
// 序列R找最后一个value
auto it = std::ranges::find(R | views::reverse, value);
```

可以明显地看出， `views::reverse`的存在确实让Ranges库中的反向查找变得十分简单——但是普通的`std::find`的反向查找还是有一些繁琐的。不过，秉承C++20开始的加方便wrapper的趋势，`find_last`这个“仅仅是一行”的wrapper还是因为方便使用而被加了进来。

`find_last`的用法很简单：和`ranges::find`几乎完全一致，也有三个版本`find_last`/`find_last_if`/`find_last_if_not`。注意只有`ranges::`版本，因为现在Old STL基本上已经被放弃了，里面不会新增任何算法。

```cpp
auto [it, end] = ranges::find_last(beg, end, value);
auto [it, end] = ranges::find_last_if(R, [](auto val) {/* ... */});
```

效果就是找到序列中最后一个相等/符合要求/不符合要求的值。有一个重要的区别是作为Ranges时代的新算法，它的返回值实际上是一个`subrange`，即会同时返回找到的位置以及计算出来的末尾迭代器位置。这里用structural binding或者`.begin()`就行了。
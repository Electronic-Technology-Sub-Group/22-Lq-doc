# 响应式侦听

组合式 API 中响应式侦听有两种方式：

* `Vue.watchEffect`：立即执行传入的函数，响应式追踪其中的依赖，并在依赖变更时重新运行该函数

  ```js
  const count = Vue.ref(0)
  // 添加侦听器
  Vue.watchEffect(() => console.log(count.value))
  // 修改 count 验证
  setTimeout(() => count.value++, 100) // 输出: 0 1
  ```
* `Vue.watch`：侦听特定数据源，在回调函数中执行副作用，**懒执行**

  数据源：拥有返回值的 `getter` 函数，或 `ref`

  ```js
  // 侦听 getter
  const state = Vue.reactive({ count: 0 })
  Vue.watch(() => state.count, (newValue, oldValue) => {
      // do something
  })
  ```

  `Vue.watch` 可以侦听多个数据源

  ```js
  const state = Vue.reactive({ count: 0 })
  const title = Vue.ref('')
  Vue.watch([() => state.count, title], ([newCount, newTitle], [oldCount, oldTitle]) => {
      // do something
  })
  ```

# 侦听器控制

* 组件停止

  当侦听器在组件 `setup()` 或生命周期钩子函数中调用时，改监听器将绑定到该组件，并在组件卸载时自动停止。

  `Vue.watchEffect()` 和 `Vue.effect()` 会返回一个函数，调用该函数可以手动停止监听器

  ```js
  const stop = Vue.watchEffect(() => { ... })
  // 停止监听
  stop()
  ```

  在侦听器回调传入一个 `onInvalidate`，在侦听器中调用 `onInvalidate(func)` 方法可以设置侦听器停止时的行为，可用于结束一些异步调用等

  该方法在 Vue 源码中传入参数名称为 `onCleanup`

  ```js
  const stop = Vue.watchEffect(onInvalidate => { 
      // do something ...
      onInvalidate(() => {
          // do something clean
      })
  })
  // 停止监听
  stop()
  ```
* 调试：`Vue.watchEffect` 和 `Vue.watch` 方法可以接受第二个对象类型参数，用于设置调试行为，**仅开发模式下生效**

  ```js
  }
      onTrack: (e) => {},  // 当该响应式对象被追踪时调用
      onTrigger: (e) => {} // 当该响应式对象的依赖项被修改时调用
  }
  ```

‍

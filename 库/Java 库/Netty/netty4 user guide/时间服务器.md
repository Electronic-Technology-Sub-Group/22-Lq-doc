服务器方面，同样只是将 Handler 改变一下即可。

由于我们不关心任何客户端发送过来的数据，凡是客户端发送的数据，我们都直接回复当前时间，因此我们重写 `channelActive` 方法而不是 `channelRead` - 不进行读操作。

* 在准备数据时，我们使用了 `ChannelHandlerContext#alloc()` 返回的申请器申请了一个 `ByteBuf`
* 发送数据返回的仍是一个 `Future`，Netty 的操作都是异步的，我们需要注册监听器等待发送完成后关闭连接

```java
class TimerServerHandler extends ChannelInboundHandlerAdapter {

    @Override
    public void channelActive(ChannelHandlerContext ctx) {
        // 准备时间数据
        ByteBuf buffer = ctx.alloc().buffer(4);
        buffer.writeInt((int) (System.currentTimeMillis() / 1000L + 2208988800L));
        // 发送数据
        ChannelFuture future = ctx.writeAndFlush(buffer);
        future.addListener((ChannelFutureListener) f -> ctx.close());
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
        cause.printStackTrace();
        ctx.close();
    }
}
```

客户端方面，创建客户端的步骤与服务器差距不大，但有以下区别：

* 使用 `Bootstrap` 代替 `ServerBootstrap`，没有传输模式选择
* 通道使用 `NioSocketChannel` 代替 `NioServerSocketChannel`
* 客户端连接相对简单，只需要定义一个 `EventLoopGroup` 即可，该对象同时承担 `worker` 和 `boss` 的职责
* 由于客户端 `SocketChannel` 没有 `parent`，因此无需设置 `childOption`
* 连接时使用 `connect` 表示连接一个服务器，而不是使用 `bind` 绑定监听端口

```java
public class TimeClient {
    private final int port;
  
    public TimeClient(int port) {
        this.port = port;
    }
  
    public void run() throws InterruptedException {
        EventLoopGroup worker = new NioEventLoopGroup();
        try {
            Bootstrap bootstrap = new Bootstrap();
            bootstrap.group(worker)
                    .option(ChannelOption.SO_KEEPALIVE, true)
                    .channel(NioSocketChannel.class)
                    .handler(new ChannelInitializer<SocketChannel>() {
                        @Override
                        protected void initChannel(SocketChannel ch) {
                            ch.pipeline().addLast(new TimeClientHandler());
                        }
                    });
                
            ChannelFuture future = bootstrap.connect("localhost", port).sync();
            future.channel().closeFuture().sync();
        } finally {
            worker.shutdownGracefully();
        }
    }
}
```

`TimeClientHandler` 是自定义的处理方法，内部直接读取时间信息并输出

```java
class TimeClientHandler extends ChannelInboundHandlerAdapter {
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) {
        ByteBuf buf = (ByteBuf) msg;
        try {
            long time = (buf.readUnsignedInt() - 2208988800L) * 1000L;
            System.out.println(new Date(time));
        } finally {
            ctx.close();
            buf.release();
        }
    }
}
```

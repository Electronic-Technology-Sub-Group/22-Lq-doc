# 基于类型的匹配

若存在多个参数类型相同，则无法使用基于类型的构造注入。

在使用构造函数注入时，`index` 指定第几个参数，如果值为 `bean` 对象引用，使用 `ref` 指定 `id`；如果是简单的 Java 类型（基本类型、`String`），则使用 `value` 指定值字面量。

当几个参数之间没有继承关系时，可以直接引用对象，Spring 可以根据类型判断实参位置。

```java
// 仅截取构造函数
public ServiceTemplate(JmsMessageSender jmsMessageSender, 
					   EmailMessageSender emailMessageSender, 
					   WebServiceInvoker webServiceInvoker) {  
    this.jmsMessageSender = jmsMessageSender;  
    this.emailMessageSender = emailMessageSender;  
    this.webServiceInvoker = webServiceInvoker;  
}
```

```xml
<!-- 仅 ServiceTemplate 的 bean 节选 -->
<bean id="serviceTemplate"
      class="com.example.mybank.chapter03.service.ServiceTemplate">
    <constructor-arg ref="webServiceInvoker" />
    <constructor-arg ref="jmsMessageSender" />
    <constructor-arg ref="emailMessageSender" />
</bean>
```

上面的例子中，`webServiceInvoker`，`jmsMessageSender`，`emailMessageSender` 三个参数的顺序与构造函数的顺序不同，且没有使用 `index` 等参数限定顺序，但 Spring 能正确初始化，因为 `JmsMessageSender`，`EmailMessageSender`，`WebServiceInvoker` 三个类没有继承关系，Spring 能正确识别每个参数的位置。

若两个参数类型有继承关系，使用 `type` 属性确定具体类型。

‍

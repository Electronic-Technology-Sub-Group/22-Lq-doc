# 抗锯齿与多重采样

>[!note] 走样
>Aliasing，有时模型边缘有锯齿的情况，放大能看到锯齿状边缘，可以清楚的看到形成边缘的像素。

> [!note] 抗锯齿
> Anti-aliasing，又称反走样，缓解走样现象，产生平滑边缘

> [!note] 光栅器：位于最终处理过的顶点之后到片段着色器之前所经过的所有的算法与过程的总和

光栅器会将一个图元的所有顶点作为输入，并将它转换为一系列的片段。

````col
```col-md
flexGrow=1
===
![[Pasted image 20230913155051-20240513170937-c2m6dh8.png]]
```
```col-md
flexGrow=1
===
![[Pasted image 20230913155234-20240513171220-vr54n4p.png]]
```
````

受限于窗口分辨率，顶点坐标与片段之间不可能一对一映射，光栅器应以某种方式决定每个顶点所在的片段/屏幕坐标，因此边缘某些像素不会渲染，即使用不光滑的边缘来渲染图元，产生锯齿边缘。

超采样抗锯齿 SSAA（Super Sample Anti-aliasing）使用比正常分辨率更高的分辨率（即超采样）来渲染场景，更新图像时分辨率会被下采样（Downsample）至正常的分辨率。这些额外的分辨率用来防止锯齿边缘的产生。

>[!error] 缺点：需要绘制更多片段，带来很大的性能开销

多重采样抗锯齿 MSAA（Multisample Anti-aliasing）借鉴了 SSAA 的理念，以更加高效的方式实现了抗锯齿。

> [!note] 多重采样：将单一的采样点变为多个采样点。以特定图案排列的几个子采样点（Subsample，默认 4 个）决定像素的遮盖度。

颜色缓冲的大小会随着子采样点的增加而增加。

![[Pasted image 20230913155504-20240513171432-h77zy5p.png]]

上图中 4 个采样点中只有 2 个被遮盖住了，这个像素的颜色将会是三角形颜色与其他两个采样点的颜色（在这里是无色）的平均值，最终形成一种淡蓝色。

> MSAA 真正的工作方式是，无论三角形遮盖了多少个子采样点，每个图元中每个像素只运行**一次**片段着色器。
>
> 片段着色器所使用的顶点数据会插值到每个像素的**中心**，所得到的结果颜色会被储存在每个被遮盖住的子采样点中。
>
> 当颜色缓冲的子样本被图元的所有颜色填满时，所有的这些颜色将会在每个像素内部平均化。
>
> 对于每个像素来说，越少的子采样点被三角形所覆盖，那么它受到三角形的影响就越小。三角形的不平滑边缘被稍浅的颜色所包围后，从远处观察时就会显得更加平滑了。

````col
```col-md
flexGrow=1
===
![[Pasted image 20230913155714-20240513172118-hjy9muh.png]]
```
```col-md
flexGrow=1
===
![[Pasted image 20230913155728-20240513172131-fy9u82a.png]]
```
````

深度和模板测试也能够使用多个采样点，相应的深度和模板缓冲的大小会乘子采样点的个数。 
- 深度测试：每个顶点的深度值会在运行深度测试之前被插值到各个子样本中。  
- 模板测试：对每个子样本，而不是每个像素，存储一个模板值。

在 OpenGL 中使用多重采样，要求每个像素中存储大于 1 个颜色的颜色缓冲，为一个窗口绑定一个包含 N 个样本的多重采样缓冲可通过 GLFW 完成。

在窗口创建之前设置：

```cpp
// 包含 4 个样本的颜色缓冲
glfwWindowHint(GLFW_SAMPLES, 4);
```

之后，在 OpenGL 中启用多重采样即可，具体细节在 OpenGL 光栅器中已经实现，无需过多关心

```cpp
glEnable(GL_MULTISAMPLE);
```
# 自定义抗锯齿算法

在着色器中使用 `sampler2DMS` 替代 `sampler2D`，可以手动访问各个采样点，手动实现抗锯齿

```cpp
uniform sampler2DMS tex;

vec4 colorSample = texelFetch(tex, TexCoords, 3); // 第 4 个子样本
```

‍

#cpp17

C++ 中，函数实参传递有两种方式：按值传递，引用传递。

由于指针本身特性特殊，通常也单挑出来称作按地址传递。

在传递数组参数时，由于接收的数组长度可能不确定，因此也比较特殊。
# 按值传递

```run-cpp
static int ID {0};

class A {
public:

    A() { cout << "create A" << ", id=" << id << endl; }
    A(const A &a) { cout << "create A by A&" << ", id=" << id << endl; }
    ~A() { cout << "remove A" << ", id=" << id << endl; }

    int value {};
    int id {ID++};
};

void set_value(A a, int value) {
    a.value = value;
    cout << "Value in set_value is " << a.value << ", id=" << a.id << endl;
}

int main() {
    // create A, id=0
    A a;
    // Value before set_value is 0, id=0
    cout << "Value before set_value is " << a.value << ", id=" << a.id << endl;
    // create A by A&, id=1
    // Value in set_value is 20, id=1
    // remove A, id=1
    set_value(a, 20);
    // Value after set_value is 0, id=0
    cout << "Value after set_value is " << a.value << ", id=" << a.id << endl;
    // remove A, id=0
    return 0;
}
```

直接传递对象本体，传递的是对象的副本（使用复制构造），并在函数运行完成后释放
# 指针传递

指针传参仍然遵循按值传递的规则，但复制的是地址而非对象，因此对象本身并未被复制

```run-cpp
static int ID {0};

class A {
public:

    A() { cout << "create A" << ", id=" << id << endl; }
    A(const A &a) { cout << "create A by A&" << ", id=" << id << endl; }
    ~A() { cout << "remove A" << ", id=" << id << endl; }

    int value {};
    int id {ID++};
};

void set_value(A *a, int value) {
    a->value = value;
    cout << "Value in set_value is " << a->value << ", id=" << a->id << endl;
    a++;
}

int main() {
    // create A, id=0
    A a;
    // Value before set_value is 0, id=0
    cout << "Value before set_value is " << a.value << ", id=" << a.id << endl;
    // Value in set_value is 20, id=0
    set_value(&a, 20);
    // Value after set_value is 20, id=0
    cout << "Value after set_value is " << a.value << ", id=" << a.id << endl;
    // remove A, id=0
    return 0;
}
```
# 引用传递

引用传递不进行任何复制，传参时也不需任何其他取址等运算，接受 `A&` 类型参数

```run-cpp
static int ID {0};

class A {
public:

    A() { cout << "create A" << ", id=" << id << endl; }
    A(const A &a) { cout << "create A by A&" << ", id=" << id << endl; }
    ~A() { cout << "remove A" << ", id=" << id << endl; }

    int value {};
    int id {ID++};
};

void set_value(A &a, int value) {
    a.value = value;
    cout << "Value in set_value is " << a.value << ", id=" << a.id << endl;
}

int main() {
    // create A, id=0
    A a;
    // Value before set_value is 0, id=0
    cout << "Value before set_value is " << a.value << ", id=" << a.id << endl;
    // Value in set_value is 20, id=0
    set_value(a, 20);
    // Value after set_value is 20, id=0
    cout << "Value after set_value is " << a.value << ", id=" << a.id << endl;
    // remove A, id=0
    return 0;
}
```

使用 `T&&` 可接受 rvalue 参数，这种声明形式称为万能引用。

```run-cpp
void fun(int &value) {
    cout << "call fun(int&)" << endl;
}

void fun(int &&value) {
    cout << "call fun(int&&)" << endl;
}

int main() {
    int a = 0;
    // call fun(int&)
    fun(a);
    // call fun(int&&)
    fun(3);
    // call fun(int&&)
    fun(a + 5);
    return 0;
}
```
# 传递数组

若数组长度恒定，可以直接标明数组类型

```c++
void func(int arr[10]);
```

但如果数组长度不定，数组的传递就不是按值传递，而是第一个元素的指针，需要额外传递数组长度。

```run-cpp
void print(int arr[]) {
    cout << "arr type is " << typeid(arr).name() << endl;
    cout << "arr size is " << sizeof arr << endl;
}

int main() {
    int arr[] = {0, 1, 2, 3, 4};
    // arr type is A5_i
    cout << "arr type is " << typeid(arr).name() << endl;
    // arr size is 20
    cout << "arr size is " << sizeof arr << endl;
    cout << "==========================" << endl;
    // arr type is Pi
    // arr size is 8
    print(arr);
    return 0;
}
```

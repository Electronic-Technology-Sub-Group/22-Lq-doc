# 形参列表

>[!note] 形参：函数头和函数原型的形参列表中的参数，形参不会分配对应内存空间

>[!note] 实参：实际调用函数时传入的参数

形参列表是函数体中表示函数参数的部分。

```c++
int func(int a, float b, double c, size_t d) {
    // do something
}
```

不需要任何参数时，可以使用 `void` 填充形参列表，或留空

```c++
void no_parameter_fun1() {
    // do something
}

void no_parameter_fun2(void) {
    // do something
}
```
# 形参默认值

形参允许使用默认值，带有默认值的形参必须在普通参数之后

```c++
void fun(int a, double b, long c = 5L, bool d = false);
```
# 变长参数

函数可以接受不定长度的🇨参数，称为变长参数。

函数参数列表可以使用 `...` 结尾，表示接受变长参数，但有一些限制
* 函数至少有一个普通形参
* 可选参数必须在所有参数末尾且只能有一个
* 不能指定可选参数的类型

不定参数通过 `cstdarg` 头文件的 `va_start`, `va_arg`, `va_end` 访问

# 显式 this 参数
#cpp23 

C++ 标准中，非静态成员函数内可访问一个 `this`，该指针通常被认为是一个隐式传入的参数，函数后置的修饰符就是该参数的修饰符

```c++
struct X {
    // fun1(const X *this)
    void fun1() const {}
    // fun2(volatile X&& *this)
    void fun2(int i) volatile &&{}
};
```

C++23 允许函数第一个参数使用 `this` 修饰，表示该变量即 `this` 参数，调用时不需要显式传入。类似 `python` 的 `self`。

但这样的函数便从成员函数变成了静态函数
* 函数体内 `this` 不再可用 - 但有了 `this` 绑定的参数变量代替
* 不允许 `static`，`virtual`，`cv` 限定符

```c++
struct X {
    void fun1(this const X &self) {}
    void fun2(this volatile X &&self, int i) {}
};
```

因此，适用于形参的一些技巧便可以直接应用到 `this` 上：
* 模板
* 可以不必要是一个指针或引用，也可以是对象（适用于 `string_view` 等）
* 递归 lambda：`lambda` 是带 `operator()` 的匿名类，可以让第一个参数为 `this auto self`

```c++
auto fact = [](this auto self, int n) -> int {
    return n ? n * self(n - 1) : 1; 
}
```

# 返回值

函数执行完成后，有时要将执行结果传递给调用者，被返回的结果称为函数的返回值。

值类型会回传对应值的副本。一般来说编译器会自动使用 `move` 优化，实际效率非常高。

```c++
int sum(int a, int b) {
    // 这一句进行的操作：
    //   创建一个临时变量 t = a + b（可以在内存或寄存器中）
    //   将 t 的值复制一份，返回给调用位置
    return a + b;
}
```

若返回类型是引用，值不会进行复制，否则返回的是数据的副本。一般不会返回一个引用类型，直接返回在一个函数中创建的自动变量的引用是非常危险的

> [!danger] **永远不要**返回一个在函数栈中创建的对象的指针或引用，也不要将其以任何方法传递到函数之外

主要原因是，函数中的自动变量位于函数自己的栈中，当函数返回时，其栈空间内存会自动释放（根据编译器不同，可能表示为清空或标记为无效）。释放过的内存可以被重新申请，其存储的值是不可预测的。
# 尾置返回值

对于函数，auto 用于尾置返回值类型的占位

```c++
auto func(int a, int b) -> int {  
    return a + b;  
}
```

尾置返回值配合 decltype，常用于模板中推断返回值类型。

```c++
template<typename T>
?? add(T &a, T &b) {
    decltype(a+b) result = a + b;
    return result;
}
```

C++ 编译器扫描源码时，其顺序是自左向右扫描。因此在指定函数类型时，编译器还无法获得其形参列表，我们要让函数的返回值往后放一放，至少让编译器知道形参列表再说，此时使用自动推断类型 `auto` 关键字

```c++
template<typename T>
auto add(T &a, T &b) -> decltype(a + b) {
    return a + b;
}
```

以上，一个用于泛型的尾置返回值函数就完成了。

事实上，编译器不会去确切的求 `a+b` 的值是多少，它可以根据 `a` 和 `b` 的类型，去查找对应的运算符。因此，我们还能这么用：

```c++
template<typename T>
auto add(vector<T> &a, vector<T> &b) -> decltype(vector[0] + vector[1]) {
    return vector[0] + vector[1];
}
```

上面用到了一个泛型容器 `vector<T>`，这和数组差不多。由于不知道 `vector<T>` 长度，也就是说他可能没有数据存储在内，直接相加可能出异常，但在 `decltype` 中不需要考虑这些东西，编译器只会去查找 `vector<T>` 的 `[]` 运算符，获取他的返回值类型后再查找 `T` 的 `+` 运算符，使用他的返回值类型。
# 返回值优化
#cpp11 

> [!note] RVO：Return Value Optimization，返回值操作数为临时对象时的优化

> [!note] NRVO：NRVO：Named Return Value Optimization：返回值操作数为具名对象时的优化

> [!note] 复制消除：在函数返回一个对象时，且返回的对象在编译期可确定，不再需要调用复制构造，可以直接转移到目标位置。该优化策略即 `RVO` 和 `NRVO` 优化。

```run-cpp
struct X {
public:
    X() { cout << "X ctor\n"; }
    X(const X &x) { cout << "X copy ctor\n"; }
    ~X() { cout << "X dtor\n"; }
};

X make_x_rvo() {
    return {};
}

X make_x_nrvo() {
    X x;
    return x;
}

int main() {
    cout << "-------------------------------------\n";
    // X ctor
    X x1 = make_x_rvo();
    cout << "-------------------------------------\n";
    // X ctor
    X x2 = make_x_nrvo();
    cout << "-------------------------------------\n";
    return 0;
    // X dtor
    // X dtor
}
```

但如果编译器无法在编译时确定被构造对象是哪一个，则优化会失效：

```run-cpp
struct X {
public:
    X() { cout << "X ctor\n"; }
    X(const X &x) { cout << "X copy ctor\n"; }
    ~X() { cout << "X dtor\n"; }
};

X make_x() {
    X x1, x2;
    // 编译器无法确定返回的是 x1 还是 x2
    if (time(nullptr) % 50) {
        return x1;
    } else {
        return x2;
    }
}

int main() {
    cout << "-------------------------------------\n";
    // X ctor
    // X ctor
    // X copy ctor  --> 从此处开始，返回值优化失效
    // X dtor
    // X dtor
    X x = make_x();
    cout << "-------------------------------------\n";
    return 0;
    // X dtor
}
```

> 上面的例子中，事实上复制消除还是消除了一次复制构造的调用的，即将 `make_x()` 的返回值复制到 `main` 中的 `x` 对象上

* 复制构造必须是可访问的，否则造成语法错误
* GCC 禁用复制消除：`-fno-elide-constructors`

#cpp14 要求对于常量表达式和常量初始化而言，编译器应保证 `RVO`，禁止 `NRVO`

#cpp17 规定，在传递临时对象或从函数返回对象时，编译器应忽略对象的复制构造和移动构造。
* 复制和移动构造在这两种情况下永远不会调用和检查，因此可以不存在或不可访问
* 复制和移动构造中若还有其他副作用，也不会调用
* 最终效果是将对象直接构造到目标的存储变量上，避免临时对象的产生  
  该规定允许所有类型都可以使用工厂函数。

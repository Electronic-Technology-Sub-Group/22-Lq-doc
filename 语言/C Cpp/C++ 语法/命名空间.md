# 命名空间

`#include` 会直接将所有头文件内容复制到源文件中，当头文件中存在相同名称的元素时，会在编译阶段会产生异常

```c++ title:a.h
int doSomething(int a, int b) {
    return a + b;
}
```

```c++ title:b.h
int doSomething(int a, int b) {
    return a - b;
}
```

```c++ title:main.cpp
#include "a.h"
#include "b.h"

int main() {
}
```

预编译后生成 `main.i`，内容为

```c++
# 1 "main.cpp"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "main.cpp"
# 1 "a.h" 1
int doSomething(int a, int b) {
    return a + b;
}
# 2 "main.cpp" 2
# 1 "b.h" 1
int doSomething(int a, int b) {
    return a - b;
}
# 3 "main.cpp" 2

int main() {
}
```

可以看到，生成的 `main.i` 有重复的 `int doSomething(int, int)` 函数，预编译过了，但编译不会通过

C++ 通过命名空间将多个同名函数分割出来，使用 namespace 关键字声明命名空间。使用 `namespace` 创建命名空间，使用域解析运算符 `::` 访问

```cpp title:a.h
namespace aaa {
   int get() {
       return 3;
   }
}
```

```cpp title:b.h
namespace bbb {
    int get() {
        return 5;
    }
}
```

```c++ title:main.cpp
#include "a.h"
#include "b.h"

int main() {
    int v1 = aaa::get(); // v1 = 3
    int v2 = bbb::get(); // v2 = 5
}
```
# namespace

`namespace` 关键字可以声明一个命名空间，用于解决全局成员的命名冲突问题。

```c++
namespace aaa {
    int a {10};
}
```

命名空间是逻辑上的一种分割，因此同一个命名空间可以分布在不同文件中，同一文件中可以包含多个命名空间，也可以多次声明同一个命名空间。即使成员分布在不同文件中，名称相同的命名空间仍是同一个命名空间。

```c++ title:a.h
namespace aaa {
    int a {10};
}
```

```c++ title:b.h
namespace bbb {
    int a {100};
}
```

```c++ title:c.h
namespace aaa {
    // 冲突：与 a.h 的 a 重名
    int a {20};
}
```

```c++ title:d.h
namespace aaa {
    int b {20};
}

namespace bbb {
    int b {30};
}

// 没问题
namespace aaa {
    int c {50};
}
```

命名空间也可以嵌套

```c++ title:e.h
namespace aaa {
    namespace bbb {
        namespace ccc {
            // aaa::bbb::ccc::abc = 10
            int abc {10};
        }
    }

    namespace ddd {
        // aaa::ddd::def = 20
        int def {20};
    }
}
```
# using

可以使用 `using` 将其他命名空间的成员引入到当前作用域中，前提是没有冲突。
* `using 命名空间::成员名;`：将指定命名空间的成员导入到当前作用域
* `using namespace 命名空间;`：将指定命名空间的所有成员导入到当前作用域

```c++
#include<iostream>
#include "a.h"

// 引入 aaa 作用域的所有成员
using namespace aaa;
// 引入 std 作用域的 cin 成员
using std::cout;

void main() {
    // std::cout, aaa::get() 都已被导入到当前作用域（的父作用域）中，因此可以直接访问
    // std::endl 还没有被导入，因此需要域解析
    cout << get() << std::endl;
  
    using std::endl;
    // 这里导入了 std::endl，因此可以直接使用了
    // 但注意的是 std::endl 导入在 main 函数的作用域中，using 之前和 main 之外仍未导入
    cout << endl;
}
```
# 内联命名空间
#cpp11 

允许将某个命名空间内的成员导出到父命名空间中

```c++
namespace A {
    inline namespace B {
        void foo();
    }

    namespace C {
        void foo();
    }
}

// 等效于 A::B::foo();
A::foo();
A::C::foo();
```

该功能主要用于对旧 lib 升级时保证兼容性使用
# 嵌套命名空间
#cpp17 

将多个嵌套的命名空间缩写成一个，之间使用 `::` 连接，支持 `inline`

```c++
namespace A::B::inline C::D {
    foo();
}
```

以上代码等效于：

```c++
namespace A {
    namespace B {
        inline namespace C {
            namespace D {
                foo();
            }
        }
    }
}
```

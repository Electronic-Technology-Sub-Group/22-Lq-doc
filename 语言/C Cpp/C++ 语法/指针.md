> [!note] 指针：存储内存地址的变量

指针变量名称常以 `p` 为前缀，其作用包括但不限于：
* 处理数组数据：数组名指代第一个元素的地址
* 访问函数外的大块数据：使用指针传参，避免复制
* 动态分配内存：使用 `new` 和 `delete` 在堆上动态分配内存，节省栈空间

内存地址通过对变量使用取址运算符 `&` 获取，使用 `*` 声明

```c++
int value {10};
int *p = &value;
```

> [!note] 一般来说，`*` 符号靠近变量名，表示该变量是一个指针。

```c++
// p 是一个 int 类型指针，未初始化
// a 和 b 是一个整形
// pa 是一个 int 类型指针，指向 a
int *p, a {10}, *pa {&a}, b {20};
```

指针地址可以直接输出，也可以转化成 `intptr_t` 类型将其转化成数字。

> [!danger] 未初始化的指针指向不可预测的内存区域，其地址随机，直接使用很危险
> 在声明指针后应当使用具体地址初始化。若没有具体指向地址，或对象已删除时，应当使用空指针对其初始化。

指针可以用作 `if` 判断，任何非空指针可隐式转化为 `true`
# nullptr
#cpp11

传统 C 使用 0 表示空指针。由于 C++ `void*` 不能直接隐式转换为指针，其定义就是 `0` 而非 `(void*) 0`

```c++
cout << typeid(NULL).name() << endl; // x
cout << typeid(0LL).name() << endl;  // x -- 证明 NULL 的类型就是长整型
```

```cpp title:'模拟 NULL 声明' fold
#ifndef MY_NULL
    #ifdef __cplusplus                    // c++
        #define MY_NULL 0
    #elif                                 // c
        #define MY_NULL ((void*) 0)
    #endif
#endif
```

在 C++ 函数重载时会引起二义性问题：

```run-cpp
void f(int v) {
    cout << "int " << v << endl;
}

void f(char* c) {
    cout << "str " << c << endl;
}

int main() {
    // gcc：call of overloaded 'f(NULL)' is ambiguous
    // 据书上说 vs 下调用的是 int 的重载
    f(NULL);
    return 0;
}
```

`NULL` 即 `0LL` 既可以被隐式转换为 `int`，又可以隐式转换为 `char*`，根据重载规则产生二义性问题。不同编译器对运行结果处理不同。

`nullptr` 关键字表示一个 `std::nullptr_t` 类型的纯右值表示一个空指针
* 禁止进行数学运算，禁止与非指针类型进行比较
* 可以隐式转换为任何类型指针类型，无法隐式转换为任何非指针类型
* 长度为 `sizeof(void*)`

可以创建一个 `nullptr_t` 类型指针的新实例

```c++
using nullptr_t = decltype(nullptr);
nullptr_t my_null;
```

* 相同点：
    * `my_null` 可以与 `nullptr` 进行比较，结果为 `true`
    * `my_null` 在指针上的性质与 `nullptr` 相同
    * `sizeof(my_null) == sizeof(void*)`

* 不同点：
    * `nullptr` 是关键字，`my_null` 不是
    * `nullptr` 是纯右值，`my_null` 是左值，`&nullptr` 是错误的

利用 `nullptr_t` 配合模板，我们可以对空指针进行特化处理

```run-cpp
template<typename T>
void use(T *p) {
    cout << "p is " << typeid(*p).name() << endl;
}

template<>
void use<nullptr_t>(nullptr_t *p) {
    cout << "p is nullptr" << endl;
}

int main() {
    // p is nullptr
    use<nullptr_t>(nullptr);
    // p is So
    use(&cout);
    return 0;
}
```
# 动态内存分配

`new` 用于在堆上申请内存的关键字和运算符，并返回该内存块的首地址指针。可以申请一个任意类型的值或一个数组，返回对应类型的指针。

> [!note] 堆，又称空闲存储器，计算机中分配给程序的未使用的内存

```c++
int *a = new int;

int **b = new int[10];

int count = 20;
int **c = new int[count];
```

如果内存空间不足以容纳申请的值，则会返回 `nullptr`。

> [!info] 不需要刻意去检查，如果内存不足程序会直接抛出异常。

`delete` 用于在堆上释放内存的关键字和运算符，可以释放使用 `new` 申请的堆内存，但不会修改原指针的值。

> [!warning] 使用 `new` 创建的指针需要使用 `delete` 释放，以免造成内存溢出

```c++
int *a = new int;

int **b = new int[10];

int count = 20;
int **c = new int[count];

delete a;
delete [] b, c;
```

可以直接释放 `nullptr`，这时不会进行任何操作。但若被释放的指针不是 `nullptr` 且对应的内存不是由 `new` 申请的，或已经被释放了，则会抛出异常。

> 使用 `delete` 释放后的内存，其值是不可预测的，应当立即将指针赋值为 `nullptr` 以免出问题。
>
> 尽量遵循 **谁申请谁销毁** 或提供 **足够明确** 的提示

```c++
int *a = new int;
delete a;
a = nullptr;
```

>[!error] 悬垂指针：指针经 `delete` 释放后，原地址理论上来说就无效了，再通过该地址访问数据获取的是不可预测的数据。这种指针称为悬垂指针

> [!error] 内存泄漏：非自动内存没有释放，通常是手动 `new` 或 `malloc` 申请的内存没有 `delete` 或 `free`，当该地址丢失后，指向的内存永远无法被 C++释放，这种情况称为内存泄漏

````tabs
tab: 一般值，类，结构体
直接通过 `new` 和 `delete` 即可申请和释放
<br/>

```cpp
// 申请内存
double *pvalue {};
pvalue = new double;
*pvalue = 999.0;
// 以上申请和赋值可以简化成这一句
double *pvalue2 { new double { 999.0 } };
// 释放内存
delete pvalue;
delete pvalue2;
// 防止悬垂指针
pvalue = nullptr;
pvalue2 = nullptr;
```

tab: 数组
使用 `[]`
* 可在运行时决定数组长度
* 可创建每个维度长度不同的多维数组
<br/>

```cpp
int *pdata { new int[5] { 1, 3, 5, 7, 9 } };
delete [] pdata;
pdata = nullptr;
```

<br/>

多维数组在申请时，最外层数组长度必须是明确的。而释放内存时，无论多少维，均使用 `delete []`

<br/>

```cpp
double (*pvalues)[5] { new double[3][5] };
delete [] pvalues;
pvalues = nullptr;
```
````
## 数组长度推导
#cpp20 

在使用 `new` 创建数组时，可以自动计算数组长度，规则与数组声明时推导长度一致，对于创建字符串尤其方便。

```c++
int *i = new int[]{1, 2, 3};
char *c = new char[]{"hello world"};
```
## 独立的 delete 调用
#cpp20 

允许通过自定义运算符时添加 `std::destorying_delete_t` 参数，禁止在 `delete` 运算符前调用析构函数。此时应该手动在合适的位置调用析构函数。

> [!note] `std::destorying_delete_t` 参数本身没有用途，只是向编译器发出通知。

```run-cpp
struct X {
    ~X() {
        cout << "dtor X\n";
    }

    void* operator new(size_t s) {
        return ::operator new(s);
    }

    // 这里添加 std::destroying_delete_t 参数 ↓↓↓
    void operator delete(X* ptr, std::destroying_delete_t) {
        cout << "delete X\n";
        ptr->~X(); // ← 手动调用析构函数
        ::operator delete(ptr);
    }
};

int main() {
    X *x = new X;
    // delete X
    // dtor X
    delete x;
    return 0;
}
```
# 指针运算

# 指针运算

* `指针 +/- 数字`：将指针地址加/减 n 个对应类型的长度
* `指针 - 指针`：将指针地址相减，并将结果除以类型长度

```c++
int value = 10;
int *pvalue = { &value };
int *pnext = pvalue + 1; // 地址为 pvalue + 1 * sizeof(int)
```

`void*` 类型可以转换为任何指针类型，但不能使用指针运算

```run-cpp
int main() {
    int arr[]{0, 1, 2, 3, 4};
    int *parr = arr;

    // parr     = 0x81b0fffa00 = 0
    cout << "parr     = " << parr << " = " << *arr << endl;
    // parr + 1 = 0x81b0fffa04 = 1
    cout << "parr + 1 = " << (parr+1) << " = " << *(arr+1) << endl;
    // parr + 2 = 0x81b0fffa08 = 2
    cout << "parr + 2 = " << (parr+2) << " = " << *(arr+2) << endl;

    void *parr2 = parr;
    long long *parr2l = static_cast<long long *>(parr2);

    // parr + 1L= 0x81b0fffa08 = 2
    // 转换成 long long* 类型，每次运算偏移量为 sizeof(long long) = 8
    // 因此 parr2l+1 == parr+2
    // 在输出时候，重新强转回 int*，否则结果会出错
    cout << "parr + 1L= " << (parr2l+1) << " = " << *(int*)(void*)(parr2l+1) << endl;
    
    return 0;
}
```
# 指针与 const

**判断方法：靠近谁，`const` 修饰谁**

````tabs
tab: 指向常量的指针
对象本身不可修改，指针地址可以修改
<br/>

```cpp
int value {5};
const int *pvalue { &value }; // const 修饰 int 类型
*pvalue = 6; // 错误： pvalue 指向 const int 类型
pvalue = nullptr; // 正确
```

tab: 指向对象的常量指针
对象本身可以修改，指针地址不可修改
<br/>

```cpp
int value {5};
int *const pvalue { &value }; // const 修饰 pvalue 变量本身
*pvalue = 6; // 正确
pvalue = nullptr; // 错误
```

tab: 指向常量的常量指针
对象本身和指针地址都不可修改
<br/>

```cpp
int value {5};
const int *const pvalue { &value };
*pvalue = 6; // 错误
pvalue = nullptr; // 错误
```
````
# 智能指针

一种模板对象。行为类似指针，但可以以一定规则管理引用，减少手动 `delete`，避免造成内存泄露。

智能指针位于 memory 头文件中。
# 数组与指针

对于数组，数组名可以直接当作指向数组第一个元素的指针使用

```c++
int array[] {1, 2, 3, 4, 5};
int *parr0 = array;
```

数组名和第一个元素的地址的区别在于其类型，数组名对应的类型是数组，包含了数组长度，而指针类型是指针，不包含数组长度，不能用 `sizeof` 等计算数组长度

```run-cpp
int arr[] {0, 1, 2, 3};
int *parr = arr;

int main() {
    cout << typeid(arr).name() << endl; // A4_i
    cout << typeid(parr).name() << endl; // Pi
    return 0;
}
```

根据指针运算规则，可以通过指针访问数组元素

```run-cpp
int main() {
    int arr[]{0, 1, 2, 3, 4};
    int *parr = arr;

    // parr     = 0x413b7ffc50 = 0
    cout << "parr     = " << parr << " = " << *arr << endl;
    // parr + 1 = 0x413b7ffc54 = 1
    cout << "parr + 1 = " << (parr+1) << " = " << *(arr+1) << endl;
    // parr + 2 = 0x7d831ff7c8 = 2
    cout << "parr + 2 = " << (parr+2) << " = " << *(arr+1) << endl;
    
    return 0;
}
```

指针每次运算的偏移量是根据其类型决定的，可以通过更改指针类型更改偏移量
* `data[0]` 等效于 `*data`，地址等效 `&data[0]`
* `data[i]` 等效于 `*(data + i)`，地址等效 `&data[i]`

#cpp11 

使用 `...` 定义任意个数、任意类别的模板参数，不必在定义时固定参数个数

```c++
// 函数模板
template<class ...Args>
void foo(Args ...args) {
    // do something
}

// 类模板
template<class ...Args>
class bar {
public:
    bar(Args ...args) {
        // do something
        foo(args...);
    }
};
```

* `class ...Args`：类型模板形参包，接受零个或多个类型的模板形参
* `Args ...args`：函数形参包，出现在函数形参列表中，接受零个或多个函数实参
* `args...`：形参包展开，将形参包展开为零个或多个模式列表（解包）

可变参数模板在模板函数中，配合函数的不定长参数可安全的处理不定长参数的类型

```c++
template<typename... PARAMS> void printf(const std::string &str, PARAMS.. parameters);
```

可变参的一些特点与限制：

1. 不能使用类型自动推断，但可以手动指定类型：

```c++
template<class ...Args>
class bar {
public:
    bar(Args ...args) {
        // do something
        foo(args...);
    }
};

int main() {
   bar<> b1;
   bar<int> b2;
   bar<int, double> b3;
}
```

2. 类模板中，可变参数模板必须是最后一个模板参数，但函数模板中可以不是，只要保证后续参数类型能匹配即可

```c++
template<class ...Args, class T, class U = double>
void foo(T, U, Args ...args);
```

3. 可变参数适用于非类型模板形参

```c++
template<int ...Args>
void foo();

foo<1, 2, 10, 20>();
```

4. 在进行模板匹配时，可变参的优先级低于有固定数量参数的模板

#cpp11 

形参包展开的形式是一个包含形参包的表达式后加 `...`，可用于大部分常见场景：
* 表达式列表，初始化列表，成员初始化列表
* 函数参数列表，lambda 表达式捕获列表，模板参数列表
* 基类描述，C++17前动态异常列表，属性列表
* `sizeof...` 运算符

```run-cpp
template<class T, class U>
T baz(T t, U u) {
    cout << t << ": " << u << endl;
    return t;
}

template<class ...Args>
void foo(Args ...args) {
}

template<class ...Args>
struct bar {
    bar(Args ...args) {
        foo(baz(&args, args)...);
    }
};

int main() {
    bar b(1, 5.0, 8LL, "hello");
    return 0;
}
```

代码片段中展示了如何展开形参包的过程，其运行结果有点类似于 `foreach`。

`foo` 是一个中间函数，实际什么都不做，只是承载中间的计算结果。

`bar` 类在其构造函数中对形参包进行展开，其中 `bar(&args, args)...` 就是包展开，`bar(&args, args)` 是模式，即展开的方法。该代码相当于：

```c++
struct bar {
    bar(int v1, double v2, long long v3, const char *v4) {
        auto p4 = baz(&v4, v4);
        auto p3 = baz(&v3, v3);
        auto p2 = baz(&v2, v2);
        auto p1 = baz(&v1, v1);
        foo(p1, p2, p3, p4);
    }
};
```

现在，我们再嵌套一层：

```c++
template<class ...T>
int baz(T ...t) {
    // ...
    return 0;
}

template<class ...Args>
void foo(Args ...args) {
}

template<class ...Args>
struct bar {
    bar(Args ...args) {
        foo(baz(&args) + args...);
    }
};
```

该代码涉及到两层包展开：

1. `baz(&args)` 在 `baz(T ...t)` 中进行展开，结果为 `baz(&v1, &v2, ...)`
2. `foo(baz(args) + args...)` 在 `foo(Args ...args)` 中进行展开

最终结果为：

```c++
foo(
    baz(&v1, &v2, &v3, ...) + v1, 
    baz(&v1, &v2, &v3, ...) + v2, 
    baz(&v1, &v2, &v3, ...) + v3, 
    ...
)
```

形参包展开的模式非常灵活，比如：

```run-cpp
int add(int a, int b) { return a + b; }

int sub(int a, int b) { return a - b; }

template<class ...Args>
std::pair<int, int *> build_array(Args (*...op)(int, int)) {
    int count = 0;
    int tmp[] = {(count++, op(7, 11)) ...};
    int *arr = new int[count];
    memcpy(arr, tmp, count * sizeof(int));
    return {count, arr};
}

int main() {
    auto [count, array] = build_array(add, sub);
    // Array 0x1bd597d1a80 has 2 values.
    cout << "Array " << array << " has " << count << " values." << endl;
    // 18 -4 
    for (int i = 0; i < count; ++i) cout << array[i] << ' ';
    cout << endl;
    delete[] array;
    return 0;
}
```

该代码将包展开用于构造数组，在 `build_array` 中展开的结果为（仅节选包展开部分）：

```c++
// int tmp[] = {(count++, op(7, 11)) ...};
int tmp[] = {
    (count++, add(7, 11)),
    (count++, sub(7, 11))
};
```

其中，`(count++, op(7, 11)) ...` 为包展开，`(count++, op(7, 11))` 为包展开模式。

这种模式还可以用于类继承：

```c++
template<class ...Args>
class derived: public Args... {
public:
    derived(const Args& ...args): Args(args)... {}
};
```

构造函数中涉及到了包展开，`Args(args)...` 是包展开，`Args(args)` 是模式。

包展开还可以用于 `lambda` 表达式中，一个比较常见的使用场景是延迟计算：

```c++
template<class F, class ...Args>
auto delay_invoke(F f, Args ...args) {
    return [f, args...]() -> decltype(auto) {
        return std::invoke(f, args...);
    };
}
```

例子中包含两次展开：

第一次在捕获列表中，将参数捕获

第二次在函数调用中，将捕获的参数作为参数传入

通过形参包的展开，还可以实现类似于 `reduce` 函数的递归形式：

```c++
template<class T>
T sum(T arg) {
    return arg;
}

template<class T, class ...Args>
auto sum(T begin, Args ...args) {
    return begin + sum(args...);
}
```

在 `sum(T, Args)` 中进行了展开，每次都会将 `...args` 中的第一个值作为 `begin` 加入函数并消掉，最后只剩下一个值由 `sum(T)` 接收。最后的结果类似于以下的递归调用：

```c++
auto sum(v1, v2, v3, v4, v5, v6, ...) {
    // v1 + (v2 + (v3 + (v4 + (v5 + (v6 + (...))))))
    return v1 + sum(v2, v3, v4, v5, v6, ...);
}
```

# 折叠表达式
#cpp17 

形参包展开可用于替代递归的形参包展开，于是我们可以写成：

```c++
template<class ...Args>
auto sum(Args ...args) {
    return (args + ...);
}
```

C++17 添加以下四种折叠表达式，其中 `op` 为任意二元运算符，`k` 为任意值，`args` 为形参包名，其中的值为 `v1, v2, v3, ..., vN`：
1. `(args op ...)` 展开得 `(v0 op (v1 op (v2 op (v3 op (...)))))`
2. `(... op args)` 展开得 `(((v0 op v1) op v2) op v3) op ...`
3. `(args op ... op k)` 展开得 `(v0 op (v1 op (v2 op (v3 op (... op (vN op k))))))`
4. `(k op ... op args)` 展开得 `(((v0 op v1) op v2) op v3) op ...`

其中，第 1 和第 2 条在空包（即 `args` 中没有值）的情况下会有问题，因为 `op` 是二元运算符，第 3，4 条由于额外的一个 `k` 得以避免。于是有了以下规则：
* 仅 `op` 为 `&&`，`||`，`,` 运算符时支持空包
* `&&` 的空包结果为 `true`，`||` 的空包结果为 `false`
* `,` 的空包结果为 `void()`
# using 包展开
#cpp17 

允许 using 声明列表内的包展开，便于可变参数类模板派生于形参包的情况

```c++
template<class T>
class base {
public:
    base() {}
    base(T t) {}
};

template<class ...Args>
class derived : public base<Args>... {
public:
    using base<Args>::base...;
};
```
# λ 初始化捕获包展开
#cpp20 

在之前的 `delay_invoke` 实例中，如果参数过大会产生过多的额外消耗（因为这里是复制构造）。如果是使用引用传递，又依赖于外部的函数环境，因此使用初始化捕获+移动语义是一个比较合理的解决方案：

```c++
template<class F, class ...Args>
auto delay_invoke(F f, Args ...args) {
    using namespace std;
    return [f = move(f), tup = make_tuple(move(args)...)]() -> decltype(auto) {
        return apply(f, tup);
    };
}
```

这样使用 `tuple` 进行打包，但一旦复杂起来（例如固定被调函数 `f`，此时需要在 `apply` 第一个参数传入一个 `lambda` 表达式中使用引用）难以理解

```c++
template<class ...Args>
auto foo(Args ...args) {
    return (args + ... + 0);
}

template<class ...Args>
auto delay_invoke(Args ...args) {
    return [tup = std::make_tuple(std::move(args)...)]() -> decltype(auto) {
        return std::apply([](auto& ...args) -> decltype(auto) { return foo(args...); } , tup);
    };
}
```

可以使用形参包展开的初始化捕获。但与普通包展开的形式有所不同的是，`...` 在模式之前

```c++
template<class ...Args>
auto foo(Args ...args) {
    return (args + ... + 0);
}

template<class ...Args>
auto delay_invoke(Args ...args) {
    return [...args = std::move(args)]() -> decltype(auto) {
        return foo(args...);
    };
}
```

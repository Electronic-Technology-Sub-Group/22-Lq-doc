# 局部和匿名类型作为模板实参
#cpp11 

允许局部和匿名类型作为模板实参

```cpp
template <class T> class X {};
template <class T> void f(T t) {};

// 匿名类型
struct {} unnamed_obj;

int main() {
    // 局部类型
    struct A {};
    typedef struct {} B;
    // 局部匿名类型
    enum { e };

    X<A>  x1;
    X<A*> x2;
    X<B>  x3;
    f(e);
    f(unnamed_obj);
    B b;
    f(b);
    return 0;
}
```
# 经转换表达式
#cpp17 

对于任何类型的非类型模板形参使用的实参，都可以使该模板形参类型的任何经转换表达式

> C++17 之前，作为模板实参的值有比较严格的要求，最主要的是链接和静态：
>
> * 整型：经转换（可以隐式转换成整数）的常量表达式
> * 对象指针：静态，或有内部或外部链接的完整对象
> * 函数指针：有链接的函数指针
> * 左值引用：有内部或外部链接
> * 成员指针：静态成员
# 非类型模板参数中的字面量类类型
#cpp20 

允许非类型模板参数中的字面量类类型，字面量类类型可用于非类型模板参数，限制有：
* 所有基类和非静态数据成员都是 `public` 且不可变的
* 所有基类和非静态数据成员都是标量类型、左值引用或其数组

```cpp
// 一个类类型
template<class T, size_t N>
struct basic_fixed_string {
    T data[N + 1];

    constexpr basic_fixed_string(const T(&foo)[N + 1]) {
        copy_n(foo, N + 1, data);
    }
};

// 允许一个字符串隐式转换成 basic_fixed_string
template<class T, size_t N>
basic_fixed_string(const T(&foo)[N]) -> basic_fixed_string<T, N - 1>;

template<basic_fixed_string str>
struct X {
    X() {
        cout << str.data;
    }
};

int main() {
    // 实参
    X<"hello world"> x;
    return 0;
}
```

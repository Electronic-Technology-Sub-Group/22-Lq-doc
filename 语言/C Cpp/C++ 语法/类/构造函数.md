构造函数是没有返回值，名称与类名相同的函数。

```c++
class A {
public:
    // 任意其他构造
    A(int a) {}
    // 手动声明默认构造
    A() = default;
}
```
# 默认构造

当一个类没有构造函数时，C++ 默认生成一个 `public` 的无参构造，实现也为空。当类中存在任何其他构造函数时，默认构造函数不会生成。
# 初始化列表

构造函数中可以使用初始化列表为类成员变量赋值，在构造函数体之前执行。

```c++
class A {
    public:
    int value;
  
    A(int v): value {v} {};
}
```

`value {v}` 是初始化列表，以 `,` 分割，可以为函数成员变量直接赋值。
# 隐式转换

如果一个构造函数只接受一个参数，且没有 `explicit` 修饰，就可以将构造接受的参数直接赋值给该类型变量，编译器会隐式调用该构造函数创建对象。这是实现类与结构体的隐式转换方式之一。

```run-cpp
class Box {
public:
    int width;
    int height;
  
    Box(int i): width {i}, height {i} {
        cout << "Create by int " << i << endl;
    }
};

int main() {
    int i = 5;
    // Create by int 5
    Box b1 = i;
    // Create by int 10
    Box b2 = 10;
    return 0;
}
```
# 委托构造
#cpp11 

委托构造：构造函数调用其他构造函数，使用 `:` 指定，但要避免循环构造。
代理构造：被委托的构造函数

```c++
class SomeType {
  int number;
  string name;
  SomeType( int i, string& s ) : number(i), name(s){}
public:
  SomeType( )           : SomeType( 0, "invalid" ){}
  SomeType( int i )     : SomeType( i, "guest" ){}
  SomeType( string& s ) : SomeType( 1, s ){ PostInit(); }
};
```

> [!warning] 委托构造不能有任何初始化列表。

委托构造函数的执行顺序如下：
* 代理构造的成员初始化列表
* 代理构造的函数体
* 委托构造的函数体
## 委托异常捕获
#cpp11

在委托时捕获异常，当代理构造产生异常，程序跳转到 `catch` 块执行

```c++
class A {
public:
  
    A() try: A(1.0) {
        // 正常构造 A
    } catch (int code) {
        // 异常 A
    }

    A(int a) try: A(a, 0.0) {
        // 正常构造 B
    } catch (int code) {
        // 异常 B
    }

    A(double b) try: A(1, b) {
        // 正常构造 C
    } catch (int code) {
        // 异常 C
        throw -2;
    }

    A(int a, double b) {
        // 委托构造
        throw -1;
    }
};
```

调用 `A(int)` 时，执行顺序为：委托构造 - 异常 B  
调用 `A()` 时，执行顺序为：委托构造 - 异常 C - 异常 A
## 委托模板构造
#cpp11

构造函数允许使用模板，因此可以将其他构造函数委托到一个模板函数进一步减少重复代码

```c++
class A {
private:
    template<class T>
    A(T a, T b) {
        // do something
    }
public:
    A(vector<int>& list): A(list.begin(), list.end()) {}
    A(deque<int>& list): A(list.begin(), list.end()) {}
};
```
# 复制构造

复制构造是 C++ 自动生成的构造函数，是一个接受当前类引用的构造函数。默认复制构造是直接复制所有类成员的变量。

```c++
class A {
public:
    A(A &other) {
    // custom copy constructor
    }
}
```

复制构造触发的场景包括使用赋值运算符将一个同类型变量复制给另一个变量，函数调用的直接传参，函数返回值返回对象等

```run-cpp
class A {
    string name;
    int times;
public:
    A(const char* name) : name{name}, times{0} {
        cout << "Create A " << name << endl;
    }

    A(const A &another) : name{another.name}, times{another.times + 1} {
        cout << "Copy from " << name << ", copy times " << another.times << " -> " << times << endl;
    }

    void print() {
        cout << "A " << name << "[" << times << "]" << endl;
    }
};

A print_a(A a) {
    a.print();
    return a;
}

int main() {
    cout << "===" << endl;
    A a {"a"};
    cout << "===" << endl;
    A a2 = a;
    cout << "===" << endl;
    a2 = print_a(a2);
    cout << "===" << endl;
    a2.print();
    cout << "===" << endl;
    return 0;
}
```

**任何涉及到手动分配内存，保存其指针的类，都应重写复制构造函数并在复制构造中使用** **`memcpy`** **等方式深复制其数据**。

```c++
class A {
    int* value;

public:
    A() {
        value = new int[5];
    }
  
    A(const A &another) {
        value = new int[5];
        memcpy(value, another.value, 5 * sizeof(int));
    }
  
    ~A() {
        delete [] value;
        value = nullptr;
    }
};
```
# 移动构造

移动构造是一个接受当前类型 `rvalue` 引用的构造函数 `(T&&)`，通常在将一个右值赋给变量时调用。在没有创建自己的移动构造的情况下，默认调用复制构造。

当对象在堆上包含大量数据时，移动构造可以只将对指针移动给新对象，不需要进行复制，提高性能。

移动构造调用后，原对象是否仍持有原始数据是一个不确定行为。为保证数据安全，移动构造不能产生异常，使用 noexcept 修饰。
## 复制构造优化

#Cpp11 将一些曾经使用复制构造的地方使用移动构造以提高效率。

```c++
struct X;

X f(X x) {
    return x;
}

int main() {
    // C++11 以后使用移动构造而非复制构造
    X r = f(X{});
}
```

#cpp20 对右值引用和 `throw` 进行扩展。该标准规定以下情况可以采用移动代替复制：
* `return`，`co_return` 返回的对象是函数或 lambda 表达式中的对象或形参
* `throw` 抛出的对象是 `try` 块中的对象
# 初始化列表构造
#cpp11

```c++
class A {
    public:
    A(std::inititalizer_list<int> list);
}

A a = {1, 3, 5, 7, 9};
```

接收 `std::initializer_list` 的构造函数称为**初始化列表构造函数**，`vector<T>` 等标准容器类型都包含了这类构造。

初始化列表构造统一了普通对象/结构体、数组、STL 容器等的初始化方式

```c++
int x[] { 1, 2, 3 };
std::vector<int> y { 1, 2, 3 };
std::set<int> z { 1, 2, 3 };
std::map<int, char> w { {1, 'a'}, {2, 'b'}, {3, 'c'} };
```

`std::inititalizer_list<T>` 类为标准类，可以在其他地方使用，类似于限定类型的可变参数

```c++
void f(std::initializer_list<float> list);

f({1f, 2f, 3f});
```

使用 `{}` 初始化既可以匹配一般构造函数，也可以匹配列表构造函数。当可以同时匹配普通构造函数和列表构造函数时，c++ 优先使用列表构造初始化。
# explicit
#cpp11 

C++ 默认的隐式转换会产生很多奇怪的结果

````tabs
tab: 例 1

```run-cpp
template<class T>
class Storage {
private:
    vector<T> data;
public:
    operator bool() const { return data.empty(); }
};

int main() {
    Storage<char> a;
    Storage<double> b;
    auto c = a + b;
    cout << "c=" << c << ", " << typeid(c).name() << endl;
    return 0;
}
```

<br/>

`c=a+b`，`a` 和 `b` 本身应该不允许直接相加，但隐式转换为 `bool` 后可以添加。

tab: 例 2

```cpp
class SomeString {
    friend void PrintStr(const SomeString& str);
public:
    SomeString(const char* s) {}
    SomeString(int alloc_size) {}
};

void PrintStr(const SomeString& str) {}

int main() {
    PrintStr("Hello World");
    PrintStr(42);
    return 0;
}
```

<br/>

`PrintStr` 函数接受字符串，当传入数字时，隐式转换成了 `SomeString`，但本意非如此。
````

`explicit` 关键字修饰的函数不能用于隐式转换，只能用于显式转换

````tabs
tab: 修饰类型转换运算符

```run-cpp
template<class T>
class Storage {
private:
    vector<T> data;
public:
    explicit operator bool() const { return data.empty(); }
};

int main() {
    Storage<char> a;
    Storage<double> b;
    // Invalid operands to binary expression ('Storage<char>' and 'Storage<double>')
    auto c = a + b;
    return 0;
}
```

tab: 修饰构造函数

```run-cpp
class SomeString {
    friend void PrintStr(const SomeString& str);
public:
    SomeString(const char* s) {}
    explicit SomeString(int alloc_size) {}
};

void PrintStr(const SomeString& str) {}

int main() {
    PrintStr("Hello World");
    // No matching function for call to 'PrintStr'
    PrintStr(42);
    // ok
    PrintStr(static_cast<SomeString>(42));
    return 0;
}
```
````
## explicit 默认构造
#cpp17

允许使用 explicit 修饰默认构造，或将默认构造相关声明移动到类之外，以创建一些特定的非聚合类

```c++ title:不可实例化的类
struct A {
    explicit A() = delete; // 使用 explicit 声明
}
// or
struct A {
private:
    A();
}
A::A() = default; // 将构造函数移出
```
## explicit(bool)
#cpp20 

explicit 允许接受一个 `bool` 常量表达式，指定 `explicit` 修饰的功能是否生效。

我们需要的效果是这样的：

```c++
pair<string, string> safe(const char* first, const char* second) {
    return {first, second};
}

pair<vector<int>, vector<int>> unsafe(int first, int second) {
    return {first, second};
}
```

`unsafe` 编译失败。这是符合直觉的 - `const char*` 可以转化为 `string`，但 `int` 不能转换为 `vector<int>`

首先考虑 `vector(T...)` 构造函数被 `explicit` 修饰，但实际上并不是，因为 `pair` 构造中为 `first`，`second` 赋值是通过间接构造完成，在构造时是显式调用的构造函数，不受 `explicit` 影响。

```c++
template<class F, class S>
class MyPair {
    F _f;
    S _s;
public:
    template<class _F, class _S>
    // 显式调用构造函数
    MyPair(_F &f, _S &s): _f(f), _s(s) {
    }
};

MyPair<vector<int>, vector<int>> unsafe(int first, int second) {
    return {first, second};
}
```

若要解决这个问题，我们可以给 `MyPair` 的构造函数添加 `explicit` 修饰以禁用该构造函数：

```c++
template<class F, class S>
class MyPair {
    F _f;
    S _s;
public:
    template<class _F, class _S>
    // 显式调用构造函数
    explicit MyPair(_F &f, _S &s): _f(f), _s(s) {
    }
};
```

但这样 `safe` 函数也不能正常完成编译了。这时候考虑使用 `SFINAE` 进行条件编译

```c++
template<class F, class S>
class MyPair {
    F _f;
    S _s;
public:
    template<class _F = F, class _S = S>
    // 约束：
    //    1. F 可通过 _F 构造，S 可通过 _S 构造
    //    2. _F 可转换为 F，_S 可转换为 S
    requires is_constructible_v<F, _F> && is_constructible_v<S, _S> 
          && is_convertible_v<_F, F>   && is_convertible_v<_S, S>
    MyPair(_F &f, _S &s): _f(f), _s(s) {
    }
  
    template<class _F = F, class _S = S>
    requires is_constructible_v<F, _F> && is_constructible_v<S, _S>
    explicit MyPair(_F&&, _S&&);
};
```

此时，可通过 `explicit` 进行开关控制：

```c++
template<class F, class S>
class MyPair {
    F _f;
    S _s;
public:
    template<class _F = F, class _S = S>
    requires  is_constructible_v<F, _F> &&  is_constructible_v<S, _S>
    explicit(!is_convertible_v<_F, F>   || !is_convertible_v<_S, S>)
    MyPair(_F &f, _S &s): _f(f), _s(s) {
    }
};
```
# constexpr 构造

constexpr 修饰类、结构体构造函数，该类或结构体可以在编译时实例化。
* 可以有参数，初始化列表必须是编译时常量表达式（参数视为常量）
* 函数体必须为空
* 所在类虚函数是平凡的（没有自定义析构、虚析构，所有成员对析构都是平凡的）

使用 `constexpr` 修饰的常量只能使用 `constexpr` 构造函数。带有 `constexpr` 构造函数的类称为*字面量类型（literal class type）* 。

`constexpr` 构造函数在实参非编译时常量表达式时，退化成普通构造函数。

类析构函数没有参数，函数名为 `~类名`，通常用于释放类申请的内存，调用时机包括：
* 对于 new 申请的内存，使用 `delete` 释放时
* 普通变量在其生存期结束时（如函数返回时）

若类不存在析构函数，则编译器会默认生成一个非虚函数的无任何实现的析构函数。

如果将一个派生类赋值给其基类类型的变量（或指针）时，析构时析构函数的调用规则为：
* 析构函数为虚函数时，总是会调用子类的析构函数
* 析构函数为非虚函数时，若值对应的类型是子类，则调用子类构造，否则调用基类构造

```run-cpp
class A {
public:
    ~A() {
        cout << "~A" << endl;
    }
};

class B : public A {
public:
    ~B() {
        cout << "~B" << endl;
    }
};

int main() {
    B *b1 = new B{};
    B *b2 = new B{};
    A *a1 = b1;
    cout << "===\n";
    delete a1;
    cout << "===\n";
    delete b2;
    cout << "===\n";
    return 0;
}
```

> [!note] 一个类若重写析构函数，且可能派生子类，则必须将析构函数声明成虚函数
# 伪析构函数结束对象生命周期
#cpp20

```c++
template<class T>
void destroy(T* p) {
    p->~T();
}
```

* 若 `T` 为非平凡类型时，`~T()` 对结束对象的生命周期；
* 若 `T` 为平凡类型，如 `int` 等，C++20 之前 `~T()` 会被认为是无效语句，C++20 之后则会结束对象生命周期。

使用 `:` 表示继承关系

```c++
class A : [private/protected/public] [BaseClass] {
// ...
}
```

`[BaseClass]` 即基类（或叫父类），`[private/protected/public]` 表示子类（派生类）可以访问基类的内容（权限）
* `private`：子类无法继承基类的 `private` 成员，基类 `protected`，`public` 成员以 `private` 权限传递给子类，表示 `implemented-in-terms-of` 关系，只有实现部分被继承，接口部分被略去。
    * 编译器不会将一个子类转换成一个基类对象，即丧失了多态性
    * `implemented-in-terms-of` 关系尽量使用复合实现，尽量不使用 `private` 继承
* `protected`：基类 `public`，`protected` 成员以 `protected` 权限传递给子类
* `public`：基类 `public`，`protected` 成员直接传递给子类，不发生权限变更，表示 `is-a` 关系

除开 `private` 继承方式外，派生类继承基类的**所有数据成员**和**部分函数成员**。
* 不被继承的函数成员：构造函数，析构函数，`=` 运算符重载；但对于构造函数，派生类的构造必须调用基类构造，可通过 `:` 调用

```c++
class A {
public:
    A(int i) {};
    A() {};
}

class B: A {
public:
    B(int i, double j): A(i) {};
    B(double j) {};
}
```
# using

派生类允许使用 using​ 导入基类的成员
## 继承构造
#cpp11

`using` 允许将基类的构造函数引入子类，子类会添加对应构造。

```c++
class A {
public:
    A() {}
    A(int a, double b) {}
    A(char a, float b) {}
};

class B: A {
    // 导入所有 A 的构造函数
    using A::A;
};
```

* 导入方式是隐式导入，即只有在代码中实际用到某个构造，编译时才会导入该构造
* 不会导入默认构造和复制构造
* 不影响自动生成派生类默认构造 -- 使用了 `using` 没有其他构造，也会产生默认构造
* 若派生类中有与基类接受形参相同的构造，不会生成继承构造

```run-cpp
class A {
public:
    A(int a) {
        cout << "Constructor from A" << endl;
    }
  
    A() = default;
};

class B : public A {
public:
    using A::A;
    B(int b): A() {
        cout << "Constructor from B" << endl;
    }
};

int main() {
    // Constructor from B
    B b {10};
    return 0;
}
```

* 多继承中，若导入的构造包含相同的形参列表，编译失败

```run-cpp
class A1 {
public:
    A1(int a) {}
};

class A2 {
public:
    A2(int a) {}
};

class B : public A1, public A2 {
    using A1::A1;
    using A2::A2;
};

int main() {
    // error: call of overloaded 'B(<brace-enclosed initializer list>)' is ambiguous
    // note: candidate: 'A2::A2(int)'
    // note: candidate: 'A1::A1(int)'
    B b = B{10};
    return 0;
}
```

* 基类构造不能为 private
# override
#cpp11

> [!note] 重写：override - 子类实现基类虚函数

> [!note] 重载：overload - 同一作用域内，同名但形参列表不同的函数

> [!note] 隐藏：overwrite - 子类中若存在与基类名称相同的函数，基类中的函数将被隐藏

由于 C++ 对重写的判断非常严格，经常容易将重载写成隐藏，如下面三个函数的声明是不同的

```c++
void fun(int &a) const;
void fun(int &a);
void fun(int a) const;
```

`override` 关键字用于声明该函数为重写函数。若在基类中找不到对应函数，C++ 将提示错误

```run-cpp
class A {
public:
    virtual int a() const;
    virtual int b() const; 
};

class B: A {
public:
    // Non-virtual member function marked 'override' hides virtual member function
    int a() override {};
    int b() const override {};
};
```

*`override`* *关键字只起到编译时检查作用，不加也能实现重写*

虚函数以 `virtual` 声明，表示函数在运行时动态链接而非在编译期由编译器决定。这样要经过一次查表，速度慢一点，但允许派生类实现自己的代码覆盖基类相同方法。

> [!warning] 注意有无 `const` 修饰的函数是不同函数。

```run-cpp
class A {
public:
    virtual void fun1() { cout << "A" << endl; }
    void fun2() { cout << "A" << endl; }
};

class B: public A {
public:
    virtual void fun1() override { cout << "B" << endl; }
    void fun2() { cout << "B" << endl; }
};

int main() {
    A a;
    a.fun1(); // A
    a.fun2(); // A

    B b;
    b.fun1(); // B
    b.fun2(); // B

    A *pb = &b;
    pb->fun1(); // B
    pb->fun2(); // A
    return 0;
}
```

当使用 `A*` 表示 `b` 对象时，`fun1` 由于是虚函数，会在运行时查找调用的函数，为 `B` 类重写的方法；而 `fun2` 非虚，故在编译期确定了 `A` 类的 `fun2` 函数。

子类重写基类虚函数时，可使用 `override` 关键字声明。这个关键字不是必须的，但可以验证基类是否真有该函数避免错误。

`final` 关键字修饰的虚函数表示该虚函数不允许被类的子类继续重写该函数。
# 纯虚函数

当一个虚函数没有任何实现时，使用 `=0` 占位，称该函数为纯虚函数。

```c++
class A {
public:
    virtual void a() = 0;
}
```
# 抽象类

带有纯虚函数的类，或基类中带有纯虚函数而子类没有全部实现的类称为抽象类。抽象类无法直接实例化。
# constexpr 虚函数
#cpp20

constexpr 支持修饰虚函数。在虚函数被调用时，将会使用常量代替，减少一次函数调用过程。

```c++
struct X {
    constexpr X() {}

    virtual constexpr int f() {
        return 10;
    }
};

struct Y : X {
    constexpr Y() {}

    virtual constexpr int f() {
        return 20;
    }
};

// 10
constexpr int fx = X().f();
// 20
constexpr int fy = Y().f();
```

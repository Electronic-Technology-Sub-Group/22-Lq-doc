```c++
union UnionValue {
    int a;
    double b;
}
```

C++ 基本不再使用联合体，大多数情况下 `union` 只用于与 C 的兼容，可以使用 `std::variant` 替代 `union`。
# 非受限联合类型

不再要求 union 成员必须是平凡类型。当一个联合体初始化时，编译器会依次调用所有成员的构造函数。
# launder

`std::launder()` 主要为了解决 C++ 的一个核心问题：

```c++
struct X {
    const int n;
};

union U {
    X x;
    float f;
};

int main() {
    U u = { .x = {1} };
    X *p = new (&u.x) X(2);
    // ...
    return 0;
}
```

程序中做了两件事：

1. 初始化联合体 `u` 内部值 `x` 常量值 `n=1`
2. 使用 `replace new` 在 `u.x` 地址上创建新结构体 X，常量值 `n=2`

那么，此时 `u.x.n` 是 1 还是 2？

* 从内存角度上来说，结果应该为 2，因为 `replace new` 替换了 `u.x` 的对象
* 从编译器的角度上来说，结果可能为 1，因为 `u.x.n` 是一个常量，编译器优化时可以将其使用 1 替换以提高效率
* 从标准上来说，这个行为是未定义的。在使用 `replace new` 后，不能使用原本的 `u.x`，只能使用 `p` 访问

> [!note] C++ 规定，如果新对象在已被某个对象占据的内存上进行构建，则原始对象的指针、引用及对象名都会自动转向新对象，除非对象是一个常量类型或对象中有常量数据成员或引用类型

#cpp17 `std::launder()` 方法防止编译器追踪到数据的来源以阻止编译器对数据的优化

```c++
// 可以确定这个值为 2
int n = *std::launder(&u.x.n);
```


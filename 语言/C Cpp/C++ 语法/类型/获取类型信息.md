# decltype

使用 `decltype` 关键字可在编译期获取一个表达式的类型

```cpp
int someInt;
decltype(someInt) otherInt = 10;
```

编译器不会真正计算表达式结果，只是提取类型信息，因此值不一定存在

```run-cpp
#include <vector>

std::vector<A> vec1;
std::vector<B> vec2;
// vec1 和 vec2 为空，但可正确执行
decltype(vec1[0] + vec2[0]) v;
```

上面例子 v 的类型为 `A` 与 `B` 对象相加的类型，如果存在的话（自定义运算符）。

`decltype` 和 `auto` 推断的类型可能不同，主要差异在 `const` 和 `&`

![[Pasted image 20240805100716.png]]

`decltype` 也常用于推断类型模板之间的运算结果。

```c++
template<class T1, class T2>
void add(T1 a, T2 b) {
    decltype(a + b) r = a + b;
}
```
## 推导规则

* 若被推导表达式是一个未加括号的表达式或类成员 `e`，推断结果为 `e` 的类型 `T`；若 `e` 为一组重载函数，则无法推断

`````col
````col-md
```cpp
int i = 10;
// decltype(i) 推断为 int
decltype(i) i_ret;
```
````
````col-md
![[Pasted image 20240805100809.png]]
````
`````
`````col
````col-md
```cpp
struct STRUCT {
    int x;
    double y;
} *j;
// decltype(j) 推导为 STRUCT*
decltype(j) j_ret;
// decltype(*j) 推导为 STRUCT&
decltype(*j) j__ret;
// decltype(j->y) 推导为 double
decltype(j->y) jx_ret;
```
````
````col-md
![[Pasted image 20240805100851.png]]
````
`````

* 若推导表达式为一个函数或仿函数调用，推断类型为函数返回值，函数并不会被调用

`````col
````col-md
```cpp
const int&& foo();
// decltype(foo()) 推断为 int&&
decltype(foo()) foo_result;

int fun(char);
double fun(int);
char fun(double);
// decltype(fun(3.0)) 推断为 char
decltype(fun(3.0)) fun_d_result;
```
````
````col-md
![[Pasted image 20240805103905.png]]
````
`````

* 若被推导值为类型为 T 的左值，则结果为 `T&`；若被推导值为将亡值，则结果为 `T&&`

```c++
// i=3 结果左值，decltype(i=3) 推断结果为 int&
decltype(i=3) lv_result;
// (int&&)i 结果为右值，decltype((int&&)i) 推断结果为 int&&
decltype((int&&)i) rv_result;
```
![[Pasted image 20240805103953.png]]

* 其他类型直接返回被推导值的类型（比较奇怪的是函数）

```c++
void foo();
// foo_type 类型为 void(void)
// typeid(foo_type).name() 为 FvvE
// 这个不知道有什么用
decltype(foo) foo_type;
// p_foo_type 类型为 void(*)(void)
// typeid(p_foo_type).name() 为 PFvvE
// 这个是函数指针
decltype(foo) *p_foo_type;
```

* 推断保留 const，volatile 修饰符
# typeid

`typeid` 可以查询一个类型的具体信息，返回一个 `type_info` 对象，位于 `typeinfo` 头文件中。

```run-cpp
#include<typeinfo>

int main() {
    auto a {10};

    const std::type_info &info = typeid(a + 10);
    const char *typeName = info.name(); // i
    cout << typeName << endl;

    return 0;
}
```

`type_info` 类重写了 `==` 运算符，并包含了对应类型的类型名等信息。
# sizeof

使用 `sizeof` 关键字获取一个类型、变量（可以是数组）、表达式占用内存字节数，类型为 `size_t`。

```c++
int main() {
    int i {5};

    size_t size1 = sizeof i; // 4
    size_t size2 = sizeof(int); // 4
}
```

> [!note] 结构化绑定
> 将一个或多个名称绑定到目标对象的一个或多个成员元素上

#cpp11 C++ 可以通过枚举直接打包多个元素，配合引用实现类似结构化绑定的特征：

```c++
// 创建元组
std::tuple<int, double, float> tuple = std::make_tuple(10, 2.0, 1.99f);

// 类似结构化绑定的用法
int a;
double b;
float c;
std::tie(a, b, c) = tuple;
// a=10, b=2.0, c=1.99f
printf("a=%d, b=%lf, c=%f", a, b, c);
```

#cpp17 支持结构化绑定语法，使用 `auto` 进行类型推断

```c++
// 创建元组
std::tuple<int, double, float> tuple = std::make_tuple(10, 2.0, 1.99f);
// 结构化绑定
auto [a, b, c] = tuple;
```

> [!warning] 虽然称为别名，但这里 `a`，`b`，`c` 不是引用，而是一个独立的变量（`tuple` 值的副本）

事实上，结构化绑定的实现可能是编译器产生一个变量，等于右边目标对象对应成员

如果需要获取引用的绑定，使用 `auto&`

```c++
// 创建元组
std::tuple<int, double, float> tuple = std::make_tuple(10, 2.0, 1.99f);
// 结构化绑定
auto& [a, b, c] = tuple;
```

结构化绑定数组和对象时有一定的限制。每个绑定都相当于一组变量声明，因此同一个作用域的结构化绑定中变量名不能相同。
- 数组：编译时必须知道数组的长度。若数组退化成指针则无法进行绑定。
- 对象：
    * 所有成员必须是 `public` 的
	    * #cpp20 后不再需要，可以根据当前作用域判断元素是否可被访问
    * 被绑定的变量数量必须与类非静态成员变量数量相同
    * 所有变量必须存在同一个类或基类中
    * 类和结构体中不能存在匿名联合体（`union`）
## 类元组绑定

结构化绑定类元组是以类似元组的形式进行绑定。

C++ 绑定到元组实际上并不要求目标类型是元组，而是需要满足以下几个条件（其中 `T` 为目标类型，`t` 为目标类型的一个实例，`i` 为第 i 个元素）：
* 满足 `std::tuple_size<T>::value` 是一个符合语法的表达式，其中 `value` 即左侧标识符列表中别名个数
* 满足 `std::tuple_element<i, T>::type` 是一个符合语法的表达式，其中 `type` 是第 i 个元素的类型
* 类型 `T` 必须包含以下模板函数：`get<i>()` 或 `get<i>(t)`，返回第 i 个元素的值

标准库中除了 `std::tuple`，符合以上条件的还有 `std::pair`，`std::array`

‍

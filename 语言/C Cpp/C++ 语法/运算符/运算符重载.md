在 C++ 中，一个类型的大多数运算符都可以重载，除了
* `::` 作用域解析运算符，用于访问类的静态成员
* `?:` 三元运算符
* `.` 直接成员选择运算符，用于通过对象直接访问成员（没错这也是运算符）
* `sizeof` 操作符，用于计算类占用内存字节数
* `.*` 指针解引用操作符

运算符重载通过声明以 `operator 运算符` 为名的函数重载

```c++
class A {
public:
    bool operator<(const A& other) const;
}
```

`operator` 和运算符之间可以没有空格，也可以添加空格。但若操作符是单词，如 `new` 和 `delete`，则 `operator` 之后需要空格避免歧义。

运算符支持 `const` 修饰符，当重载的运算符不修改原对象时，应当使用 `const` 修饰。

若运算符需要不止一个操作数，本身（即方法中 `this` 指针）为运算符的最左侧操作数。
* `operator()()` 运算符重载是正确的，他重载了 `()` 运算符，这类对象可像函数一样调用。`lambda` 表达式即一种这类对象
* `operator=()` 可重载赋值运算符
* `++`，`--` 重载时，前后缀通过参数列表体现：
    * `T& operator++()` --> ++a
    * `T& operaotr++(T)` --> a++
* 比较运算符只需要重载 `<` 和 `==` 运算符即可，剩下的可以通过使用标准库中 `std::rel_ops` 命名空间的相关函数直接实现。
# `[]` 多个参数
#cpp23

`[]` 允许使用 `,` 分隔的多个参数，避免 `arr[i][j][k]` 这种写法。`[]` 运算符重载时也可以传入多个参数。

> [!danger] 该特性易引发兼容性错误
> - C++20 以前，`[]` 内存在 `,` 被认为是逗号运算符
> - C++20 开始，`[]` 内的逗号触发警告，但仍被认为是逗号运算符
> - C++23 之后，`[]` 内逗号可以是多个参数

```cpp
class Matrix {
    int values[4][4];
public:
    // [] 运算符带了两个参数
    int &operator[](int row, int col) {
        return values[row % 4][col % 4];
    }
};

int main() {
    Matrix m {};
    // 使用两个参数访问矩阵元素
    m[1, 3] = 5;
    return 0;
}
```
# 静态 () 运算符
#cpp23

`operator()` 运算符可以是静态成员函数了，可用于提高效率 - 节省一次 `this` 传递。

只需要在前面加上 `static` 声明即可

```c++
template<typename T>
struct less {
    static bool operator()(const T& x, const T& y) {
        return x < y;
    }
}

less<int>{}(2, 3);
```

lambda 表达式也可以使用 -- 在 `[]()` 与 `{}` 之间添加 `static` 关键字即可。
# 按值默认比较
#cpp20 

类 `C` 的默认 `==` 运算符可以是一个参数为 `const &C` 的非静态成员函数，或两个参数都是 `const &C` 或 `C` 的友元函数（原本只能是 `const &C`）

```c++

struct C {
    // 没问题
    bool operator==(const C &o) const = default;
    friend bool operator==(C c1, C c2) = default;
    friend bool operator==(const C &c1, const C &c2) = default;

    // error: defaulted member 'bool C::operator==(C) const' must have parameter type 'const C&'
    bool operator==(C o) const = default;
    // error: defaulted 'bool operator==(C, const C&)' must have parameters of either type 'const C&' or 'C', not both
    friend bool operator==(C c1, const C &c2) = default;
};
```

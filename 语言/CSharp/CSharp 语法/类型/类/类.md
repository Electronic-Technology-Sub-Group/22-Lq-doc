类使用 `class` 声明，通过引用传递。

```csharp
class ClassName {
    ...
}
```

类中可以包含各种[[属性]]和[[函数]]，静态成员属于类. 实例成员属于对象。

# 构造函数

实例化对象时自动调用的特殊函数，与类同名，无返回值。没有提供任何构造时，编译器自动生成一个无参构造。

- 静态构造：在引用该类时有且仅有一次调用，类似 Java `static` 块。
   
```csharp
class MyClass {
    // 隐式调用，不能有任何参数，无视任何修饰符
    static MyClass() { ... }
}
```

- 在一个构造中调用其他构造：使用 `this()`；调用基类构造，使用 `base()`
   
```csharp
class MyClass: MyClassParent {
    MyClass(int p1, int p2, int p3): base() { ... }
    MyClass(int p1, int p2): this(p1, p2, 3) { ... }
    MyClass(int p1): this(p1, 2, 3) { ... }
    MyClass(): this(1, 2, 3) { ... }
}
```

# 析构函数

CLR 检测到不再需要某个对象时调用，不能预测何时析构

```csharp
class MyClass {
    NyClass() { ... }     // 构造函数
    ~MyClass() { ... }    // 析构函数
}
```

析构函数在 .Net 中统称终结器，在 IL 中映射为 `Finalize()` 方法。

> [!attention] 实现终结器对性能会有显著影响。

# 匿名类

由编译器生成的类，直接继承 Object，无名称，直接使用 `new { ... }` 创建 
- 所有属性相同时, 两个匿名类生成的对象类型相同
- 匿名类不能进行任何反射

```csharp
var objectName = new {
    Field1 = Value1,
    Field2 = Value2,
    Field3 = Value3,
    ...
};
```

# 部分类

可以将类成员等放在多个文件中，每个文件仅包含其一部分内容，使用 `partial` 修饰

- 部分类会自动合并属性，XML注释，接口，泛型类型的参数属性，成员等部分
- 所有部分必须拥有相同的修饰符
- 部分方法：方法的声明和实现不在一起，但其返回值必须是 `void` 的

`````col
````col-md
flexGrow=1
===
```csharp
// in SampleClass1.cs
partial class SampleClass {
    public void Method1() {
        APartialMethod();
    }

    public partial void APartialMethod();
}
```
````
````col-md
flexGrow=1
===
```csharp
// in SampleClass2.cs
partial class SampleClass: IOtherSampleClass {
    public void APartialMethod() {
        // implementation
    }
}
```
````
`````

# 继承

继承语法类似 C++，使用 `:` 继承
- 类必须在接口之前，且不支持多继承
- 结构体只能实现接口，不能继承其他类型
- 访问基类成员使用 `base`

```csharp
class MyClass : MyBaseClass, IMyInterface1, IMyInterface2 {
    ...
}
```

基类方法或属性使用 `virtual` 声明可被重写（虚方法），子类中使用 `override` 修饰重写方法

```csharp
class MyBaseClass {
    public virtual void MyMethod() {
        Console.WriteLine("Method in MyBaseClass");
    }
}

class MyClass: MyBaseClass {
    public override void MyMethod() {
        base.MyMothod()    // 调用父类的方法
        Console.WriteLine("Method in MyClass");
    }
}
```

基类没有用 `virtual` 声明时，子类可用 `new` 声明隐藏基类方法

> [!warning] 隐藏方法多用于解决继承于其他第三方类的子类的版本冲突，不应故意用于隐藏基类成员

```csharp
class MyBaseClass {
    public void MyMethod() {
        Console.WriteLine("Method in MyBaseClass");
    }
}

class MyClass: MyBaseClass {
    new public void MyMethod() {
        base.MyMothod()    // 调用父类的方法
        Console.WriteLine("Method in MyClass");
    }
}
```

# 抽象类

`abstract` 声明抽象类和抽象方法，抽象类不能被实例化。含有抽象方法的类必须为抽象类。

```csharp
abstract class MyBaseClass {
    public abstract void MyMethod1();
    public abstract void MyMethod2();
}

abstract class MyClass: MyBaseClass {
    public override void MyMethod1() {
        Console.WriteLine("Method in MyClass");
    }

    public override void MyMethod2() {
        // 可抛出该异常，作为临时实现
        throw new NotImplementedException();
    }
}
```

# 修饰符

> [!attention] 内部类型可访问外部类型的所有成员，包括 `private` 成员

|     修饰符     |        应用         |            说明             |
| :---------: | :---------------: | :-----------------------: |
|  `public`   |      所有类型及成员      |     逻辑访问修饰符，任何代码均可访问      |
| `protected` |   类型和内嵌类型的所有成员    |      逻辑访问修饰符，仅派生类可访问      |
| `internal`  |      所有类型及成员      |     物理访问修饰符，所在程序集内可访问     |
|  `private`  |   类型和内嵌类型的所有成员    |    逻辑访问修饰符，仅限所属类型内部可访问    |
|    `new`    |       函数成员        |          隐藏基类成员           |
|  `static`   |      所有类型成员       | 作为类成员而非对象成员；修饰类时表示该类无法实例化 |
|  `virtual`  |       函数成员        |          可由派生类重写          |
| `abstract`  |       类或成员        |         抽象类或抽象成员          |
| `override`  |       函数成员        |       重写继承的抽象类或虚拟类        |
|  `sealed `  |     子类或重写的成员      |      不能派生子类或继续被子类重写       |
|  `extern`   | 静态`[DLLImport]`方法 |       外部用另一种语言实现的成员       |
|  `unsafe`   |       任何成员        |       运行非安全代码，使用指针        |
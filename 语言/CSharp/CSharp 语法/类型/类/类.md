
`````col
````col-md
flexGrow=2
===
类属于引用类型，存于托管推中，通过引用传递。

类使用 `class` 声明，包含各种[[属性]]和[[函数]]成员。
````
````col-md
flexGrow=1
===

| C# 类型  | .Net 类型       |
|:------:|:-------------:|
| object | System.Object |
| string | System.String |

````
`````

```csharp
class ClassName {
    ...
}
```

静态成员属于类. 实例成员属于对象。

# object

`Object` 为所有类的基类，定义了一组方法
- `ToString`：获取对象字符串
- `GetHashCode`：若要将该类作为字典的一个键，则需要重写该方法
- `Equals`：按值比对对象，不能抛异常。接收两个参数，可处理 `null`
- `ReferenceEquals`：比较两个对象是否引用同一实例
- `GetType`：返回 `System.Type` 对象，类似 Java 的 `class`
- `MemberwiseClone`：浅表复制

# 静态构造

在第一次引用类时调用，类似 Java `static` 块。
   
```csharp
class MyClass {
    // 隐式调用，不能有任何参数，无视任何修饰符
    static MyClass() { ... }
}
```

# 构造函数

声明同 Java，调用基类/其他构造同 C++：

> 使用 `this()` 在一个构造中调用其他构造；使用 `base()` 调用基类构造

```csharp
class MyClass: MyClassParent {
    MyClass(int p1, int p2, int p3): base() { ... }
    MyClass(int p1, int p2): this(p1, p2, 3) { ... }
    MyClass(int p1): this(p1, 2, 3) { ... }
    MyClass(): this(1, 2, 3) { ... }
}
```

# 析构函数

CLR 检测到不再需要某个对象时调用，不能预测何时析构

```csharp
class MyClass {
    NyClass() { ... }     // 构造函数
    ~MyClass() { ... }    // 析构函数
}
```

析构函数在 .Net 中统称**终结器**，在 IL 中映射为 `Finalize()` 方法。

> [!attention] 实现终结器对性能会有显著影响。

# 匿名类

由编译器生成的类，直接继承 Object，无名称，直接使用 `new { ... }` 创建 
- 所有属性相同时, 两个匿名类生成的对象类型相同
- 匿名类不能进行反射

```csharp
var objectName = new {
    Field1 = Value1,
    Field2 = Value2,
    Field3 = Value3,
    ...
};
```

# 部分类

使用 `partial` 修饰，拆分类到多个文件中
- 所有部分必须拥有相同的修饰符
- 部分方法：返回值是 `void` 的方法，声明和实现不在同一个文件

`````col
````col-md
flexGrow=1
===
```csharp
// in SampleClass1.cs
partial class SampleClass {
    public void Method1() {
        APartialMethod();
    }

    public partial void APartialMethod();
}
```
````
````col-md
flexGrow=1
===
```csharp
// in SampleClass2.cs
partial class SampleClass: IOtherSampleClass {
    public void APartialMethod() {
        // implementation
    }
}
```
````
`````

# 继承

继承语法类似 C++，使用 `:` 继承
- 类必须在接口之前，且不支持多继承
- 结构体只能实现接口，不能继承其他类型
- 访问基类成员使用 `base`

```csharp
class MyClass : MyBaseClass, IMyInterface1, IMyInterface2 {
    ...
}
```

`virtual` 声明的方法或属性可被重写，子类中使用 `override` 修饰重写方法

`````col
````col-md
flexGrow=1
===
```csharp
class MyBaseClass {
    public virtual void MyMethod() {
        Console.WriteLine("Method in MyBaseClass");
    }
}
```
````
````col-md
flexGrow=1
===
```csharp
class MyClass: MyBaseClass {
    public override void MyMethod() {
        base.MyMothod()    // 调用父类的方法
        Console.WriteLine("Method in MyClass");
    }
}
```
````
`````

基类没有用 `virtual` 声明时，子类可用 `new` 声明隐藏基类方法

> [!warning] 隐藏方法多用于解决继承于其他第三方类的子类的版本冲突，不应故意用于隐藏基类成员

`````col
````col-md
flexGrow=1
===
```csharp
class MyBaseClass {
    public void MyMethod() {
        Console.WriteLine("Method in MyBaseClass");
    }
}
```
````
````col-md
flexGrow=1
===
```csharp
class MyClass: MyBaseClass {
    new public void MyMethod() {
        base.MyMothod()    // 调用父类的方法
        Console.WriteLine("Method in MyClass");
    }
}
```
````
`````

# 抽象类

`abstract` 声明抽象类和抽象方法，抽象类不能被实例化。含有抽象方法的类必须为抽象类。

```csharp
abstract class MyBaseClass {
    public abstract void MyMethod1();
    public abstract void MyMethod2();
}

abstract class MyClass: MyBaseClass {
    public override void MyMethod1() {
        Console.WriteLine("Method in MyClass");
    }

    public override void MyMethod2() {
        // 可抛出该异常，作为临时实现
        throw new NotImplementedException();
    }
}
```

# 密封类

使用 `sealed` 修饰类或方法，不允许派生出子类或重写此方法
- 防止子类造成功能的不稳定性
- 缩短或消除用于虚拟方法的虚拟表，以提高性能

```csharp
public sealed class MySealedClass { ... }
public class MyClass1: MyClass { ... }                // 编译器报错，无法继承于密封类

public class MyBaseClass {
    public sealed void MySealedMethod() { ... }
}
public class MyClass2: MyBaseClass {
    public override void MySealedMethod() { ... }    // 编译器报错，无法重写密封方法或属性
}
```

# 修饰符

> [!attention] 内部类型可访问外部类型的所有成员，包括 `private` 成员

|     修饰符     |        应用         |            说明             |
| :---------: | :---------------: | :-----------------------: |
|  `public`   |      所有类型及成员      |     逻辑访问修饰符，任何代码均可访问      |
| `protected` |   类型和内嵌类型的所有成员    |      逻辑访问修饰符，仅派生类可访问      |
| `internal`  |      所有类型及成员      |     物理访问修饰符，所在程序集内可访问     |
|  `private`  |   类型和内嵌类型的所有成员    |    逻辑访问修饰符，仅限所属类型内部可访问    |
|    `new`    |       函数成员        |          隐藏基类成员           |
|  `static`   |      所有类型成员       | 作为类成员而非对象成员；修饰类时表示该类无法实例化 |
|  `virtual`  |       函数成员        |          可由派生类重写          |
| `abstract`  |       类或成员        |         抽象类或抽象成员          |
| `override`  |       函数成员        |       重写继承的抽象类或虚拟类        |
|  `sealed `  |     子类或重写的成员      |      不能派生子类或继续被子类重写       |
|  `extern`   | 静态`[DLLImport]`方法 |       外部用另一种语言实现的成员       |
|  `unsafe`   |       任何成员        |       运行非安全代码，使用指针        |
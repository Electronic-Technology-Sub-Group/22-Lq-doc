---
è¯­è¨€: Rust
è¯­æ³•ç±»å‹: åŸºç¡€è¯­æ³•
---
# æ•´å‹

æ•´å‹å­—é¢å€¼å¯ä»¥ç”±å‰ç¼€ï¼Œå€¼ï¼Œåç¼€ä¸‰éƒ¨åˆ†ç»„æˆï¼Œå‰åç¼€åˆ†åˆ«è¡¨ç¤ºè¿›åˆ¶å’Œå€¼ç±»å‹

`````col
````col-md
flexGrow=1
===
|       é•¿åº¦       |  æœ‰ç¬¦å·  |  æ— ç¬¦å·  |
| :------------: | :---: | :---: |
|     8 bit      |  i8   |  u8   |
|     16 bit     |  i16  |  u16  |
|     32 bit     |  i32  |  u32  |
|     64 bit     |  i64  |  u64  |
|    128 bit     | i128  | u128  |
| å¹³å°ç›¸å…³(32 or 64) | isize | usize |
````
````col-md
flexGrow=1
===
```rust
let x = 1; // i32 ç±»å‹ åè¿›åˆ¶ 1
let y = 0xffi64; // i64 ç±»å‹ åå…­è¿›åˆ¶ FF
let z = 0o77usize; // usize ç±»å‹ å…«è¿›åˆ¶ 77
let w = b'A'; // u8 ç±»å‹ 'A' (åè¿›åˆ¶ 65)
```
````
`````

> [!note] ä¸ºæé«˜å¯è¯»æ€§ï¼Œå…è®¸ä½¿ç”¨ `_` åˆ†å‰²æ•°å­—ï¼Œå¦‚ `1_000`  ç­‰æ•ˆäº `1000` ï¼Œ`0.000_001`  ç­‰æ•ˆäº `0.000001` 

åè¿›åˆ¶ä¸éœ€è¦å‰ç¼€ï¼Œå…«è¿›åˆ¶ä¸º `0o`ï¼Œåå…­è¿›åˆ¶ä¸º `0x`ï¼ŒäºŒè¿›åˆ¶ä¸º `0b`ï¼Œ char ç±»å‹è½¬åŒ–ä½¿ç”¨ `b`ã€‚

åç¼€ä¸»è¦ç”¨äºæŒ‡å®šæ•´å‹ç±»å‹ï¼Œé»˜è®¤ä¸º `i32`ï¼›`b` å‰ç¼€ç”¨äºè½¬åŒ–å­—ç¬¦çš„ç±»å‹åªèƒ½æ˜¯ u8ã€‚å­—é¢é‡çš„ç±»å‹ä¸å˜é‡ç±»å‹å¯ä»¥ä¸åŒï¼Œå…è®¸å®‰å…¨è½¬åŒ–ã€‚

## æ•´å‹æº¢å‡º

> [!error] æ•´å‹æº¢å‡ºï¼šè¿ç®—ç»“æœè¶…è¿‡æ•´å‹æœ€å¤§å€¼

Debug æ¨¡å¼ä¸‹ Rust ä½¿ç¨‹åº `panic!` ï¼Œrelease æ¨¡å¼ä¸‹ä½¿ç”¨äºŒè¿›åˆ¶è¡¥ç å¾ªç¯æº¢å‡ºå¤„ç†ã€‚

```rust
fn main() {
    println!("Integer overflow: 254+1={}", 254u8+1u8);
}
```

æ•´å‹æº¢å‡ºä¸€èˆ¬è¢«è®¤ä¸ºæ˜¯ä¸€ç§<font color="#c0504d">é”™è¯¯</font>ï¼Œä¹Ÿå¯ä½¿ç”¨ `Wrapping` åŠŸèƒ½æ‰‹åŠ¨å¤„ç†ã€‚

-  `wrapping_*` ï¼šé»˜è®¤ï¼Œå°†æº¢å‡ºå€¼ä»¥äºŒè¿›åˆ¶è¡¥ç åŒ…è£…ï¼Œåœ¨ debug æ¨¡å¼ä¸‹ä»èƒ½è¿è¡Œ

```rust
fn main() {
    println!("Integer overflow: 254+2={}", 254u8+2u8);
    println!("Wrapping add: 254+1={}", 254u8.wrapping_add(1u8));
    println!("Wrapping add: 254+2={}", 254u8.wrapping_add(2u8));
}
```

- `checked_*`ï¼šè¿”å› `Option` å¯¹è±¡ï¼Œæº¢å‡ºæ—¶è¿”å› `None` 

```rust
fn main() {
    println!("Check: 254+1={}", 254u8.checked_add(1u8).get_or_insert(0u8));
    println!("Check: 254+2={}", 254u8.checked_add(2u8).get_or_insert(0u8));
}
```

-  `overflowing_*`ï¼šè¿”å› `(self, bool)`  ç±»å‹å…ƒç»„ï¼Œå‰è€…ä»¥è¡¥ç åŒ…è£…ï¼Œåè€…ä¸ºæ˜¯å¦æº¢å‡º

```rust
fn main() {
    let oa = 254u8.overflowing_add(1u8);
    println!("Overflowing: 254+1=({}, {})", oa.0, oa.1);
    
    let oa = 254u8.overflowing_add(2u8);
    println!("Overflowing: 254+1=({}, {})", oa.0, oa.1);
}
```

-  `saturating_*`ï¼šé¥±å’Œå¤„ç†ï¼Œä¿ç•™æº¢å‡ºå‰çš„æœ‰æ•ˆå€¼

```rust
fn main() {
    println!("Saturating: 254+1={}", 254u8.saturating_add(1u8));
    println!("Saturating: 254+2={}", 254u8.saturating_add(2u8));
}
```

# æµ®ç‚¹

ä½¿ç”¨  `f32`  å’Œ `f64`  åˆ†åˆ«è¡¨ç¤º IEEE-754 æ ‡å‡†å•ç²¾åº¦/åŒç²¾åº¦æµ®ç‚¹æ•°ï¼Œé»˜è®¤ä¸º `f64`

> [!success] ç°ä»£ CPU ä¸­ 64 ä½æµ®ç‚¹æ•°çš„é€Ÿåº¦ä¸ 32 ä½å‡ ä¹ç›¸åŒä¸”ç²¾åº¦æ›´é«˜ã€‚

```rust
let x = 1.0; // f64
let y: f32 = 2.2; // f32
```

æµ®ç‚¹ç±»å‹åªå®ç°äº† `PartialEq`ï¼Œæ²¡æœ‰å®ç° `Eq`

# NaN

Not A Numberï¼Œä»£è¡¨ä¸€ä¸ªæ•°å­¦ä¸Šæœªå®šä¹‰çš„ç»“æœã€‚ä»»ä½• NaN å‚ä¸çš„æ“ä½œç»“æœä¸º NaNï¼Œä¸”æ— æ³•ç”¨äºä¸å…¶ä»–æ•°å­—æ¯”è¾ƒ

å¯ä»¥ä½¿ç”¨ `is_nan()` æ–¹æ³•åˆ¤æ–­æ˜¯å¦ä¸º NaN

```rust
fn main() {
    let x = (-42.0_f32).sqrt();
    println!("{}", x.is_nan());
}
```

# å¤æ•°

Rust æ ‡å‡†åº“ä¸å­˜åœ¨å¤æ•°ã€‚å¯ä½¿ç”¨ `num` åº“ï¼š

```rust
use num::complex::Complex;

 fn main() {
   let a = Complex { re: 2.1, im: -1.2 };
   let b = Complex::new(11.1, 22.2);
   let result = a + b;

   println!("{} + {}i", result.re, result.im)
 }
```
# å­—ç¬¦

Rust å­—ç¬¦ç±»å‹ char å­—é¢é‡ä»¥ '' å¼•ç”¨ï¼Œä»£è¡¨ä¸€ä¸ª 4 å­—èŠ‚ Unicode æ ‡é‡å€¼

```rust
let c = 'z';
let z = 'â„¤';
let heart_eyed_cat = 'ğŸ˜»';
```
# å¸ƒå°”

å¸ƒå°”å€¼ bool å¤šç”¨äºæ§åˆ¶è¯­å¥ï¼ŒåŒ…å« `true`  å’Œ `false`  ä¸¤ä¸ªå€¼ï¼Œå  1 å­—èŠ‚
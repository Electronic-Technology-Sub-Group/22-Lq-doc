函数使用 `fn` ​ 关键字声明，由函数名，参数列表和可选的返回值组成。函数名推荐以 `snake_case` 形式。

`````col
````col-md
flexGrow=1
===
```rust
fn 函数名(形参列表) -> 返回值 {
    函数体
}
```
````
````col-md
flexGrow=1
===
```rust
fn add(a: i32, b: i32) {
    a + b
}
```
````
`````

​ `main` ​ 函数为整个 Rust 代码的入口函数，该函数无参，返回值类型为 `()` ​ 或 `Result<(), E>​`
- ​`()​` 类型即没有指定返回值类型的函数的返回值类型。
- ​`Result<(), E>​` 类型说明 `main`​ 函数可能会有错误。

```rust
fn main() {
    // do something
}
```

使用 `->`​ 指定返回值类型，在函数体中使用 `return`​ 提前返回值，或使用函数最后一条表达式（不带有 `;​`）作为返回值。

```rust
// 返回 i32 类型 5，这里 5 没有分号，是一个表达式
fn five() -> i32 { 5 }

fn add(a: i32, b: i32) -> i32 { a+b }
```
# 发散函数

没有任何返回值的函数称为<font color="#9bbb59">发散函数</font>。此时要求指定函数返回值类型为 `!​`

> [!danger]
> 由于 Rust 要求每个表达式都有返回值，发散函数往往表示程序会因此崩溃

`````col
````col-md
flexGrow=1
===
```rust
fn dead_end() -> ! {
    panic!("An Error!")
}
```
使用 `panic!`​ 宏触发错误
````
````col-md
flexGrow=1
===
```rust
fn forever() -> ! {
    loop {}
}
```
死循环永远不会跳出
````
`````
# 函数指针

函数名可以直接作为函数指针。函数指针类型为 `fn(...)->...​`

```rust
fn add_one(x: i32) -> i32 { x + 1 }

fn do_twice(f: fn(i32) -> i32, arg: i32) -> i32 {
    f(arg) + f(arg)
}

fn main() {
    let ans = do_twice(add_one, 5);
    // Answer is 12
    println!("Answer is {}", ans);
}
```

​ `fn` ​ 类型实现了 `Fn` ​, `FnMut` ​, `FnOnce` ​, 因此可以直接作为参数传入接受闭包的函数或者成为其返回值。
# 闭包

<font color="#9bbb59">闭包</font>，或称为 <font color="#9bbb59">lambda​ 表达式</font>，是可以以变量或参数形式存在的匿名函数。

闭包使用 `||`​ 声明参数，`->`​ 声明返回值，`{}`​ 声明函数体。以下是写法及几种简写

```rust
fn add_one(x: u32) -> u32 { x+1 }

fn main() {
    let add_one_v1 = |x: u32| -> u32 { x+1 };
    // 参数和返回值类型可省略，编译器根据调用时的参数自动推断
    let add_one_v2 = |x| { x + 1 };
    // 闭包只有一行，大括号也可以省略了
    let add_one_v3 = |x| x+1;
}
```

> [!warning]
> 闭包推断不是泛型，当编译器推导出一种类型后，它就会一直使用该类型

根据捕获外部环境值的方法，闭包实现了 `Fn`​, `FnMut`​ 或 `FnOnce`​ 中的一个 trait​，完整类型可能是 `Fn(i32)​, Fn(i32) -> i32`​ 等形式
- ​`FnOnce`​: 闭包从周围作用域捕获变量并获取其所有权，且只能执行一次
- ​`FnMut`​: 闭包从周围作用域获取可变引用
- ​`Fn`​: 闭包从周围作用域获取不可变引用

```rust
struct Cached<T> where T: Fn(u32) -> u32 {
    calculation: T,
    value: Option<u32>
}

impl<T> Cached<T> where T: Fn(u32) -> u32 {

    fn new (calculation: T) -> Cached<T> {
        Cached {
            calculation,
            value: None
        }
    }

    fn value(&mut self, arg: u32) -> u32 {
        match self.value {
            Some(v) => v,
            None => {
                let v = (self.calculation)(arg);
                self.value = Some(v);
                v
            }
        }
    }
}
```

```rust
fn main() {
    let f = |x| {
        println!("Called with {}", x);
        x+1
    };
    let mut cached = Cached::new(f);
    // Called with 5
    // 6
    println!("{}", cached.value(5));
    // 6
    println!("{}", cached.value(5));
    // 6
    println!("{}", cached.value(5));
    // 6
    println!("{}", cached.value(5));
    // 6
    println!("{}", cached.value(5));
}
```

​`Fn`​​、`FnMut`​​ 可以使用 `move`​​ 强制要求转移捕获参数的所有权

```rust
let s = String::new();
let update_string = move || println!("{}", s);
update_string();
```
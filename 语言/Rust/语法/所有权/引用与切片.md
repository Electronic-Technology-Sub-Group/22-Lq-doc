# 引用

Rust 支持直接传递变量的引用，使用 `&` ​ 标记，允许使用值但不获取其所有权。创建引用的过程叫做借用。

引用的存在遵循以下规则：

- 任意给定时间（作用域内），无法同时存在超过一个可变引用，也无法在不可变引用存在的情况下存在可变引用
- 引用必须总是有效

引用通过 `*ref`​ 解引用，可用于获取被引用的值。

```rust
fn main() {
    let s1 = String::from("hello");
    // 传递的是一个 &String 类型，即对 String 的引用，可访问到 s1 但不拥有它
    let len = calculate_length(&s1);
    // hello.len=5
    println!("{}.len={}", s1, len);
}
```

```rust
fn calculate_length(s: &String) -> usize {
    s.len()
}
```

引用的值无法被修改。若想要修改引用值，首先要将变量转化为可变变量，然后使用 `&mut`​ 作为变量类型。

```rust
fn main() {
    let mut s1 = String::from("hello");
    change(&mut s1);
    // hello, world
    println!("{}", s1);
}

fn change(s: &mut String) {
    s.push_str(", world");
}
```

> [!warning]
> 同一时刻，只能有一个对某变量的可变引用

```rust
let mut s1 = String::from("hello");

let r1 = &mut s1;
// let r1 = &mut s1;
//          ------- first mutable borrow occurs here
// let r2 = &mut s1;
//          ^^^^^^^ second mutable borrow occurs here
// 
// println!("{}, {}", r1, r2);
//                    -- first borrow later used here
let r2 = &mut s1;

println!("{}, {}", r1, r2);
```

> [!warning]
> 不能在持有不可变引用的同时持有可变引用

```rust
fn main() {
    let mut s1 = String::from("hello");

    let r1 = &s1;
    let r2 = &s1;
    // let r1 = &s1;
    //          --- immutable borrow occurs here
    // let r2 = &s1;
    // let r3 = &mut s1;
    //          ^^^^^^^ mutable borrow occurs here
    // 
    // println!("{}, {}. {}", r1, r2, r3);
    //                        -- immutable borrow later used here
    let r3 = &mut s1;

    println!("{}, {}. {}", r1, r2, r3);
}
```

> [!info]
> 一个引用的作用域是从声明开始，到最后一次使用为止。因此以在不同作用域中使用，也可以在使用后声明，这不是同时拥有

```rust
fn main() {
    let mut s1 = String::from("hello");

    {
        let r1 = &mut s1;
    }

    let r2 = &s1;
    let r3 = &s1;
    println!("{} and {}", r2, r3);
    // r1 已脱离作用域，r2 r3 已被使用都失效了，因此此时声明不再是同时拥有
    let r4 = &mut s1;
    println!("{}", r4);
}
```

 Rust 不允许在作用域外存在对应指针，避免产生悬垂指针。

> [!note] 悬垂指针
> 使用指针时，指向的内存已被分配给其他持有者。如 C 中，`free` 了一个指针，但后面又访问了这个指针

```rust
fn main() {
    let reference_to_nothing = dangle();
}
// fn dangle() -> &String {
//                ^ expected named lifetime parameter
// help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
// help: consider using the `'static` lifetime
// fn dangle() -> &'static String {
//                ~~~~~~~~
fn dangle() -> &String {
    let s = String::from("hello");
    &s
}
```

解决方法为直接返回 String 本身，转移所有权
## 再借用

对一个引用解引用后重新借用，这个过程称为<font color="#9bbb59">再借用</font>（reborrow）。

```rust
fn main() {
    let mut p = Point { x: 0, y: 0 };
    let r = &mut p;
    let rr: &Point = &*r;

    // 再借用 rr 最后一次使用发生在这里
    // 在它的生命周期中，我们并没有使用原来的借用 r，因此不会报错
    println!("{:?}", rr);

    // 再借用结束后，才去使用原来的借用`r`
    r.move_to(10, 10);
    println!("{:?}", r);
}
```

再借用 `rr​` 生效时，原本的 `r` ​ 暂时失效，当 `rr` ​ 失效后 `r​` 重新可用。
# 切片

​切片 `slice` ​ 是除了引用外另一个没有所有权的数据类型，表示对数组或集合中一段连续元素或序列的引用。

```run-rust
fn main() {
    let s = String::from("Hello world!");
    let word = first_word(&s);
    // First word is Hello
    println!("First word is {}", word)
}

fn first_word(str: &String) -> &str {
    let bytes = str.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &str[..i];
        }
    }

    &str[..]
}
```

​String​ 的 slice​ 类型为 &str​, 这也是直接使用字面量字符串赋值的类型；其他类型使用 `&[type]​`, 如 `&[i32]​`。

slice 使用一个 Range​ 表示范围，若从 0 开始则可省略起点，到最后一个元素为止则可省略结束

```run-rust
fn main() {
    let a = [1, 2, 3, 4, 5];
    // sa1: 2, 3
    let sa1 = &a[1..3];
    println!("sa1: {}, {}", sa1[0], sa1[1]);
    // sa2: 1, 2, 3
    let sa2 = &a[..3];
    println!("sa2: {}, {}, {}", sa2[0], sa2[1], sa2[2]);
    // sa3: 4, 5
    let sa3 = &a[3..];
    println!("sa3: {}, {}", sa3[0], sa3[1]);
    // sa4: 1, 2, 3, 4, 5
    let sa4 = &a[..];
    println!("sa4: {}, {}, {}, {}, {}", sa4[0], sa4[1], sa4[2], sa4[3], sa4[4]);
}
```

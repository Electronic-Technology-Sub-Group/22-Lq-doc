# æ•´å‹

æ•´å‹å­—é¢å€¼å¯ä»¥æœ‰ä¸‰éƒ¨åˆ†ç»„æˆ - å‰ç¼€è¡¨ç¤ºè¿›åˆ¶ï¼Œä¸­é—´ä¸ºå€¼ï¼Œåç¼€è¡¨ç¤ºç±»å‹

`````col
````col-md
flexGrow=1
===
|       é•¿åº¦       |  æœ‰ç¬¦å·  |  æ— ç¬¦å·  |
| :------------: | :---: | :---: |
|     8 bit      |  i8   |  u8   |
|     16 bit     |  i16  |  u16  |
|     32 bit     |  i32  |  u32  |
|     64 bit     |  i64  |  u64  |
|    128 bit     | i128  | u128  |
| å¹³å°ç›¸å…³(32 or 64) | isize | usize |
````
````col-md
flexGrow=1
===
```rust
let x = 1; // i32 ç±»å‹ åè¿›åˆ¶ 1
let y = 0xffi64; // i64 ç±»å‹ åå…­è¿›åˆ¶ FF
let z = 0o77usize; // usize ç±»å‹ å…«è¿›åˆ¶ 77
let w = b'A'; // u8 ç±»å‹ 'A' (åè¿›åˆ¶ 65)
```
````
`````

> [!note]
> ä¸ºæé«˜å¯è¯»æ€§ï¼Œå…è®¸åœ¨æ•°å­—å­—é¢é‡ä¹‹é—´æ’å…¥ `_â€‹â€‹` ç”¨äºåˆ†å‰²æ•°å­—ï¼š1_000â€‹â€‹ ç­‰æ•ˆäº 1000â€‹â€‹ï¼Œ0.000_001â€‹â€‹ ç­‰æ•ˆäº 0.000001â€‹â€‹

åè¿›åˆ¶ä¸éœ€è¦å‰ç¼€ï¼Œå…«è¿›åˆ¶ä¸º `0o`â€‹ï¼Œåå…­è¿›åˆ¶ä¸º `0xâ€‹`ï¼ŒäºŒè¿›åˆ¶ä¸º `0bâ€‹`ï¼Œ char ç±»å‹è½¬åŒ–ä½¿ç”¨ `bâ€‹`ã€‚

åç¼€ä¸»è¦ç”¨äºæŒ‡å®šæ•´å‹ç±»å‹ï¼Œé»˜è®¤ä¸º `i32`â€‹ï¼›`bâ€‹` å‰ç¼€ç”¨äºè½¬åŒ–å­—ç¬¦çš„ç±»å‹åªèƒ½æ˜¯ u8â€‹ã€‚å­—é¢é‡çš„ç±»å‹ä¸å˜é‡ç±»å‹å¯ä»¥ä¸åŒï¼Œå…è®¸å®‰å…¨è½¬åŒ–ã€‚

æ•´å‹è¿ç®—æ—¶æ³¨æ„æ•´å‹æº¢å‡ºã€‚
## æ•´å‹æº¢å‡º

> [!note] æ•´å‹æº¢å‡º
> å½“è¿ç®—ç»“æœè¶…è¿‡æ•´å‹æœ€å¤§å€¼çš„æƒ…å†µè¢«ç§°ä¸ºæ•´å‹æº¢å‡ºã€‚Debug æ¨¡å¼ä¸‹ Rust ä½¿ç¨‹åº `panic!` â€‹â€‹ï¼Œrelease æ¨¡å¼ä¸‹ä½¿ç”¨äºŒè¿›åˆ¶è¡¥ç å¾ªç¯æº¢å‡ºå¤„ç†ã€‚

```rust
fn main() {
    println!("Integer overflow: 254+1={}", 254u8+1u8);
}
```

æ•´å‹æº¢å‡ºä¸€èˆ¬è¢«è®¤ä¸ºæ˜¯ä¸€ç§<font color="#c0504d">é”™è¯¯</font>ï¼Œä½†è‹¥ä¾èµ–äºæ•´å‹æº¢å‡ºï¼Œå¯ä½¿ç”¨ `Wrapping`â€‹â€‹ åŠŸèƒ½ã€‚

`wrapping_*` â€‹ æ–¹æ³•æ€»æ˜¯å°†æº¢å‡ºå€¼ä»¥äºŒè¿›åˆ¶è¡¥ç åŒ…è£…ï¼Œåœ¨ debugâ€‹ æ¨¡å¼ä¸‹ä»èƒ½è¿è¡Œã€‚é»˜è®¤æ“ä½œã€‚

```rust
fn main() {
    println!("Integer overflow: 254+2={}", 254u8+2u8);
    println!("Wrapping add: 254+1={}", 254u8.wrapping_add(1u8));
    println!("Wrapping add: 254+2={}", 254u8.wrapping_add(2u8));
}
```

â€‹ `checked_*â€‹` æ–¹æ³•è¿”å›ä¸€ä¸ª Optionâ€‹ å¯¹è±¡ï¼Œå½“æº¢å‡ºæ—¶è¿”å› `None`â€‹

```rust
fn main() {
    println!("Check: 254+1={}", 254u8.checked_add(1u8).get_or_insert(0u8));
    println!("Check: 254+2={}", 254u8.checked_add(2u8).get_or_insert(0u8));
}
```

`overflowing_*` â€‹ æ–¹æ³•è¿”å›ä¸€ä¸ª `(self, bool)` â€‹ ç±»å‹å…ƒç»„ï¼Œå‰è€…ä»¥è¡¥ç åŒ…è£…ï¼Œåè€…ä¸ºæ˜¯å¦æº¢å‡º

```rust
fn main() {
    let oa = 254u8.overflowing_add(1u8);
    println!("Overflowing: 254+1=({}, {})", oa.0, oa.1);
    
    let oa = 254u8.overflowing_add(2u8);
    println!("Overflowing: 254+1=({}, {})", oa.0, oa.1);
}
```

`saturating_*â€‹` æ–¹æ³•å¯¹å€¼çš„æœ€å¤§å€¼æˆ–æœ€å°å€¼è¿›è¡Œé¥±å’Œå¤„ç†

```rust
fn main() {
    println!("Saturating: 254+1={}", 254u8.saturating_add(1u8));
    println!("Saturating: 254+2={}", 254u8.saturating_add(2u8));
}
```

# æµ®ç‚¹

Rust æµ®ç‚¹åˆ†ä¸º `f32` â€‹ å’Œ `f64` â€‹ ä¸¤ç§ï¼Œä»£è¡¨ IEEE-754 æ ‡å‡†å•ç²¾åº¦/åŒç²¾åº¦æµ®ç‚¹æ•°ï¼Œé»˜è®¤ä¸º `f64`

> [!success]
> åœ¨ç°ä»£ CPU ä¸­ 64 ä½æµ®ç‚¹æ•°çš„é€Ÿåº¦ä¸ 32 ä½å‡ ä¹ç›¸åŒä¸”ç²¾åº¦æ›´é«˜ã€‚

```rust
let x = 1.0; // f64
let y: f32 = 2.2; // f32
```

æµ®ç‚¹ç±»å‹åªå®ç°äº† `PartialEq`â€‹â€‹ï¼Œæ²¡æœ‰å®ç° `Eq`â€‹â€‹

# NaN

ä»£è¡¨ä¸€ä¸ªæ•°å­¦ä¸Šæœªå®šä¹‰çš„ç»“æœï¼ŒNot A Numberâ€‹ã€‚ä»»ä½• NaNâ€‹ å‚ä¸çš„æ“ä½œç»“æœä¸º NaNâ€‹ï¼Œä¸”æ— æ³•ç”¨äºä¸å…¶ä»–æ•°å­—æ¯”è¾ƒ

å¯ä»¥ä½¿ç”¨ `is_nan()`â€‹ æ–¹æ³•åˆ¤æ–­æ˜¯å¦ä¸º NaNâ€‹

```rust
fn main() {
    let x = (-42.0_f32).sqrt();
    println!("{}", x.is_nan());
}
```

# å¤æ•°

Rust æ ‡å‡†åº“ä¸å­˜åœ¨å¤æ•°ã€‚å¯ä½¿ç”¨ `num`â€‹ åº“ï¼š

```rust
use num::complex::Complex;

 fn main() {
   let a = Complex { re: 2.1, im: -1.2 };
   let b = Complex::new(11.1, 22.2);
   let result = a + b;

   println!("{} + {}i", result.re, result.im)
 }
```
# å­—ç¬¦

Rust å­—ç¬¦ç±»å‹ charâ€‹ å­—é¢é‡ä»¥ ''â€‹ å¼•ç”¨ï¼Œä»£è¡¨ä¸€ä¸ª 4 å­—èŠ‚ Unicode æ ‡é‡å€¼

```rust
let c = 'z';
let z = 'â„¤';
let heart_eyed_cat = 'ğŸ˜»';
```
# å¸ƒå°”

å¸ƒå°”å€¼ boolâ€‹ å¤šç”¨äºæ§åˆ¶è¯­å¥ï¼ŒåŒ…å« `true` â€‹ å’Œ `false` â€‹ ä¸¤ä¸ªå€¼ï¼Œå  1 å­—èŠ‚
# 整型

整型字面值可以有三部分组成 - 前缀表示进制，中间为值，后缀表示类型

`````col
````col-md
flexGrow=1
===
|       长度       |  有符号  |  无符号  |
| :------------: | :---: | :---: |
|     8 bit      |  i8   |  u8   |
|     16 bit     |  i16  |  u16  |
|     32 bit     |  i32  |  u32  |
|     64 bit     |  i64  |  u64  |
|    128 bit     | i128  | u128  |
| 平台相关(32 or 64) | isize | usize |
````
````col-md
flexGrow=1
===
```rust
let x = 1; // i32 类型 十进制 1
let y = 0xffi64; // i64 类型 十六进制 FF
let z = 0o77usize; // usize 类型 八进制 77
let w = b'A'; // u8 类型 'A' (十进制 65)
```
````
`````

> [!note]
> 为提高可读性，允许在数字字面量之间插入 `_​​` 用于分割数字：1_000​​ 等效于 1000​​，0.000_001​​ 等效于 0.000001​​

十进制不需要前缀，八进制为 `0o`​，十六进制为 `0x​`，二进制为 `0b​`， char 类型转化使用 `b​`。

后缀主要用于指定整型类型，默认为 `i32`​；`b​` 前缀用于转化字符的类型只能是 u8​。字面量的类型与变量类型可以不同，允许安全转化。

整型运算时注意整型溢出。
## 整型溢出

> [!note] 整型溢出
> 当运算结果超过整型最大值的情况被称为整型溢出。Debug 模式下 Rust 使程序 `panic!` ​​，release 模式下使用二进制补码循环溢出处理。

```rust
fn main() {
    println!("Integer overflow: 254+1={}", 254u8+1u8);
}
```

整型溢出一般被认为是一种<font color="#c0504d">错误</font>，但若依赖于整型溢出，可使用 `Wrapping`​​ 功能。

`wrapping_*` ​ 方法总是将溢出值以二进制补码包装，在 debug​ 模式下仍能运行。默认操作。

```rust
fn main() {
    println!("Integer overflow: 254+2={}", 254u8+2u8);
    println!("Wrapping add: 254+1={}", 254u8.wrapping_add(1u8));
    println!("Wrapping add: 254+2={}", 254u8.wrapping_add(2u8));
}
```

​ `checked_*​` 方法返回一个 Option​ 对象，当溢出时返回 `None`​

```rust
fn main() {
    println!("Check: 254+1={}", 254u8.checked_add(1u8).get_or_insert(0u8));
    println!("Check: 254+2={}", 254u8.checked_add(2u8).get_or_insert(0u8));
}
```

`overflowing_*` ​ 方法返回一个 `(self, bool)` ​ 类型元组，前者以补码包装，后者为是否溢出

```rust
fn main() {
    let oa = 254u8.overflowing_add(1u8);
    println!("Overflowing: 254+1=({}, {})", oa.0, oa.1);
    
    let oa = 254u8.overflowing_add(2u8);
    println!("Overflowing: 254+1=({}, {})", oa.0, oa.1);
}
```

`saturating_*​` 方法对值的最大值或最小值进行饱和处理

```rust
fn main() {
    println!("Saturating: 254+1={}", 254u8.saturating_add(1u8));
    println!("Saturating: 254+2={}", 254u8.saturating_add(2u8));
}
```

# 浮点

Rust 浮点分为 `f32` ​ 和 `f64` ​ 两种，代表 IEEE-754 标准单精度/双精度浮点数，默认为 `f64`

> [!success]
> 在现代 CPU 中 64 位浮点数的速度与 32 位几乎相同且精度更高。

```rust
let x = 1.0; // f64
let y: f32 = 2.2; // f32
```

浮点类型只实现了 `PartialEq`​​，没有实现 `Eq`​​

# NaN

代表一个数学上未定义的结果，Not A Number​。任何 NaN​ 参与的操作结果为 NaN​，且无法用于与其他数字比较

可以使用 `is_nan()`​ 方法判断是否为 NaN​

```rust
fn main() {
    let x = (-42.0_f32).sqrt();
    println!("{}", x.is_nan());
}
```

# 复数

Rust 标准库不存在复数。可使用 `num`​ 库：

```rust
use num::complex::Complex;

 fn main() {
   let a = Complex { re: 2.1, im: -1.2 };
   let b = Complex::new(11.1, 22.2);
   let result = a + b;

   println!("{} + {}i", result.re, result.im)
 }
```
# 字符

Rust 字符类型 char​ 字面量以 ''​ 引用，代表一个 4 字节 Unicode 标量值

```rust
let c = 'z';
let z = 'ℤ';
let heart_eyed_cat = '😻';
```
# 布尔

布尔值 bool​ 多用于控制语句，包含 `true` ​ 和 `false` ​ 两个值，占 1 字节
泛型是具体类型或属性的抽象替代。

```rust
// 方法
fn get_first<T>(list: &[T]) -> &T {
    // ...
    list.get(0).unwrap()
}

// 结构体
struct Point<T, U> {
    x: T,
    y: U
}

impl<T, U> Point<T, U> {
    // ...
}

// 枚举
enum Option<T> {
    None,
    Some<T>
}
```

可以给泛型增加默认值

> [!success]
> Self 可指代结构体或 Trait 类型本身

```rust
struct A;

// 默认 T=实现trait的类型，V=i32
trait B<T=Self, V=i32> {
    fn c(&self, p: T) -> V;
}

impl B for A {
    fn c(&self, p: Self) -> i32 {
        todo!()
    }
}

impl B<u32> for A {
    fn c(&self, p: u32) -> i32 {
        todo!()
    }
}
```

Rust 通过泛型代码的单态化（通过填充编译时使用的具体类型，将通用代码转化为特定代码的过程。）实现了泛型使用时性能零损耗（相当于 C++ 的模板特化）
# const 泛型

> [!warning]
> Rust 1.51 后支持 const 泛型，允许在泛型中使用 const​ 表达式实现在编译时检查

允许在泛型参数中使用 const​ 值和 const​ 表达式

```rust
fn display_array<T: std::fmt::Debug, const N: usize>(arr: [T; N]) {
    println!("{:?}", arr);
}
```

该特性可用于在编译时计算和校验

```rust
// 目前只能在nightly版本下使用
#![allow(incomplete_features)]
#![feature(generic_const_exprs)]

fn something<T>(val: T)
where
    Assert<{ core::mem::size_of::<T>() < 768 }>: IsTrue,
    //       ^-----------------------------^ 这里是一个 const 表达式
{
    //
}

fn main() {
    something([0u8; 0]); // ok
    something([0u8; 512]); // ok
    something([0u8; 1024]); // 编译错误，数组长度是1024字节，超过了768字节的参数长度限制
}

// ---
```

```rust
pub enum Assert<const CHECK: bool> {
    //
}

pub trait IsTrue {
    //
}

impl IsTrue for Assert<true> {
    //
}
```

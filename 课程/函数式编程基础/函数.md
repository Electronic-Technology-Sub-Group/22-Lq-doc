函数式编程中的函数指的是数学中的函数，即自变量的映射，具有以下特点：
* 函数是一等公民，即与其他数据类型具有相同地位，可用于参数、赋值等
* 函数是纯函数

纯函数：相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用。

副作用：与函数外部环境发生任何交互，包括但不限于任何对函数之外的状态发生改变，用户输入输出交互，HTTP 请求等

纯函数为函数式编程带来了很多优点：

* 可缓存性 Cacheable：纯函数可方便的根据输入做缓存

  * 延迟执行
* 可移植性 Portable：纯函数计算结果与外界环境无关，且不与外界产生任何交互
* 自文档化 Self-Documenting：依赖明确，便于观察和理解
* 可测试性 Testable：允许方便的自动生成输入并断言输出，不需要模拟外部环境
* 合理性 Reasonable：纯函数总是符合引用透明性的
* 并行性：纯函数不需要任何共享内存

引用透明性：一段代码可以替换成它执行所得的结果，而且是在不改变整个程序行为的前提下替换的，那么我们就说这段代码是引用透明的

最简单的一个纯函数称为 `identity` 或 `id` 函数，输入一个值，并直接返回输入的值。

函数基本运算包括函数合成（Compose）和柯里化（Curry）。

# 柯里化

柯里化：Curry，只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。

只传给函数一部分参数通常也叫做部分求值或局部调用，函数接收一些函数但不立即求值，而是返回一个保存有已有参数的新函数，直到所有参数都传入时再求值，能够大量减少样板文件代码。

`curry` 函数也是一个纯函数。每通过 `curry` 传递一个参数调用函数，就返回一个确定的新函数处理剩余的参数。某些实现中 `curry` 函数也允许一次传递多个参数，等效于多次调用 `curry` 函数。以下是 `curry` 函数的一个 Java 实现

```java
// Function3 接口
interface Function3<T1, T2, T3, R> { R invoke(T1 v1, T2 v2, T3 v3); }

// curry 方法的一种简单实现
<T1, T2, T3, R> BiFunction<T2, T3, R> curry(Function3<T1, T2, T3, R> func, T1 v1) {
    return (v2, v3) => func(v1, v2, v3);
}
```

# 代码组合

函数合成是指将多个函数组合后生成新函数的过程

pointfree：无值风格，函数无须提及将要操作的数据是什么样的。  
 -- 运算过程抽象化，处理一个值，但不提到这个值。

```java
Function f1, f2;

// 非 pointfree 形式写法
// 因为提及了传入参数 v
Function f = v -> f2.apply(f1.apply(v));

// pointfree 形式的写法
// 假设一个 compose 方法
Function compose(Function f1, Function f2);
Function f = compose(f1, f2);
```

# 高阶函数

满足以下特点之一的函数称为高阶函数

* 接受函数作为参数，如集合中常见的 `map`，`foreach`，`reduce` 等
* 返回值是一个函数，如柯里化方法等

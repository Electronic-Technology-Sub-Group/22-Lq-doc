将一串资料依照特定排序方式进行排列的一种算法。排序算法的输出必须遵守下列两个原则：
1.  输出结果为递增序列（递增是针对所需的排序顺序而言）
2.  输出结果是原输入的一种排列或是重组

排序算法通常依以下性能参数：
- 时间复杂度。一般而言，好的性能是 $O(n \log n)$，坏的性能是 $O(n^2)$，理想的性能是 $O(n)$，对大多数依赖于比较的排序而言至少需要 $O(n \log n)$。
- 内存使用量（空间复杂度）
- 稳定性：稳定排序算法会让原本有相等键值的数据维持相对次序。
- 排序方法：排序方法。分为比较排序和其他排序。其他排序有更大的限制但不受 $O(n \log n)$ 时间复杂度的限制
- 排序的方法：插入、交换、选择、合并等等。

算法的选择：
- 针对于少量数据时，可选择复杂度 $O(n^2)$ 的算法，数据量较少故而时间不会很大，实现代码比较简单，且通常只需要 `1` 的额外空间
	- [[插入排序]]在数据量较小时表现不错，一般作为快速排序的补充，可以优先选择
	- [[希尔排序]]在序列基本有序的情况下效率接近线性，在一般的情况下也比插入排序块，在基本无序的情况下会急剧恶化。使用最好的步长序列下，希尔排序在小数组中的表现甚至比快速排序和堆排序更快，但在大量数据的情况下还是不如快速排序。
	- [[选择排序]]算法表现十分稳定，且数据的交换次数较少，但用作数组时不稳定
	- [[冒泡排序]]思路简单，代码最少，但效率最低，偶尔也能用用？
- 针对于大量数据时，$O(n^2)$ 的复杂度算法通常是不可接受的
	- [[快速排序]]实际中其速度通常比其他算法更快，因为其内部循环在大部分架构上效率都很高，最坏情况也是极其罕见的。但快速排序是不稳定的，且当使用链表时，基准选择可能较差。
	- [[归并排序]]稳定且对链表等结构友好，但需要额外 $n$ 的空间和递归的函数调用。
	- [[堆排序]]使用最大堆/最小堆进行排序，数据量较少时建立堆造成的开销会非常明显，但在元素比较多时效率非常稳定，在查找最大/最小的 $n$ 个数之类的问题时几乎是首选算法
- 其他
	- [[计数排序]]适用于每个元素的大小都可以映射到一个整数，此时可做到线性的排序时间，适用于数据量不大（内存足够）且分布比较集中的情况
	- [[桶排序]]将数据分别装入有限个桶，然后将桶内数据以其他方式进行排序再进行合并。桶排序的时间复杂度与内部采用的排序方法有关，只是减少了每次排序的规模。
	- [[基数排序]]要求元素必须可以映射到整数中，整数长度在10W-100W时效率最好

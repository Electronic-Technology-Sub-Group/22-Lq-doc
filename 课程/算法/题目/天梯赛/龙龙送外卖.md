> 2022年天梯赛真题
> https://pintia.cn/problem-sets/1648134818082430976/exam/overview

难度/题目：
# 题目

龙龙是“饱了呀”外卖软件的注册骑手，负责送帕特小区的外卖。帕特小区的构造非常特别，都是双向道路且没有构成环 —— 你可以简单地认为小区的路构成了一棵树，根结点是外卖站，树上的结点就是要送餐的地址。

每到中午 12 点，帕特小区就进入了点餐高峰。一开始，只有一两个地方点外卖，龙龙简单就送好了；但随着大数据的分析，龙龙被派了更多的单子，也就送得越来越累……

看着一大堆订单，龙龙想知道，从外卖站出发，访问所有点了外卖的地方至少一次（这样才能把外卖送到）所需的最短路程的距离到底是多少？每次新增一个点外卖的地址，他就想估算一遍整体工作量，这样他就可以搞明白新增一个地址给他带来了多少负担。
## 输入格式

输入第一行是两个数 N 和 M (2≤N≤105, 1≤M≤105)，分别对应树上节点的个数（包括外卖站），以及新增的送餐地址的个数。

接下来首先是一行 N 个数，第 i 个数表示第 i 个点的双亲节点的编号。节点编号从 1 到 N，外卖站的双亲编号定义为 −1。

接下来有 M 行，每行给出一个新增的送餐地点的编号 Xi​。保证送餐地点中不会有外卖站，但地点有可能会重复。

为了方便计算，我们可以假设龙龙一开始一个地址的外卖都不用送，两个相邻的地点之间的路径长度统一设为 1，且从外卖站出发可以访问到所有地点。

注意：所有送餐地址可以按任意顺序访问，_**且完成送餐后无需返回外卖站**_。
## 输出格式

对于每个新增的地点，在一行内输出题目需要求的最短路程的距离。
## 样例
### 输入

```
7 4
-1 1 1 1 2 2 3
5
6
2
4
```
### 输出

```
2
4
4
6
```
## 代码限制

代码长度限制：16 KB

Java (javac)

时间限制：1400 ms
内存限制：256 MB

Python (python3)

时间限制：600 ms
内存限制：64 MB

其他编译器

时间限制：400 ms
内存限制：64 MB
栈限制：131072 KB
# 思路

最短路径长度为 $2\times 总路径 - 最长路径$：
- 设全部路径没有分叉，$2n-n=n$ 成立
- 设从 p 点开始分叉，分叉后两条岔路子路径分别为$n_1$，$n_2$，设 $n_1\leq n_2$，取 $n_1$ 岔路走过后返回，$n_2$ 不返回，路程最短，长度为 $2n_1+n_2=2(n_1+n_2)-n_2$

使用一次 DFS 统计每个路径的高度（用于确定最长路径），之后每加一个点从下向上统计即可。
# 答案

```cpp
#include <iostream>
#include <vector>

using namespace std;

// n 个节点，m 个送达地点
// h 每个节点的父节点
// l 每个节点的高度
int n, m, h[100010], l[100010];
// c 每个节点的子节点
vector<int> c[100010];
// 某个节点是否已经被计算过
bool selected[100010];

// 需要经过的所有路径, 最长路径
int total_path, longest_path;

// 计算每个节点的高度
void dfs_height(int i, int base) {
    l[i] = base;
    for (int k: c[i]) {
        dfs_height(k, base + 1);
    }
}

int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; ++i) {
        cin >> h[i];
        if (h[i] == -1) h[i] = 0;
        c[h[i]].push_back(i);
    }
    dfs_height(0, 0);

    int k;
    while (m--) {
        cin >> k;
        if (k < 0) k = 0;
        // 更新最长路径
        longest_path = max(longest_path, l[k] + 1);
        // 更新总路径
        while (k && !selected[k]) {
            total_path++;
            selected[k] = true;
            k = h[k];
        }

        cout << (total_path * 2 - longest_path) << endl;
    }

    return 0;
}
```